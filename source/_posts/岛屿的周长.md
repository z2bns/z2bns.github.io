---
title: 岛屿的周长
date: 2020-11-23 20:44:39
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/island-perimeter/submissions/)**

**难度：**⭐

###### **题目描述：**

给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。

网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

<!-- more -->

**示例1：**

![img](%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/island.png)

```
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
```

**示例2：**

```
输入：grid = [[1]]
输出：4
```

**示例3：**

```
输入：grid = [[1,0]]
输出：4
```

**提示：**

- `row == grid.length`
- `col == grid[i].length`
- `1 <= row, col <= 100`
- `grid[i][j]` 为 `0` 或 1



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

分析网格图我们可以看出一格本来是四条边都要算周长的，若它上方有格则它上面这条边就不算周长了变成了3条有效边了，下方和左右两方也是一样的，所以得到如下思路。

遍历二维网格中的每一块，如果当前块为陆地1，则依次判断上下左右是否有相邻块，每相邻一个初始值4就减去1，最后把当前块的有效边数加到周长上，遍历结束时返回周长。

**c++代码：**(执行用时192ms，击败90.14%，内存消耗94.2M，击败34.26%）

```c++
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int result=0;
        int row=grid.size();
        int col=grid[0].size();
        for(int i=0;i<row;++i){
            for(int j=0;j<col;++j){
                if(grid[i][j]==1){
                    //每个块4条边
                    int tmp=4;
                    if(i-1>=0 && grid[i-1][j]==1){
                        //上格元素是1,当前块去掉上面一条边
                        --tmp;
                    }
                    if(i+1<row && grid[i+1][j]==1){
                        //下格元素是1
                        --tmp;
                    }
                    if(j-1>=0 && grid[i][j-1]==1){
                        //左格元素是1
                        --tmp;
                    }
                    if(j+1<col && grid[i][j+1]==1){
                        //右格元素是1
                        --tmp;
                    }
                    result+=tmp;
                }
            }
        }
        return result;
    }
};
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/island-perimeter/solution/dao-yu-de-zhou-chang-by-leetcode-solution/):

**方法一：迭代**

**思路与算法**

对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 $1$）加入答案 $\textit{ans}$中即可。

**c++代码：**(执行用时232ms，击败31.64%，内存消耗94.2M，击败49.13%）

```c++
class Solution {
    constexpr static int dx[4] = {0, 1, 0, -1};
    constexpr static int dy[4] = {1, 0, -1, 0};
public:
    int islandPerimeter(vector<vector<int>> &grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j]) {
                    int cnt = 0;
                    for (int k = 0; k < 4; ++k) {
                        int tx = i + dx[k];
                        int ty = j + dy[k];
                        if (tx < 0 || tx >= n || ty < 0 || ty >= m || !grid[tx][ty]) {
                            cnt += 1;
                        }
                    }
                    ans += cnt;
                }
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nm)$，其中 n 为网格的高度，$m$ 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 $4$ 个格子是否为岛屿，因此总时间复杂度为 $O(4nm)=O(nm)$。

- 空间复杂度：$O(1)$。只需要常数空间存放若干变量。


**方法二：深度优先搜索**

**思路与算法**

我们也可以将方法一改成深度优先搜索遍历的方式，此时遍历的方式可扩展至统计多个岛屿各自的周长。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 $2$ 的格子为已经遍历过的陆地格子。

**c++代码：**(执行用时224ms，击败41.57%，内存消耗94.6M，击败13.01%）

```c++
class Solution {
    constexpr static int dx[4] = {0, 1, 0, -1};
    constexpr static int dy[4] = {1, 0, -1, 0};
public:
    int dfs(int x, int y, vector<vector<int>> &grid, int n, int m) {
        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0) {
            return 1;
        }
        if (grid[x][y] == 2) {
            return 0;
        }
        grid[x][y] = 2;
        int res = 0;
        for (int i = 0; i < 4; ++i) {
            int tx = x + dx[i];
            int ty = y + dy[i];
            res += dfs(tx, ty, grid, n, m);
        }
        return res;
    }
    int islandPerimeter(vector<vector<int>> &grid) {
        int n = grid.size(), m = grid[0].size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    ans += dfs(i, j, grid, n, m);
                }
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nm)$，其中 $n$ 为网格的高度，$m$ 为网格的宽度。每个格子至多会被遍历一次，因此总时间复杂度为 $O(nm)$。

- 空间复杂度：$O(nm)$。深度优先搜索复杂度取决于递归的栈空间，而栈空间最坏情况下会达到 $O(nm)$。




<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

官方题解第一种方法和我的思路是一致的，第二种方法深度优先搜索也是比较重要的方法，不过对于这道简单题来讲还是复杂了些，第一种方法就挺好🤔。