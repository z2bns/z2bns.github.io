---
title: 键盘行
date: 2020-11-27 10:55:54
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/flipping-an-image/)**

**难度：**⭐

###### **题目描述：**

给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。

<!-- more -->

![American keyboard](%E9%94%AE%E7%9B%98%E8%A1%8C/keyboard.png)

**示例：**

```
输入: ["Hello", "Alaska", "Dad", "Peace"]
输出: ["Alaska", "Dad"]
```

**注意：**

1. 你可以重复使用键盘上同一字符。
2. 你可以假设输入的字符串将只包含字母。



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

定义一个map集合，存储字母到数字的映射，键盘第一行字母对应1，第二行对应2，第三行对应3。遍历单词列表，遍历每一个单词字母，判断字母（转成小写）在map中的值是否相等，若不相等break继续下一个单词，若单词字母都在同一行就存储到结果集中。

**c++代码：**(执行用时4ms，击败45.62%，内存消耗7.3M，击败23.05%）

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) {
        vector<string> result;
        unordered_map<char,int> m;
        string line1="qwertyuiop";
        string line2="asdfghjkl";
        string line3="zxcvbnm";
        for(char c1:line1){
            m[c1]=1;
        }
        for(char c2:line2){
            m[c2]=2;
        }
        for(char c3:line3){
            m[c3]=3;
        }
        char tmp1,tmp2;
        for(string word:words){
            int n=word.length();
            int i=0;
            for(i=0;i<n-1;++i){
                //将字母转换成小写
                tmp1=word[i]|32;
                tmp2=word[i+1]|32;
                if(m[tmp1]!=m[tmp2]){
                    break;
                }
            }
            //使用键盘同一行字母打印的单词
            if(i==n-1){
                result.emplace_back(word);
            }
        }
        return result;

    }
};
```



<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

没有官方题解，虽然代码长了些，但也还行吧🙄。

