---
title: 数字的补数
date: 2020-11-27 11:28:01
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/number-complement/)**

**难度：**⭐

###### **题目描述：**

给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

<!-- more -->

**示例1：**

```
输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

**示例2：**

```
输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

**注意:**

- 给定的整数保证在 32 位带符号整数的范围内。
- 你可以假定二进制数不包含前导零位。
- 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

对正整数二进制表示取反，取反就是和1异或运算，这样1\^1=0;0\^1=1。所以只要计算出没有前导零位时二进制表示位数全为1时的数值，例如5二进制表示为101（3位），计算出111（3位）对应的数值为7，返回5^7=2。

**c++代码：**(执行用时0ms，击败100.00%，内存消耗6.2M，击败23.56%）

```c++
class Solution {
public:
    int findComplement(int num) {
        double n=1;
        int tmp=num;
        while(tmp){
            n*=2;
            tmp/=2;
        }
        return num^((int)(n-1));
    }
};
```



<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

没有官方题解，也没有总结，就是这么任性😎。