---
title: 第213场周赛
date: 2020-11-02 12:28:31
categories:
- ACM
- CONTEST
tags:
- LeetCode周赛
---

[比赛地址](https://leetcode-cn.com/contest/weekly-contest-213/)

###### 比赛说明

本场竞赛由「coupang」&「力扣」联合主办

**【工作机会奖励】**

- **排名第 1 ~ 300 名的参赛者**可获「 coupang」简历内推机会。

**【实物周边奖励】**

- **排名第 1 名的参赛者**可获coupang提供的「小爱音响」×1
- **排名第 2 名的参赛者**可获coupang提供的「小米手环」×1
- **排名第 3 ~ 55 名的参赛者**可获coupang「棒球帽」×1
- **排名第 199、399、599、999、1999 名的参赛者**可获coupang「棒球帽」×1

<!-- more -->

重要提示**

1. 请注意，每个错误提交的惩罚时间已经从 **10分钟** 改变为了 **5分钟** 。

2. 力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 **零容忍** 的态度维护竞赛的公平、公正。

3. 以下被判定为竞赛中的违规行为

   - 一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）

   - 通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的
   - 多账号提交雷同代码（抄袭）
   - 使用不正当手段影响他人竞赛的
   - 竞赛结束前在讨论区发布答案的

4. 如被发现违规行为，我们将会严格按照以下处罚规则执行：

   - **第一次违规**：账号内的所有积分清零，账号冻结 1 个月

   - **第二次违规**：永久封号

5. 同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：

   - 被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励

   - 每人每场最高可获得举报成功的 100 积分奖励


###### 题目列表重要提示**

1. 请注意，每个错误提交的惩罚时间已经从 **10分钟** 改变为了 **5分钟** 。

2. 力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 **零容忍** 的态度维护竞赛的公平、公正。

3. 以下被判定为竞赛中的违规行为

   - 一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）

   - 通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的
   - 多账号提交雷同代码（抄袭）
   - 使用不正当手段影响他人竞赛的
   - 竞赛结束前在讨论区发布答案的

4. 如被发现违规行为，我们将会严格按照以下处罚规则执行：

   - **第一次违规**：账号内的所有积分清零，账号冻结 1 个月

   - **第二次违规**：永久封号

5. 同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：

   - 被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励

   - 每人每场最高可获得举报成功的 100 积分奖励


###### 题目列表

| 题目                                                         | 难度 | 得分 |
| ------------------------------------------------------------ | ---- | ---- |
| 1.[能否连接形成数组](https://leetcode-cn.com/problems/check-array-formation-through-concatenation/) | 简单 | 3    |
| 2.[统计字典序元音字符串的数目](https://leetcode-cn.com/problems/count-sorted-vowel-strings/) | 中等 | 4    |
| 3.[可以到达的最远建筑](https://leetcode-cn.com/problems/furthest-building-you-can-reach/) | 中等 | 5    |
| 4.[第 K 条最小指令](https://leetcode-cn.com/problems/kth-smallest-instructions/) | 困难 | 6    |

###### 能否连接形成数组

**题目描述：**

给你一个整数数组 `arr` ，数组中的每个整数 **互不相同** 。另有一个由整数数组构成的数组 `pieces`，其中的整数也 `互不相同` 。请你以 **任意顺序** 连接 `pieces` 中的数组以形成 `arr` 。但是，**不允许** 对每个数组 `pieces[i]` 中的整数重新排序。

如果可以连接 `pieces` 中的数组形成 `arr` ，返回 `true` ；否则，返回 `false` 。



**示例1：**

```
输入：arr = [85], pieces = [[85]]
输出：true
```

**示例2：**

```
输入：arr = [15,88], pieces = [[88],[15]]
输出：true
解释：依次连接 [15] 和 [88]
```

**示例3：**

```
输入：arr = [49,18,16], pieces = [[16,18,49]]
输出：false
解释：即便数字相符，也不能重新排列 pieces[0]
```

**示例4：**

```
输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
输出：true
解释：依次连接 [91]、[4,64] 和 [78]
```

**示例5：**

```
输入：arr = [1,3,5,7], pieces = [[2,4,6,8]]
输出：false
```

**提示：**

- `1 <= pieces.length <= arr.length <= 100`
- `sum(pieces[i].length) == arr.length`
- `1 <= pieces[i].length <= arr.length`
- `1 <= arr[i], pieces[i][j] <= 100`
- `arr` 中的整数 **互不相同**
- `pieces` 中的整数 **互不相同**（也就是说，如果将 `pieces` 扁平化成一维数组，数组中的所有整数互不相同）

**思路：**



**提交的代码：**



```c++

//草稿版
class Solution {
public:
    bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {
        //遍历查找pieces中的元素是否在arr中
        for(int i=0;i<pieces.size();++i){
            for(int j=0;j<pieces[i].size();++j){
                for(int k=0;k<arr.size();++k){

                    if(pieces[i][j]==arr[k]){
                        break;
                    }
                }

            }

        }


        //遍历arr

        for(int i=0;i<arr.size();++i){
            //遍历pieces
            for(int j=0;j<pieces.size();++j){

                if(arr[i])
            }
            if(arr[i])

        }

    }
};
```



###### 可以到达的最远建筑

**题目描述：**

给你一个整数数组 `heights` ，表示建筑物的高度。另有一些砖块 `bricks` 和梯子 `ladders` 。

你从建筑物 `0` 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。

当从建筑物 `i` 移动到建筑物 `i+1`（下标 **从 0 开始** ）时：

- 如果当前建筑物的高度 **大于或等于** 下一建筑物的高度，则不需要梯子或砖块
- 如果当前建筑的高度 **小于** 下一个建筑的高度，您可以使用 **一架梯子** 或 (`h[i+1] - h[i]`) 个砖块

如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 **从 0 开始** ）。

![img](%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/q4.gif)

**示例1：**

```c++
输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1
输出：4
解释：从建筑物 0 出发，你可以按此方案完成旅程：
- 不使用砖块或梯子到达建筑物 1 ，因为 4 >= 2
- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 < 7
- 不使用砖块或梯子到达建筑物 3 ，因为 7 >= 6
- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 < 9
无法越过建筑物 4 ，因为没有更多砖块或梯子。
```

**示例2：**

```
输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2
输出：7
```

**示例3：**

```
输入：heights = [14,3,19,3], bricks = 17, ladders = 0
输出：3
```



**提示：**

- 1 <= heights.length <= 105
- 1 <= heights[i] <= 106
- 0 <= bricks <= 109
- 0 <= ladders <= heights.length

**思路：**



**提交的代码：**



###### 第K条最小指令

**题目描述：**

Bob 站在单元格 `(0, 0)` ，想要前往目的地 `destination` ：`(row, column)` 。他只能向 **右** 或向 `下` 走。你可以为 Bob 提供导航 **指令** 来帮助他到达目的地 `destination` 。

**指令** 用字符串表示，其中每个字符：

- `'H'` ，意味着水平向右移动
- `'V'` ，意味着竖直向下移动

能够为 Bob 导航到目的地 `destination` 的指令可以有多种，例如，如果目的地 `destination` 是 `(2, 3)`，`"HHHVV"` 和 `"HVHVH"` 都是有效 指令 。

然而，Bob 很挑剔。因为他的幸运数字是 `k`，他想要遵循 **按字典序排列后的第 `k` 条最小指令** 的导航前往目的地 `destination` 。`k`  的编号 **从 1 开始** 。

给你一个整数数组 `destination` 和一个整数 `k` ，请你返回可以为 Bob 提供前往目的地 `destination` 导航的 **按字典序排列后的第 `k` 条最小指令** 。



**示例1：**

![img](%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex1.png)

```
输入：destination = [2,3], k = 1
输出："HHHVV"
解释：能前往 (2, 3) 的所有导航指令 按字典序排列后 如下所示：
["HHHVV", "HHVHV", "HHVVH", "HVHHV", "HVHVH", "HVVHH", "VHHHV", "VHHVH", "VHVHH", "VVHHH"].
```

**示例2：**

![img](%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex2.png)

```
输入：destination = [2,3], k = 2
输出："HHVHV"
```

**示例3：**

![img](%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex3.png)

```
输入：destination = [2,3], k = 3
输出："HHVVH"
```



**提示：**

- `destination.length == 2`
- `1 <= row, column <= 15`
- `1 <= k <= nCr(row + column, row)`，其中 `nCr(a, b)` 表示组合数，即从 `a` 个物品中选 `b` 个物品的不同方案数。

**思路：**



**提交的代码：**







###### 统计字典序元音字符串的数目

**题目描述：**

给你一个整数 `n`，请返回长度为 `n` 、仅由元音 (`a`, `e`, `i`, `o`, `u`) 组成且按 **字典序排列** 的字符串数量。

字符串 `s` 按 **字典序排列** 需要满足：对于所有有效的 `i`，`s[i]` 在字母表中的位置总是与 `s[i+1]` 相同或在 `s[i+1]` 之前。



**示例1：**

```c++
输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 ["a","e","i","o","u"]
```

**示例2：**

```c++
输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]
注意，"ea" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
```

**示例3：**

```c++
输入：n = 33
输出：66045
```



**提示：**

- `1 <= n <= 50` 

**思路：**



**提交的代码：**





###### 总结

这次比赛虽然也打开网站，做题1个半小时，但是心太浮躁了，尤其是今天是周日是休息的日子，自己迟到了5、6分钟，刷题量少，也没什么信心，事情也有点多，数学、机器学习、论文等反正好多东西。最简单的一道题都没做出了根本就没思路，希望自己可以保持学习的激情，下次努力，一直坚持一定会有回报的😥