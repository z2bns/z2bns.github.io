---
title: 两句话中的不常见单词
date: 2020-12-29 13:05:33
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/)**

**难度：**⭐

###### **题目描述：**

给定两个句子 `A` 和 `B` 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）

如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。

返回所有不常用单词的列表。

您可以按任何顺序返回列表。

<!-- more -->

**示例1：**

```
输入：A = "this apple is sweet", B = "this apple is sour"
输出：["sweet","sour"]
```

**示例2：**

```
输入：A = "apple apple", B = "banana"
输出：["banana"]
```

**提示：**

1. `0 <= A.length <= 200`
2. `0 <= B.length <= 200`
3. `A` 和 `B` 都只包含空格和小写字母。



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

根据题目描述可以得出不常见单词就是在两个句子中出现总次数等于1的单词。于是遍历字符串A和B，空格作为单词之间的分隔使用计数法统计不同单词出现的次数存储在哈希容器中，最后遍历哈希容器把出现次数为1的单词添加到结果中。

**c++代码：**(执行用时0ms，击败100.00%，内存消耗7.2M，击败54.11%）

```c++
class Solution {
public:
    vector<string> uncommonFromSentences(string A, string B) {
        unordered_map<string,int> m;
        vector<string> result;
        string tmp="";
        //为了处理最后一个单词给句子加上一个尾空格
        A+=" ";
        B+=" ";
        for(char c:A){
            if(c!=' '){
                tmp+=c;
            }else{
                ++m[tmp];
                tmp="";
            }
        }
        for(char c:B){
            if(c!=' '){
                tmp+=c;
            }else{
                ++m[tmp];
                tmp="";
            }
        }
        for(auto [i,j]:m){
            if(j==1){
                result.emplace_back(i);
            }
        }
        return result;
    }
};
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/solution/liang-ju-hua-zhong-de-bu-chang-jian-dan-ci-by-leet/):

#### 方法 ：计数

**思路和算法**

个不常见的单词总共只出现一次。我们可以统计每个单词的出现次数，然后返回恰好出现一次的单词。

**Java代码：**

```java
class Solution {
    public String[] uncommonFromSentences(String A, String B) {
        Map<String, Integer> count = new HashMap();
        for (String word: A.split(" "))
            count.put(word, count.getOrDefault(word, 0) + 1);
        for (String word: B.split(" "))
            count.put(word, count.getOrDefault(word, 0) + 1);

        List<String> ans = new LinkedList();
        for (String word: count.keySet())
            if (count.get(word) == 1)
                ans.add(word);

        return ans.toArray(new String[ans.size()]);
    }
}
```

**复杂度分析**

- 时间复杂度：$O(M + N)$，其中 $M$, $N$分别是 `A` 和 `B` 的长度。

- 空间复杂度：$O(M + N)$，`count` 所用去的空间。




<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

这道题的最优解应该就是使用计数法求解了，官方题解是使用Java语言做的，毕竟Java封装好了很多方法，比如直接把字符串通过split()方法根据空格分解成单词，不过使用C++也不错，总的来说题目比较简单。

