---
title: 自除数
date: 2020-11-13 22:38:06
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/self-dividing-numbers/)**

**难度：**⭐

###### **题目描述：**

自除数 是指可以被它包含的每一位数除尽的数。

例如，128 是一个自除数，因为 `128 % 1 == 0`，`128 % 2 == 0`，`128 % 8 == 0`。

还有，自除数不允许包含 0 。

给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。

<!-- more -->

**示例1：**

```
输入： 
上边界left = 1, 下边界right = 22
输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
```

**注意：**

- 每个输入参数的边界满足 `1 <= left <= right <= 10000`。



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

直接遍历给定范围内的数，依次判断是否为自除数。不为自除数的情况有两种，一种是某位数为0，一种是不能被某个位数除尽，直接模拟。

**c++代码：**(执行用时0ms，击败100%，内存消耗6.9M，击败8.06%）

```c++
class Solution {
public:
    vector<int> selfDividingNumbers(int left, int right) {
        vector<int> result;
        for(int i=left;i<=right;++i){
            int tmp=i;
            while(tmp){
                //某位数为0或者不能被该位数除尽，不是自除数
                if(tmp%10==0 || i%(tmp%10)!=0){
                    break;
                }else if(tmp/10==0){
                    //最后一位数了,满足自除数条件
                    result.push_back(i);
                }
                tmp/=10;
            }
        }
        return result;
    }
};
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/self-dividing-numbers/solution/zi-chu-shu-by-leetcode/):

**方法一：暴力法**

**算法：**

对于给定范围内的每个数，我们将直接判断该数是否为自除数。
根据定义，我们先判断数字是否非零，若数字非零再判断是否能够被该数除尽。例如，对于 128，我们要判断 `d != 0 && 128 % d == 0`，且 `d = 1, 2, 8`。
解决这个问题的一个简单方法是将数字转换成一个字符数组（python 中的字符串），然后在检查 `n%d==0` 时转换回整数执行模运算。
我们还可以不断地把数字除以 `10`，取整数的最后一个数字。在代码中为注释的部分。

**Java代码：**

```java
class Solution {
    public List<Integer> selfDividingNumbers(int left, int right) {
        List<Integer> ans = new ArrayList();
        for (int n = left; n <= right; ++n) {
            if (selfDividing(n)) ans.add(n);
        }
        return ans;
    }
    public boolean selfDividing(int n) {
        for (char c: String.valueOf(n).toCharArray()) {
            if (c == '0' || (n % (c - '0') > 0))
                return false;
        }
        return true;
    }
    /*
    Alternate implementation of selfDividing:
    public boolean selfDividing(int n) {
        int x = n;
        while (x > 0) {
            int d = x % 10;
            x /= 10;
            if (d == 0 || (n % d) > 0) return false;
        }
        return true;
    */
}
```

**复杂度分析**

- 时间复杂度：$O(D)$。$D$是在区间 $[L, R]$ 里的整数数。
- 空间复杂度：$O(D)$，使用了一个数组来存放结果。



<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

思路基本一样，题解给出了Python和Java两个版本的代码，没啥可分析的。




