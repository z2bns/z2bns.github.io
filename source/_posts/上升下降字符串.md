---
title: 上升下降字符串
date: 2020-11-17 17:04:45
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/increasing-decreasing-string/)**

**难度：**⭐

###### **题目描述：**

给你一个字符串 `s` ，请你根据下面的算法重新构造字符串：

1. 从 `s` 中选出 **最小** 的字符，将它 **接在** 结果字符串的后面。
2. 从 `s` 剩余字符中选出 **最小** 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
3. 重复步骤 2 ，直到你没法从 `s` 中选择字符。
4. 从 `s` 中选出 **最大** 的字符，将它 **接在** 结果字符串的后面。
5. 从 `s` 剩余字符中选出 **最大** 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
6. 重复步骤 5 ，直到你没法从 `s` 中选择字符。
7. 重复步骤 1 到 6 ，直到 `s` 中所有字符都已经被选过。

在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 `s` 中字符重新排序后的 **结果字符串** 。

<!-- more -->

**示例1：**

```
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"
解释：第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc" ，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"
```

**示例2：**

```
输入：s = "rat"
输出："art"
解释：单词 "rat" 在上述算法重排序以后变成 "art"
```

**示例3：**

```
输入：s = "leetcode"
输出："cdelotee"
```

**示例4：**

```
输入：s = "ggggggg"
输出："ggggggg"
```

**示例5：**

```
输入：s = "spo"
输出："ops"
```

**提示：**

- `1 <= s.length <= 500`
- `s` 只包含小写英文字母。



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

一开始尝试使用暴力模拟，先给字符串字符sort非递减排序。第一轮正向遍历求出一串升序字符串，反向遍历求出一串降序字符串然后循环直到所有字符都已被选过。运行超出时间限制了，意料之中遍历太慢了。

重新思考，注意到提示中s只包含小写英文字母，想到了从没用过的计数法，使用大小为26的数组存储字符串中字符出现的个数，然后正向将出现的字母依次放入结果字符串中，放入字母后，该字母的数量应该减1，然后再反向遍历放入字母，直到数组中元素的值为0即所有字符都已被选过。

**c++代码：**(执行用时12ms，击败56.24%，内存消耗7.9M，击败26.54%）

```
class Solution {
public:
    string sortString(string s) {
        //计数法
        string result="";
        //因为s只包含小写英文字母,用数组存储每个字母的个数
        vector<int> num(26,0);
        int i;
        for(i=0;i<s.length();++i){
            ++num[s[i]-'a'];
        }
        //数组num中元素最大值大于零就表示还有字符没有选过
        while(*max_element(num.begin(),num.end())>0){
            //从前往后遍历，选出最小字符
            for(i=0;i<26;++i){
                if(num[i]!=0){
                    result+=i+'a';
                    //当前字符数量减一
                    --num[i];
                }
            }
            //从后往前遍历，选出最大字符
            for(i=25;i>=0;--i){
                if(num[i]!=0){
                    result+=i+'a';
                    --num[i];
                }
            }      
        }
        return result;
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/increasing-decreasing-string/solution/shang-sheng-xia-jiang-zi-fu-chuan-by-leetcode-solu/):

**方法一：桶记数**

**思路**

我们可以开一个长度为 26 的数组表示 26 个桶，每个桶里存放一种字母。先用 $O(|s|)$ 的时间扫描一遍字符串（其中 $|s|$代表字符串的长度），统计每个字母出现的次数。然后我们只要不停地扫描这里的「桶序列」——先从小到大扫，再从大到小扫，每次发现一个桶当中计数值不为 0 的时候，就把这个桶对应的字母添加到结果字符串的最后方，然后对计数值减一。

具体地，开一个长度为 26 的数组 `h[]`，作为用来计数的「桶」。`haveChar` 的功能是在每次循环开始执行之前判断是否还有未使用的字符。`appendChar` 的功能是检测当前位置的桶是否计数值为 0，如果不为 0 则修改目标串和计数值。

**c++代码：**(执行用时0ms，击败100.00%，内存消耗7.8M，击败28.96%）

```c++
class Solution {
public:
    int h[26];

    inline bool haveChar() {
        for (int i = 0; i < 26; ++i) {
            if (h[i]) {
                return true;
            }
        }
        return false;
    }

    string sortString(string s) {
        for (const auto &c: s) ++h[c - 'a'];

        string ret;

        auto appendChar = [&] (int p) {
            if (h[p]) {
                --h[p];
                ret.push_back(p + 'a');
            }
        };

        while (true) {
            if (!haveChar()) break;
            for (int i = 0; i < 26; ++i) appendChar(i);
            for (int i = 25; i >= 0; --i) appendChar(i);
        }

        return ret;
    }
};
```

**复杂度分析**

- 时间复杂度：考虑最坏情况下字符串 $s$ 中 $|s|$ 个字符全部是同一个字母，最外层的 `while` 循环就要执行 $\lceil \frac{|s|}{2} \rceil$ 次（其中 $\lceil x \rceil$表示 $x$向上取整），每次执行中又包含 3 个执行 26 次的循环，故这里的渐进时间复杂度为 $O(3 \times 26 \times |s|) = O(|s|)$。
- 空间复杂度：这里使用了长度为 26 的数组作为辅助空间，故渐进空间复杂度为 $O(26)$。




<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

官方题解也是用的计数法，还改了个名字叫桶计数🤣，嗯，简单题不难，只要努力去做都会做出来的。