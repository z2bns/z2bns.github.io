---
title: 独一无二的出现次数
date: 2020-11-23 19:55:49
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/unique-number-of-occurrences/)**

**难度：**⭐

###### **题目描述：**

给你一个整数数组 `arr`，请你帮忙统计数组中每个数的出现次数。

如果每个数的出现次数都是独一无二的，就返回 `true`；否则返回 `false`。

<!-- more -->

**示例1：**

```
输入：arr = [1,2,2,1,1,3]
输出：true
解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。
```

**示例2：**

```
输入：arr = [1,2]
输出：false
```

**示例3：**

```
输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]
输出：true
```

**提示：**

- `1 <= arr.length <= 1000`
- `-1000 <= arr[i] <= 1000`



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

使用计数法，定义一个大小为2000的数组tmp，遍历整数数组arr，每个元素i出现的次数传到数组tmp中的下标索引i处。接下来只需要判断数组tmp中是否有重复的元素，遍历数组tmp对每个大于0的元素值和索引存储到map容器中，值作为键，索引作为map的值，利用map容器键相同值覆盖的特性，只要tmp中元素值有相同的，map容器中的元素个数一定会和tmp中大于0的元素个数不相同。

**c++代码：**(执行用时4ms，击败90.69%，内存消耗8.8M，击败6.72%）

```c++
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        vector<int> tmp(2000,0);
        for(int i:arr){
            ++tmp[1000+i];
        }
        int tmp2=0;
        map<int,int> m;
        for(int j=0;j<2000;++j){
            if(tmp[j]>0){
                m[tmp[j]]=j;
                ++tmp2;
            }
        }
        return tmp2==m.size();
    }
};
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/unique-number-of-occurrences/solution/du-yi-wu-er-de-chu-xian-ci-shu-by-leetcode-solutio/):

**方法一：哈希表**

首先使用哈希表记录每个数字的出现次数；随后再利用新的哈希表，统计不同的出现次数的数目。如果不同的出现次数的数目等于不同数字的数目，则返回 $\textit{true}$，否则返回 $\textit{false}$。

**c++代码：**(执行用时4ms，击败90.69%，内存消耗8.5M，击败50.19%）

```c++
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int, int> occur;
        for (const auto& x: arr) {
            occur[x]++;
        }
        unordered_set<int> times;
        for (const auto& x: occur) {
            times.insert(x.second);
        }
        return times.size() == occur.size();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(N)$，其中 $N$ 为数组的长度。遍历原始数组需要 $O(N)$时间，而遍历中间过程产生的哈希表又需要 $O(N)$ 的时间。

- 空间复杂度：$O(N)$。




<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

官方题解和我的思路一样，不过表达的比我清楚（我也会越来越好的），stl容器用的也比我6（嘘！我会回悄悄地野蛮生长🙂），代码写的比我的简洁。