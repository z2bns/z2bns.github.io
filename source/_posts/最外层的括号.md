---
title: 最外层的括号
date: 2020-11-13 22:08:42
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/remove-outermost-parentheses/)**

**难度：**⭐

###### **题目描述：**

有效括号字符串为空 `("")`、`"(" + A + ")"` 或 `A + B`，其中 `A` 和 `B` 都是有效的括号字符串，+ 代表字符串的连接。例如，`""`，`"()"`，`"(())()"` 和 `"(()(()))"` 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 `S = A+B` 的方法，我们称其为**原语（primitive）**，其中 `A` 和 `B` 都是非空有效括号字符串。

给出一个非空有效字符串 `S`，考虑将其进行原语化分解，使得：`S = P_1 + P_2 + ... + P_k`，其中 `P_i` 是有效括号字符串原语。

对 `S` 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 `S` 。

<!-- more -->

**示例1：**

```
输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

**示例2：**

```
输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```

**示例3：**

```
输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
```

**提示：**

1. `S.length <= 10000`
2. `S[i]` 为 `"("` 或 `")"`
3. `S` 是一个有效括号字符串



<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

使用STL模板库中的stack，左括号'('入栈，右括号')'出栈。遍历字符串的每一个字符，判断是否是最外层括号，只需要判断栈中是否只有一个左括号'('且下一个元素是右括号')'。

**c++代码：**(执行用时4ms，击败86.98%，内存消耗6.8M，击败58.35%）

```c++
class Solution {
public:
    string removeOuterParentheses(string S) {
        string result="";
        stack<char> st;
        for(int i=0;i<S.length();++i){
            if(st.empty()){
                //若栈空，则入栈
                st.push(S[i]);
            }else{
                //若栈元素个数为1
                if(st.top()==S[i]){
                    //栈中元素与当前字符相同，则继续入栈,并把当前字符存到结果字符串中
                    st.push(S[i]);
                    result+=S[i];
                }else{
                    //与栈中元素不同，也就是说是匹配的括号(),出栈
                    st.pop();
                    //不是最外层括号，存到结果中
                    if(!st.empty()){
                        result+=S[i];
                    }
                }

            }
        }
        return result;
    }
};
```




<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

没有官方题解，也挺简单的，不聊了。😏

