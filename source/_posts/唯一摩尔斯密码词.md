---
title: 唯一摩尔斯密码词
date: 2020-11-13 22:36:31
mathjax: true
categories:
- ACM
- LeetCode
tags:
- 算法
- 简单
---

**[题目地址](https://leetcode-cn.com/problems/unique-morse-code-words/)**

**难度：**⭐

###### **题目描述：**

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: `"a"` 对应 `".-"`, "b" 对应 `"-..."`, `"c"` 对应 `"-.-."`, 等等。

<!-- more -->

为了方便，所有26个英文字母对应摩尔斯密码表如下：

```
[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]
```

给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + ".-" + "-..." 字符串的结合)。我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

```
例如:
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
```

**注意:**

- 单词列表`words` 的长度不会超过 `100`。
- 每个单词 `words[i]`的长度范围为 `[1, 12]`。
- 每个单词 `words[i]`只包含小写字母。

<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

###### 解题过程：

**思路：**

建立摩尔斯密码和字母之间的映射，遍历words数组，对每一个单词求出对应的翻译，然后作为键存到map容器中，单词作为它的值。这样不同单词有相同翻译的时候，只会在map中存储一次，相同的键后面会覆盖前面的值。最后答案就是map容器元素的个数。

**c++代码：**(执行用时8ms，击败65.97%，内存消耗8.9M，击败15.82%）

```c++
class Solution {
public:
    int uniqueMorseRepresentations(vector<string>& words) {
        string s[26]={".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
        string alp="abcdefghijklmnopqrstuvwxyz";
        map<string,string> m;
        //遍历单词列表
        for(int i=0;i<words.size();++i){
            string tmp="";
            //转换单词中的每个字母为摩尔斯密码
            for(char c:words[i]){
                tmp+=s[alp.find(c)];
            }
            //使用map容器存储，摩尔斯密码作为键，单词作为值，利用map中元素关键字不能重复的特性进行去重
            m[tmp]=words[i];
        }
        return m.size();
    }
};
```



<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

###### [官方题解](https://leetcode-cn.com/problems/unique-morse-code-words/solution/wei-yi-mo-er-si-mi-ma-ci-by-leetcode/):

**方法一：哈希集合**

我们将数组 `word` 中的每个单词转换为摩尔斯码，并加入哈希集合（HashSet）中，最终的答案即为哈希集合中元素的个数。

**Java代码：**(执行用时2ms，击败99.10%，内存消耗36.4M，击败82.85%）

```Java
class Solution {
    public int uniqueMorseRepresentations(String[] words) {
        String[] MORSE = new String[]{".-","-...","-.-.","-..",".","..-.","--.",
                         "....","..",".---","-.-",".-..","--","-.",
                         "---",".--.","--.-",".-.","...","-","..-",
                         "...-",".--","-..-","-.--","--.."};

        Set<String> seen = new HashSet();
        for (String word: words) {
            StringBuilder code = new StringBuilder();
            for (char c: word.toCharArray())
                code.append(MORSE[c - 'a']);
            seen.add(code.toString());
        }

        return seen.size();
    }
}
```

**复杂度分析**

- 时间复杂度：O(S)，其中 $S$ 是数组 `words` 中所有单词的长度之和。
- 空间复杂度：O(S)。



<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

###### 总结：

官方题解和我的思路一样，英雄所见略同😊，不过官方题解没给出c++实现只有Java和Python。另外在查找每个字母对应的摩尔斯码的时候，索引可以用字母和‘a’的差值来计算，不用像我那样去查找该字母在字母表中的位置。